From efa270eec499f02cfb949c0090e2d7409c729e1c Mon Sep 17 00:00:00 2001
From: Michal Schmidt <mschmidt@redhat.com>
Date: Tue, 24 Apr 2012 11:21:03 +0200
Subject: [PATCH] transaction: cancel jobs non-recursively on isolate

Recursive cancellation of jobs would trigger OnFailure actions of
dependent jobs. This is not desirable when isolating.

Fixes https://bugzilla.redhat.com/show_bug.cgi?id=798328
(cherry picked from commit 5273510e9f228a300ec6207d4502f1c6253aed5e)

Conflicts:

	src/core/transaction.c
	src/job.c
---
 src/dbus-job.c |    2 +-
 src/job.c      |   39 +++++++++++++++------------------------
 src/job.h      |    2 +-
 src/manager.c  |   13 ++++++-------
 src/unit.c     |   12 ++++++------
 5 files changed, 29 insertions(+), 39 deletions(-)

diff --git a/src/dbus-job.c b/src/dbus-job.c
index ab6d610..6b5a33d 100644
--- a/src/dbus-job.c
+++ b/src/dbus-job.c
@@ -100,7 +100,7 @@ static DBusHandlerResult bus_job_message_dispatch(Job *j, DBusConnection *connec
                 if (!(reply = dbus_message_new_method_return(message)))
                         goto oom;
 
-                job_finish_and_invalidate(j, JOB_CANCELED);
+                job_finish_and_invalidate(j, JOB_CANCELED, true);
 
         } else {
                 const BusBoundProperties bps[] = {
diff --git a/src/job.c b/src/job.c
index e57286f..ce4db75 100644
--- a/src/job.c
+++ b/src/job.c
@@ -464,13 +464,13 @@ int job_run_and_invalidate(Job *j) {
 
         if ((j = manager_get_job(m, id))) {
                 if (r == -EALREADY)
-                        r = job_finish_and_invalidate(j, JOB_DONE);
+                        r = job_finish_and_invalidate(j, JOB_DONE, true);
                 else if (r == -ENOEXEC)
-                        r = job_finish_and_invalidate(j, JOB_SKIPPED);
+                        r = job_finish_and_invalidate(j, JOB_SKIPPED, true);
                 else if (r == -EAGAIN)
                         j->state = JOB_WAITING;
                 else if (r < 0)
-                        r = job_finish_and_invalidate(j, JOB_FAILED);
+                        r = job_finish_and_invalidate(j, JOB_FAILED, true);
         }
 
         return r;
@@ -523,12 +523,11 @@ static void job_print_status_message(Unit *u, JobType t, JobResult result) {
         }
 }
 
-int job_finish_and_invalidate(Job *j, JobResult result) {
+int job_finish_and_invalidate(Job *j, JobResult result, bool recursive) {
         Unit *u;
         Unit *other;
         JobType t;
         Iterator i;
-        bool recursed = false;
 
         assert(j);
         assert(j->installed);
@@ -565,7 +564,7 @@ int job_finish_and_invalidate(Job *j, JobResult result) {
         job_print_status_message(u, t, result);
 
         /* Fail depending jobs on failure */
-        if (result != JOB_DONE) {
+        if (result != JOB_DONE && recursive) {
 
                 if (t == JOB_START ||
                     t == JOB_VERIFY_ACTIVE ||
@@ -575,29 +574,23 @@ int job_finish_and_invalidate(Job *j, JobResult result) {
                                 if (other->job &&
                                     (other->job->type == JOB_START ||
                                      other->job->type == JOB_VERIFY_ACTIVE ||
-                                     other->job->type == JOB_RELOAD_OR_START)) {
-                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY);
-                                        recursed = true;
-                                }
+                                     other->job->type == JOB_RELOAD_OR_START))
+                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY, true);
 
                         SET_FOREACH(other, u->dependencies[UNIT_BOUND_BY], i)
                                 if (other->job &&
                                     (other->job->type == JOB_START ||
                                      other->job->type == JOB_VERIFY_ACTIVE ||
-                                     other->job->type == JOB_RELOAD_OR_START)) {
-                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY);
-                                        recursed = true;
-                                }
+                                     other->job->type == JOB_RELOAD_OR_START))
+                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY, true);
 
                         SET_FOREACH(other, u->dependencies[UNIT_REQUIRED_BY_OVERRIDABLE], i)
                                 if (other->job &&
                                     !other->job->override &&
                                     (other->job->type == JOB_START ||
                                      other->job->type == JOB_VERIFY_ACTIVE ||
-                                     other->job->type == JOB_RELOAD_OR_START)) {
-                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY);
-                                        recursed = true;
-                                }
+                                     other->job->type == JOB_RELOAD_OR_START))
+                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY, true);
 
                 } else if (t == JOB_STOP) {
 
@@ -605,10 +598,8 @@ int job_finish_and_invalidate(Job *j, JobResult result) {
                                 if (other->job &&
                                     (other->job->type == JOB_START ||
                                      other->job->type == JOB_VERIFY_ACTIVE ||
-                                     other->job->type == JOB_RELOAD_OR_START)) {
-                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY);
-                                        recursed = true;
-                                }
+                                     other->job->type == JOB_RELOAD_OR_START))
+                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY, true);
                 }
         }
 
@@ -636,7 +627,7 @@ finish:
 
         manager_check_finished(u->manager);
 
-        return recursed;
+        return 0;
 }
 
 int job_start_timer(Job *j) {
@@ -728,7 +719,7 @@ void job_timer_event(Job *j, uint64_t n_elapsed, Watch *w) {
         assert(w == &j->timer_watch);
 
         log_warning("Job %s/%s timed out.", j->unit->id, job_type_to_string(j->type));
-        job_finish_and_invalidate(j, JOB_TIMEOUT);
+        job_finish_and_invalidate(j, JOB_TIMEOUT, true);
 }
 
 static const char* const job_state_table[_JOB_STATE_MAX] = {
diff --git a/src/job.h b/src/job.h
index 2121426..7c62a57 100644
--- a/src/job.h
+++ b/src/job.h
@@ -160,7 +160,7 @@ int job_start_timer(Job *j);
 void job_timer_event(Job *j, uint64_t n_elapsed, Watch *w);
 
 int job_run_and_invalidate(Job *j);
-int job_finish_and_invalidate(Job *j, JobResult result);
+int job_finish_and_invalidate(Job *j, JobResult result, bool recursive);
 
 char *job_dbus_path(Job *j);
 
diff --git a/src/manager.c b/src/manager.c
index 74bd740..16b0487 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -1222,18 +1222,16 @@ static int transaction_apply(Manager *m, JobMode mode) {
 
                 /* When isolating first kill all installed jobs which
                  * aren't part of the new transaction */
-        rescan:
                 HASHMAP_FOREACH(j, m->jobs, i) {
                         assert(j->installed);
 
                         if (hashmap_get(m->transaction_jobs, j->unit))
                                 continue;
 
-                        /* 'j' itself is safe to remove, but if other jobs
-                           are invalidated recursively, our iterator may become
-                           invalid and we need to start over. */
-                        if (job_finish_and_invalidate(j, JOB_CANCELED) > 0)
-                                goto rescan;
+                        /* Not invalidating recursively. Avoids triggering
+                         * OnFailure= actions of dependent jobs. Also avoids
+                         * invalidating our iterator. */
+                        job_finish_and_invalidate(j, JOB_CANCELED, false);
                 }
         }
 
@@ -1906,7 +1904,8 @@ void manager_clear_jobs(Manager *m) {
         transaction_abort(m);
 
         while ((j = hashmap_first(m->jobs)))
-                job_finish_and_invalidate(j, JOB_CANCELED);
+                /* No need to recurse. We're cancelling all jobs. */
+                job_finish_and_invalidate(j, JOB_CANCELED, false);
 }
 
 unsigned manager_dispatch_run_queue(Manager *m) {
diff --git a/src/unit.c b/src/unit.c
index 9e33701..3f6fd37 100644
--- a/src/unit.c
+++ b/src/unit.c
@@ -1223,12 +1223,12 @@ void unit_notify(Unit *u, UnitActiveState os, UnitActiveState ns, bool reload_su
                 case JOB_VERIFY_ACTIVE:
 
                         if (UNIT_IS_ACTIVE_OR_RELOADING(ns))
-                                job_finish_and_invalidate(u->job, JOB_DONE);
+                                job_finish_and_invalidate(u->job, JOB_DONE, true);
                         else if (u->job->state == JOB_RUNNING && ns != UNIT_ACTIVATING) {
                                 unexpected = true;
 
                                 if (UNIT_IS_INACTIVE_OR_FAILED(ns))
-                                        job_finish_and_invalidate(u->job, ns == UNIT_FAILED ? JOB_FAILED : JOB_DONE);
+                                        job_finish_and_invalidate(u->job, ns == UNIT_FAILED ? JOB_FAILED : JOB_DONE, true);
                         }
 
                         break;
@@ -1238,12 +1238,12 @@ void unit_notify(Unit *u, UnitActiveState os, UnitActiveState ns, bool reload_su
 
                         if (u->job->state == JOB_RUNNING) {
                                 if (ns == UNIT_ACTIVE)
-                                        job_finish_and_invalidate(u->job, reload_success ? JOB_DONE : JOB_FAILED);
+                                        job_finish_and_invalidate(u->job, reload_success ? JOB_DONE : JOB_FAILED, true);
                                 else if (ns != UNIT_ACTIVATING && ns != UNIT_RELOADING) {
                                         unexpected = true;
 
                                         if (UNIT_IS_INACTIVE_OR_FAILED(ns))
-                                                job_finish_and_invalidate(u->job, ns == UNIT_FAILED ? JOB_FAILED : JOB_DONE);
+                                                job_finish_and_invalidate(u->job, ns == UNIT_FAILED ? JOB_FAILED : JOB_DONE, true);
                                 }
                         }
 
@@ -1254,10 +1254,10 @@ void unit_notify(Unit *u, UnitActiveState os, UnitActiveState ns, bool reload_su
                 case JOB_TRY_RESTART:
 
                         if (UNIT_IS_INACTIVE_OR_FAILED(ns))
-                                job_finish_and_invalidate(u->job, JOB_DONE);
+                                job_finish_and_invalidate(u->job, JOB_DONE, true);
                         else if (u->job->state == JOB_RUNNING && ns != UNIT_DEACTIVATING) {
                                 unexpected = true;
-                                job_finish_and_invalidate(u->job, JOB_FAILED);
+                                job_finish_and_invalidate(u->job, JOB_FAILED, true);
                         }
 
                         break;
