Index: libs/libkexiv2/libkexiv2/msgtextedit.cpp
===================================================================
--- libs/libkexiv2/libkexiv2/msgtextedit.cpp	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/msgtextedit.cpp	(copie de travail)
@@ -6,32 +6,30 @@
  * Date        : 2009-07-15
  * Description : a text edit widget with click message.
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
  * Public License as published by the Free Software Foundation;
  * either version 2, or (at your option)
  * any later version.
- *
+ * 
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
+ * 
  * ============================================================ */
 
-#include "msgtextedit.moc"
-
 // Qt includes.
 
 #include <QColor>
 #include <QPalette>
 #include <QPainter>
 
-// KDE includes.
+// Local includes.
 
-#include <kdebug.h>
+#include "msgtextedit.moc"
 
 namespace KExiv2Iface
 {
@@ -45,10 +43,9 @@
     QString message;
 };
 
-MsgTextEdit::MsgTextEdit(QWidget *parent)
-           : KTextEdit(parent)
+MsgTextEdit::MsgTextEdit(QWidget* parent)
+           : KTextEdit(parent), d(new MsgTextEditPriv)
 {
-    d = new MsgTextEditPriv;
 }
 
 MsgTextEdit::~MsgTextEdit()
@@ -88,19 +85,19 @@
     }
 }
 
-void MsgTextEdit::dropEvent(QDropEvent *e)
+void MsgTextEdit::dropEvent(QDropEvent* e)
 {
     viewport()->repaint();
     KTextEdit::dropEvent(e);
 }
 
-void MsgTextEdit::focusInEvent(QFocusEvent *e)
+void MsgTextEdit::focusInEvent(QFocusEvent* e)
 {
     viewport()->repaint();
     KTextEdit::focusInEvent(e);
 }
 
-void MsgTextEdit::focusOutEvent(QFocusEvent *e)
+void MsgTextEdit::focusOutEvent(QFocusEvent* e)
 {
     viewport()->repaint();
     KTextEdit::focusOutEvent(e);
Index: libs/libkexiv2/libkexiv2/subjectwidget.cpp
===================================================================
--- libs/libkexiv2/libkexiv2/subjectwidget.cpp	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/subjectwidget.cpp	(copie de travail)
@@ -6,7 +6,7 @@
  * Date        : 2006-10-15
  * Description : IPTC subjects editor.
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  * Copyright (C) 2009      by Andi Clemens <andi dot clemens at gmx dot net>
  *
  * This program is free software; you can redistribute it
@@ -38,7 +38,6 @@
 // KDE includes
 
 #include <kcombobox.h>
-#include <kdebug.h>
 #include <kdialog.h>
 #include <kglobal.h>
 #include <khbox.h>
@@ -47,6 +46,7 @@
 #include <klistwidget.h>
 #include <klocale.h>
 #include <kstandarddirs.h>
+#include <kdebug.h>
 
 namespace KExiv2Iface
 {
@@ -79,32 +79,32 @@
         optionsBox       = 0;
     }
 
-    typedef QMap<QString, SubjectData>  SubjectCodesMap;
+    typedef QMap<QString, SubjectData> SubjectCodesMap;
 
-    SubjectCodesMap                     subMap;
+    SubjectCodesMap                    subMap;
 
-    QStringList                         subjectsList;
+    QStringList                        subjectsList;
 
-    QWidget                            *optionsBox;
+    QWidget*                           optionsBox;
 
-    QPushButton                        *addSubjectButton;
-    QPushButton                        *delSubjectButton;
-    QPushButton                        *repSubjectButton;
+    QPushButton*                       addSubjectButton;
+    QPushButton*                       delSubjectButton;
+    QPushButton*                       repSubjectButton;
 
-    QLabel                             *iprLabel;
-    QLabel                             *refLabel;
-    QLabel                             *nameLabel;
-    QLabel                             *matterLabel;
-    QLabel                             *detailLabel;
+    QLabel*                            iprLabel;
+    QLabel*                            refLabel;
+    QLabel*                            nameLabel;
+    QLabel*                            matterLabel;
+    QLabel*                            detailLabel;
 
-    QButtonGroup                       *btnGroup;
+    QButtonGroup*                      btnGroup;
 
-    QRadioButton                       *stdBtn;
-    QRadioButton                       *customBtn;
+    QRadioButton*                      stdBtn;
+    QRadioButton*                      customBtn;
 
-    KComboBox                          *refCB;
+    KComboBox*                         refCB;
 
-    KListWidget                        *subjectsBox;
+    KListWidget*                       subjectsBox;
 };
 
 // --------------------------------------------------------------------------------
@@ -120,7 +120,7 @@
     QString path = KGlobal::dirs()->findResource("iptcschema", "topicset.iptc-subjectcode.xml");
 
     if (!loadSubjectCodesFromXML(KUrl(path)))
-        kDebug(51001) << "Cannot load IPTC/NAA subject codes XML database";
+        kDebug() << "Cannot load IPTC/NAA subject codes XML database";
 
     // --------------------------------------------------------
 
@@ -130,19 +130,23 @@
 
     // --------------------------------------------------------
 
+    m_subjectsCheck  = new QCheckBox(i18n("Use structured definition of the subject matter:"), this);
     d->optionsBox    = new QWidget;
     d->btnGroup      = new QButtonGroup(this);
     d->stdBtn        = new QRadioButton;
     d->customBtn     = new QRadioButton;
     d->refCB         = new KComboBox;
-    QLabel *codeLink = new QLabel(i18n("Use standard "
+    QLabel* codeLink = new QLabel(i18n("Use standard "
                                        "<b><a href='http://www.iptc.org/NewsCodes'>"
                                        "reference code</a></b>"));
     codeLink->setOpenExternalLinks(true);
     codeLink->setWordWrap(false);
 
-    QLabel *customLabel = new QLabel(i18n("Use custom definition"));
+    // By default, check box is not visible. (digiKam do not use it, kipi-plugins yes).
+    m_subjectsCheck->setVisible(false);
 
+    QLabel* customLabel = new QLabel(i18n("Use custom definition"));
+
     d->btnGroup->addButton(d->stdBtn,    SubjectWidgetPriv::STANDARD);
     d->btnGroup->addButton(d->customBtn, SubjectWidgetPriv::CUSTOM);
     d->btnGroup->setExclusive(true);
@@ -219,7 +223,7 @@
 
     // --------------------------------------------------------
 
-    QGridLayout *optionsBoxLayout = new QGridLayout;
+    QGridLayout* optionsBoxLayout = new QGridLayout;
     optionsBoxLayout->addWidget(d->stdBtn,      0, 0, 1, 1);
     optionsBoxLayout->addWidget(codeLink,       0, 1, 1, 2);
     optionsBoxLayout->addWidget(d->refCB,       0, 3, 1, 1);
@@ -242,15 +246,16 @@
 
     // --------------------------------------------------------
 
-    QGridLayout *mainLayout = new QGridLayout;
+    QGridLayout* mainLayout = new QGridLayout;
     mainLayout->setAlignment( Qt::AlignTop );
-    mainLayout->addWidget(d->optionsBox,       0, 0, 1, 4);
-    mainLayout->addWidget(d->subjectsBox,      1, 0, 5, 3);
-    mainLayout->addWidget(d->addSubjectButton, 1, 3, 1, 1);
-    mainLayout->addWidget(d->delSubjectButton, 2, 3, 1, 1);
-    mainLayout->addWidget(d->repSubjectButton, 3, 3, 1, 1);
-    mainLayout->addWidget(m_note,              4, 3, 1, 1);
-    mainLayout->setRowStretch(5, 10);
+    mainLayout->addWidget(m_subjectsCheck,     0, 0, 1, 4);
+    mainLayout->addWidget(d->optionsBox,       1, 0, 1, 4);
+    mainLayout->addWidget(d->subjectsBox,      2, 0, 5, 3);
+    mainLayout->addWidget(d->addSubjectButton, 2, 3, 1, 1);
+    mainLayout->addWidget(d->delSubjectButton, 3, 3, 1, 1);
+    mainLayout->addWidget(d->repSubjectButton, 4, 3, 1, 1);
+    mainLayout->addWidget(m_note,              5, 3, 1, 1);
+    mainLayout->setRowStretch(6, 10);
     mainLayout->setColumnStretch(2, 1);
     mainLayout->setMargin(0);
     mainLayout->setSpacing(KDialog::spacingHint());
@@ -278,6 +283,14 @@
 
     // --------------------------------------------------------
 
+    connect(m_subjectsCheck, SIGNAL(toggled(bool)),
+            this, SLOT(slotSubjectsToggled(bool)));
+
+    // --------------------------------------------------------
+
+    connect(m_subjectsCheck, SIGNAL(toggled(bool)),
+            this, SIGNAL(signalModified()));
+
     connect(d->addSubjectButton, SIGNAL(clicked()),
             this, SIGNAL(signalModified()));
 
@@ -297,6 +310,16 @@
     delete d;
 }
 
+void SubjectWidget::slotSubjectsToggled(bool b)
+{
+    d->optionsBox->setEnabled(b);
+    d->subjectsBox->setEnabled(b);
+    d->addSubjectButton->setEnabled(b);
+    d->delSubjectButton->setEnabled(b);
+    d->repSubjectButton->setEnabled(b);
+    slotEditOptionChanged(d->btnGroup->id(d->btnGroup->checkedButton()));
+}
+
 void SubjectWidget::slotEditOptionChanged(int b)
 {
     if (b == SubjectWidgetPriv::CUSTOM)
@@ -358,7 +381,7 @@
 
 void SubjectWidget::slotDelSubject()
 {
-    QListWidgetItem *item = d->subjectsBox->currentItem();
+    QListWidgetItem* item = d->subjectsBox->currentItem();
     if (!item) return;
     d->subjectsBox->takeItem(d->subjectsBox->row(item));
     delete item;
@@ -408,7 +431,7 @@
     bool found = false;
     for (int i = 0 ; i < d->subjectsBox->count(); i++)
     {
-        QListWidgetItem *item = d->subjectsBox->item(i);
+        QListWidgetItem* item = d->subjectsBox->item(i);
         if (newSubject == item->text())
         {
             found = true;
@@ -499,7 +522,7 @@
          it != d->subMap.end(); ++it)
     {
         QString name, keyPrefix;
-        if (it.key().endsWith("00000"))
+        if (it.key().endsWith(QLatin1String("00000")))
         {
             keyPrefix = it.key().left(3);
             name      = it.value().name;
@@ -508,7 +531,7 @@
                 it2 != d->subMap.end(); ++it2)
             {
                 if (it2.key().startsWith(keyPrefix) &&
-                    !it2.key().endsWith("00000"))
+                    !it2.key().endsWith(QLatin1String("00000")))
                 {
                     it2.value().name = name;
                 }
@@ -522,7 +545,7 @@
          it != d->subMap.end(); ++it)
     {
         QString matter, keyPrefix;
-        if (it.key().endsWith("000"))
+        if (it.key().endsWith(QLatin1String("000")))
         {
             keyPrefix = it.key().left(5);
             matter    = it.value().matter;
@@ -531,7 +554,7 @@
                 it2 != d->subMap.end(); ++it2)
             {
                 if (it2.key().startsWith(keyPrefix) &&
-                    !it2.key().endsWith("000"))
+                    !it2.key().endsWith(QLatin1String("000")))
                 {
                     it2.value().matter = matter;
                 }
@@ -542,16 +565,21 @@
     return true;
 }
 
-void SubjectWidget::setSubjectList(const QStringList& list)
+void SubjectWidget::setSubjectsList(const QStringList& list)
 {
     d->subjectsList = list;
 
     blockSignals(true);
     d->subjectsBox->clear();
+    m_subjectsCheck->setChecked(false);
     if (!d->subjectsList.isEmpty())
+    {
         d->subjectsBox->insertItems(0, d->subjectsList);
+        m_subjectsCheck->setChecked(true);
+    }
 
     blockSignals(false);
+    slotSubjectsToggled(m_subjectsCheck->isChecked());
 }
 
 QStringList SubjectWidget::subjectsList() const
@@ -560,7 +588,7 @@
 
     for (int i = 0 ; i < d->subjectsBox->count(); i++)
     {
-        QListWidgetItem *item = d->subjectsBox->item(i);
+        QListWidgetItem* item = d->subjectsBox->item(i);
         newSubjects.append(item->text());
     }
 
Index: libs/libkexiv2/libkexiv2/countryselector.cpp
===================================================================
--- libs/libkexiv2/libkexiv2/countryselector.cpp	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/countryselector.cpp	(copie de travail)
@@ -6,7 +6,7 @@
  * Date        : 2009-07-07
  * Description : country selector combo-box.
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -30,8 +30,8 @@
 
 // KDE includes
 
+#include <klocale.h>
 #include <kdebug.h>
-#include <klocale.h>
 
 namespace KExiv2Iface
 {
Index: libs/libkexiv2/libkexiv2/msgtextedit.h
===================================================================
--- libs/libkexiv2/libkexiv2/msgtextedit.h	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/msgtextedit.h	(copie de travail)
@@ -5,38 +5,39 @@
  *
  * Date        : 2009-07-15
  * Description : a text edit widget with click message.
- * 
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
  * Public License as published by the Free Software Foundation;
  * either version 2, or (at your option)
  * any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * ============================================================ */
 
 #ifndef MSGTEXTEDIT_H
 #define MSGTEXTEDIT_H
 
-// Qt includes.
+// Qt includes
 
 #include <QWidget>
 #include <QString>
 
-// KDE includes.
+// KDE includes
 
 #include <ktextedit.h>
 
-// Local includes
+// Local includes.
 
 #include "libkexiv2_export.h"
 
+
 namespace KExiv2Iface
 {
 
@@ -48,7 +49,7 @@
 
 public:
 
-    MsgTextEdit(QWidget *parent);
+    MsgTextEdit(QWidget* parent);
     ~MsgTextEdit();
 
     void    setClickMessage(const QString& msg);
@@ -65,7 +66,7 @@
 
 private:
 
-    MsgTextEditPriv* d;
+    MsgTextEditPriv* const d;
 };
 
 }  // namespace KExiv2Iface
Index: libs/libkexiv2/libkexiv2/subjectwidget.h
===================================================================
--- libs/libkexiv2/libkexiv2/subjectwidget.h	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/subjectwidget.h	(copie de travail)
@@ -6,7 +6,7 @@
  * Date        : 2006-10-15
  * Description : IPTC subjects editor.
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  * Copyright (C) 2009      by Andi Clemens <andi dot clemens at gmx dot net>
  *
  * This program is free software; you can redistribute it
@@ -31,20 +31,18 @@
 #include <QtCore/QMap>
 #include <QtCore/QStringList>
 #include <QtGui/QWidget>
+#include <QtGui/QCheckBox>
+#include <QtGui/QLabel>
 
 // KDE includes
 
 #include <kurl.h>
+#include <klineedit.h>
 
-// Local includes
+// Local includes.
 
 #include "libkexiv2_export.h"
 
-class QCheckBox;
-class QLabel;
-
-class KLineEdit;
-
 namespace KExiv2Iface
 {
 
@@ -77,7 +75,7 @@
     SubjectWidget(QWidget* parent);
     ~SubjectWidget();
 
-    void setSubjectList(const QStringList& list);
+    void setSubjectsList(const QStringList& list);
     QStringList subjectsList() const;
 
 Q_SIGNALS:
@@ -86,6 +84,7 @@
 
 protected Q_SLOTS:
 
+    virtual void slotSubjectsToggled(bool);
     virtual void slotRefChanged();
     virtual void slotEditOptionChanged(int);
     virtual void slotSubjectSelectionChanged();
@@ -100,14 +99,16 @@
 
 protected:
 
-    QLabel    *m_note;
+    QLabel*    m_note;
 
-    KLineEdit *m_iprEdit;
-    KLineEdit *m_refEdit;
-    KLineEdit *m_nameEdit;
-    KLineEdit *m_matterEdit;
-    KLineEdit *m_detailEdit;
+    QCheckBox* m_subjectsCheck;
 
+    KLineEdit* m_iprEdit;
+    KLineEdit* m_refEdit;
+    KLineEdit* m_nameEdit;
+    KLineEdit* m_matterEdit;
+    KLineEdit* m_detailEdit;
+
 private:
 
     SubjectWidgetPriv* const d;
Index: libs/libkexiv2/libkexiv2/version.h.cmake
===================================================================
--- libs/libkexiv2/libkexiv2/version.h.cmake	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/version.h.cmake	(copie de travail)
@@ -6,7 +6,7 @@
  * Date        : 2007-02-06
  * Description : Exiv2 library interface for KDE
  *
- * Copyright (C) 2007-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2007-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
Index: libs/libkexiv2/libkexiv2/countryselector.h
===================================================================
--- libs/libkexiv2/libkexiv2/countryselector.h	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/countryselector.h	(copie de travail)
@@ -6,7 +6,7 @@
  * Date        : 2009-07-07
  * Description : country selector combo-box.
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -33,7 +33,7 @@
 
 #include <kcombobox.h>
 
-// Local includes
+// Local includes.
 
 #include "libkexiv2_export.h"
 
Index: libs/libkexiv2/libkexiv2/kexiv2image.cpp
===================================================================
--- libs/libkexiv2/libkexiv2/kexiv2image.cpp	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/kexiv2image.cpp	(copie de travail)
@@ -265,6 +265,46 @@
             return imageOrient;
         }
 
+        // -- Sony Cameras ----------------------------------
+
+        Exiv2::ExifKey sonyKey1("Exif.Sony1Cs.Rotation");
+        it = exifData.findKey(sonyKey1);
+
+        if (it != exifData.end())
+        {
+            orientation = it->toLong();
+            kDebug(51003) << "Orientation => Exif.Sony1Cs.Rotation => " << (int)orientation << endl;
+            switch(orientation)
+            {
+                case 1:
+                    imageOrient = ORIENTATION_ROT_90;
+                    break;
+                case 2:
+                    imageOrient = ORIENTATION_ROT_270;
+                    break;
+            }
+            return imageOrient;
+        }
+
+        Exiv2::ExifKey sonyKey2("Exif.Sony2Cs.Rotation");
+        it = exifData.findKey(sonyKey2);
+
+        if (it != exifData.end())
+        {
+            orientation = it->toLong();
+            kDebug(51003) << "Orientation => Exif.Sony2Cs.Rotation => " << (int)orientation << endl;
+            switch(orientation)
+            {
+                case 1:
+                    imageOrient = ORIENTATION_ROT_90;
+                    break;
+                case 2:
+                    imageOrient = ORIENTATION_ROT_270;
+                    break;
+            }
+            return imageOrient;
+        }
+
         // -- Standard Exif tag --------------------------------
 
         Exiv2::ExifKey keyStd("Exif.Image.Orientation");
Index: libs/libkexiv2/libkexiv2/altlangstredit.cpp
===================================================================
--- libs/libkexiv2/libkexiv2/altlangstredit.cpp	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/altlangstredit.cpp	(copie de travail)
@@ -6,12 +6,13 @@
  * Date        : 2009-06-15
  * Description : multi-languages string editor
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
  * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
+ * either version 2, or (at your option)
+ * any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -240,27 +241,27 @@
         languageCodeMap.insert( "zu-ZA", i18n("isiZulu Zulu (South Africa)") );
     }
 
-    typedef QMap<QString, QString>  LanguageCodeMap;
+    typedef QMap<QString, QString> LanguageCodeMap;
 
-    LanguageCodeMap                 languageCodeMap;
+    LanguageCodeMap                languageCodeMap;
 
-    QString                         currentLanguage;
+    QString                        currentLanguage;
 
-    QLabel                         *titleLabel;
+    QLabel*                        titleLabel;
 
-    QToolButton                    *delValueButton;
+    QToolButton*                   delValueButton;
 
-    MsgTextEdit                    *valueEdit;
+    MsgTextEdit*                   valueEdit;
 
-    KComboBox                      *languageCB;
+    KComboBox*                     languageCB;
 
-    KExiv2::AltLangMap              values;
+    KExiv2::AltLangMap             values;
 };
 
 AltLangStrEdit::AltLangStrEdit(QWidget* parent)
               : QWidget(parent), d(new AltLangStrEditPriv)
 {
-    QGridLayout *grid = new QGridLayout(this);
+    QGridLayout* grid = new QGridLayout(this);
     d->titleLabel     = new QLabel(this);
     d->delValueButton = new QToolButton(this);
     d->delValueButton->setIcon(SmallIcon("edit-clear"));
@@ -346,7 +347,7 @@
     d->valueEdit->blockSignals(true);
 
     QString langISO3066 = d->currentLanguage;
-    langISO3066.replace("-", "_");
+    langISO3066.replace('-', '_');
     d->valueEdit->setSpellCheckingLanguage(langISO3066);
 
     QString text = d->values.value(d->currentLanguage);
@@ -390,7 +391,7 @@
     QStringList list = d->values.keys();
     if (!list.isEmpty())
     {
-        foreach (QString item, list)
+        foreach (const QString &item, list)
         {
               d->languageCB->addItem(item);
               d->languageCB->setItemIcon(d->languageCB->count()-1, SmallIcon("dialog-ok"));
Index: libs/libkexiv2/libkexiv2/kexiv2exif.cpp
===================================================================
--- libs/libkexiv2/libkexiv2/kexiv2exif.cpp	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/kexiv2exif.cpp	(copie de travail)
@@ -261,6 +261,13 @@
             {
                 // write as Unicode (UCS-2)
 
+            #if (EXIV2_TEST_VERSION(0,20,0))
+                std::string exifComment("charset=\"Unicode\" ");
+                exifComment += comment.toUtf8().constData();
+                d->exifMetadata()["Exif.Photo.UserComment"] = exifComment;
+            #else
+                // Older versions took a UCS2-String, see bug #205824
+
                 // Be aware that we are dealing with a UCS-2 string.
                 // Null termination means \0\0, strlen does not work,
                 // do not use any const-char*-only methods,
@@ -269,6 +276,7 @@
                 std::string exifComment("charset=\"Unicode\" ");
                 exifComment.append((const char*)ucs2, sizeof(unsigned short) * comment.length());
                 d->exifMetadata()["Exif.Photo.UserComment"] = exifComment;
+            #endif
             }
         }
         return true;
Index: libs/libkexiv2/libkexiv2/rotationmatrix.cpp
===================================================================
--- libs/libkexiv2/libkexiv2/rotationmatrix.cpp	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/rotationmatrix.cpp	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2009-08-03
  * Description : Tools for combining rotation operations
  *
- * Copyright (C) 2004-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2004-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -21,8 +21,6 @@
  *
  * ============================================================ */
 
-// Qt includes
-
 // KDE includes
 
 #include <kdebug.h>
@@ -64,7 +62,7 @@
    matrices defined below.
    (I did not proof that mathematically, but empirically)
 
-   static const RotationMatrix identity;                   //( 1,  0,  0,  1)
+   static const RotationMatrix identity;               //( 1,  0,  0,  1)
    static const RotationMatrix rotate90;               //( 0, -1,  1,  0)
    static const RotationMatrix rotate180;              //(-1,  0,  0, -1)
    static const RotationMatrix rotate270;              //( 0,  1, -1,  0)
@@ -77,6 +75,7 @@
 
 namespace Matrix
 {
+
 static const RotationMatrix identity               ( 1,  0,  0,  1);
 static const RotationMatrix rotate90               ( 0, -1,  1,  0);
 static const RotationMatrix rotate180              (-1,  0,  0, -1);
@@ -133,7 +132,7 @@
 }
 
 
-}
+} // namespace Matrix
 
 RotationMatrix::RotationMatrix()
 {
@@ -168,14 +167,14 @@
     return *this == Matrix::identity;
 }
 
-RotationMatrix &RotationMatrix::operator*=(const RotationMatrix &ma)
+RotationMatrix& RotationMatrix::operator*=(const RotationMatrix& ma)
 {
     set( ma.m[0][0]*m[0][0] + ma.m[0][1]*m[1][0],  ma.m[0][0]*m[0][1] + ma.m[0][1]*m[1][1],
          ma.m[1][0]*m[0][0] + ma.m[1][1]*m[1][0],  ma.m[1][0]*m[0][1] + ma.m[1][1]*m[1][1] );
          return *this;
 }
 
-bool RotationMatrix::operator==(const RotationMatrix &ma) const
+bool RotationMatrix::operator==(const RotationMatrix& ma) const
 {
     return m[0][0]==ma.m[0][0] &&
     m[0][1]==ma.m[0][1] &&
@@ -183,24 +182,24 @@
     m[1][1]==ma.m[1][1];
 }
 
-bool RotationMatrix::operator!=(const RotationMatrix &ma) const
+bool RotationMatrix::operator!=(const RotationMatrix& ma) const
 {
     return !(*this==ma);
 }
 
-RotationMatrix &RotationMatrix::operator*=(TransformationAction action)
+RotationMatrix& RotationMatrix::operator*=(TransformationAction action)
 {
     return (*this *= Matrix::matrix(action));
 }
 
-RotationMatrix &RotationMatrix::operator*=(QList<TransformationAction> actions)
+RotationMatrix& RotationMatrix::operator*=(QList<TransformationAction> actions)
 {
     foreach (TransformationAction action, actions)
         *this *= Matrix::matrix(action);
     return *this;
 }
 
-RotationMatrix &RotationMatrix::operator*=(KExiv2::ImageOrientation exifOrientation)
+RotationMatrix& RotationMatrix::operator*=(KExiv2::ImageOrientation exifOrientation)
 {
     return (*this *= Matrix::matrix(exifOrientation));
 }
Index: libs/libkexiv2/libkexiv2/altlangstredit.h
===================================================================
--- libs/libkexiv2/libkexiv2/altlangstredit.h	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/altlangstredit.h	(copie de travail)
@@ -6,12 +6,13 @@
  * Date        : 2009-06-15
  * Description : multi-languages string editor
  *
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
  * Public License as published by the Free Software Foundation;
- * either version 2, or (at your option) any later version.
+ * either version 2, or (at your option)
+ * any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -28,10 +29,10 @@
 #include <QtGui/QWidget>
 #include <QtCore/QString>
 
-// Local includes
+// Local includes.
 
+#include "libkexiv2_export.h"
 #include "kexiv2.h"
-#include "libkexiv2_export.h"
 
 namespace KExiv2Iface
 {
Index: libs/libkexiv2/libkexiv2/kexiv2_p.cpp
===================================================================
--- libs/libkexiv2/libkexiv2/kexiv2_p.cpp	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/kexiv2_p.cpp	(copie de travail)
@@ -93,10 +93,16 @@
 
         if (charset == "\"Unicode\"")
         {
+        #if (EXIV2_TEST_VERSION(0,20,0))
+            return QString::fromUtf8(comment.data());
+        #else
+            // Older versions give a UCS2-String, see bug #205824
+
             // QString expects a null-terminated UCS-2 string.
             // Is it already null terminated? In any case, add termination "\0\0" for safety.
             comment.resize(comment.length() + 2, '\0');
             return QString::fromUtf16((unsigned short *)comment.data());
+        #endif
         }
         else if (charset == "\"Jis\"")
         {
Index: libs/libkexiv2/libkexiv2/rotationmatrix.h
===================================================================
--- libs/libkexiv2/libkexiv2/rotationmatrix.h	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/rotationmatrix.h	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2009-08-03
  * Description : Tools for combining rotation operations
  *
- * Copyright (C) 2004-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2004-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -44,12 +44,12 @@
      */
     enum TransformationAction
     {
-        NoTransformation = 0,/// no transformation
-        FlipHorizontal = 1,  /// horizontal flip
-        FlipVertical = 2,    /// vertical flip
-        Rotate90 = 5,        /// 90-degree clockwise rotation
-        Rotate180 = 6,       /// 180-degree rotation
-        Rotate270 = 7        /// 270-degree clockwise (or 90 ccw)
+        NoTransformation = 0, /// no transformation
+        FlipHorizontal   = 1, /// horizontal flip
+        FlipVertical     = 2, /// vertical flip
+        Rotate90         = 5, /// 90-degree clockwise rotation
+        Rotate180        = 6, /// 180-degree rotation
+        Rotate270        = 7  /// 270-degree clockwise (or 90 ccw)
     };
 
     /// Constructs the identity matrix (the matrix describing no transformation)
@@ -57,24 +57,24 @@
     /// Returns the matrix corresponding to the given TransformationAction
     RotationMatrix(TransformationAction action);
     /// Returns the matrix corresponding to the given TransformationAction
-    RotationMatrix(KExiv2Iface::KExiv2::ImageOrientation exifOrientation);
+    RotationMatrix(KExiv2::ImageOrientation exifOrientation);
 
-    bool operator==(const RotationMatrix &ma) const;
-    bool operator!=(const RotationMatrix &ma) const;
+    bool operator==(const RotationMatrix& ma) const;
+    bool operator!=(const RotationMatrix& ma) const;
 
     /// Returns true of this matrix describes no transformation (is the identity matrix)
     bool isNoTransform() const;
 
-    RotationMatrix &operator*=(const RotationMatrix &ma);
+    RotationMatrix& operator*=(const RotationMatrix& ma);
 
     /// Applies the given transform to this matrix
-    RotationMatrix &operator*=(TransformationAction action);
+    RotationMatrix& operator*=(TransformationAction action);
 
     /// Applies the given transform actions to this matrix
-    RotationMatrix &operator*=(QList<TransformationAction> actions);
+    RotationMatrix& operator*=(QList<TransformationAction> actions);
 
     /// Applies the given Exif orientation flag to this matrix
-    RotationMatrix &operator*=(KExiv2Iface::KExiv2::ImageOrientation exifOrientation);
+    RotationMatrix& operator*=(KExiv2::ImageOrientation exifOrientation);
 
     /** Returns the actions described by this matrix. The order matters.
      *  Not all possible matrices are supported, but all those that can be combined
@@ -85,7 +85,7 @@
     /** Returns the Exif orienation flag describing this matrix.
      *  Returns ORIENTATION_UNSPECIFIED if no flag matches this matrix.
      */
-    KExiv2Iface::KExiv2::ImageOrientation exifOrientation() const;
+    KExiv2::ImageOrientation exifOrientation() const;
 
     RotationMatrix(int m11, int m12, int m21, int m22);
 
Index: libs/libkexiv2/libkexiv2/CMakeLists.txt
===================================================================
--- libs/libkexiv2/libkexiv2/CMakeLists.txt	(révision 1122317)
+++ libs/libkexiv2/libkexiv2/CMakeLists.txt	(copie de travail)
@@ -51,4 +51,4 @@
               ${CMAKE_CURRENT_BINARY_DIR}/version.h
         DESTINATION ${INCLUDE_INSTALL_DIR}/libkexiv2 COMPONENT Devel)
 
-INSTALL(FILES topicset.iptc-subjectcode.xml DESTINATION ${DATA_INSTALL_DIR}/libkexiv2/data)
\ No newline at end of file
+INSTALL(FILES topicset.iptc-subjectcode.xml DESTINATION ${DATA_INSTALL_DIR}/libkexiv2/data)
Index: libs/libkexiv2/test/setiptcpreview.cpp
===================================================================
--- libs/libkexiv2/test/setiptcpreview.cpp	(révision 1122317)
+++ libs/libkexiv2/test/setiptcpreview.cpp	(copie de travail)
@@ -31,15 +31,9 @@
 
 #include "kdeversion.h"
 
-#if KDE_IS_VERSION(4,0,0)
 #include "qdebug.h"
 #define PRINT_DEBUG qDebug()
 #define ENDL
-#else
-#include "kdebug.h"
-#define PRINT_DEBUG kDebug()
-#define ENDL << endl
-#endif
 
 // Local includes.
 
Index: libs/libkexiv2/CMakeLists.txt
===================================================================
--- libs/libkexiv2/CMakeLists.txt	(révision 1122317)
+++ libs/libkexiv2/CMakeLists.txt	(copie de travail)
@@ -20,10 +20,11 @@
 # 0.5.0 => 7.2.0     (Released with KDE 4.2.0)
 # 0.6.0 => 7.3.0     (Released with KDE 4.3.0)
 # 1.0.0 => 8.0.0     (Released with KDE 4.4.0)
+# 1.1.0 => 8.1.0     (Released with KDE 4.5.0)
 
 # Library API version
 SET(KEXIV2_LIB_MAJOR_VERSION "1")
-SET(KEXIV2_LIB_MINOR_VERSION "0")
+SET(KEXIV2_LIB_MINOR_VERSION "1")
 SET(KEXIV2_LIB_PATCH_VERSION "0")
 
 # Suffix to add at end of version string. Usual values are:
@@ -38,7 +39,7 @@
 # Library ABI version used by linker.
 # For details : http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info
 SET(KEXIV2_LIB_SO_CUR_VERSION "8")
-SET(KEXIV2_LIB_SO_REV_VERSION "0")
+SET(KEXIV2_LIB_SO_REV_VERSION "1")
 SET(KEXIV2_LIB_SO_AGE_VERSION "0")
 
 # =======================================================
Index: libs/libkdcraw/test/raw2png.cpp
===================================================================
--- libs/libkdcraw/test/raw2png.cpp	(révision 1122317)
+++ libs/libkdcraw/test/raw2png.cpp	(copie de travail)
@@ -30,15 +30,9 @@
 
 #include "kdeversion.h"
 
-#if KDE_IS_VERSION(4,0,0)
 #include "qdebug.h"
 #define PRINT_DEBUG qDebug()
 #define ENDL
-#else
-#include "kdebug.h"
-#define PRINT_DEBUG kdDebug()
-#define ENDL << endl
-#endif
 
 // Local includes.
 
Index: libs/libkdcraw/libraw/LICENSE.LGPL
===================================================================
--- libs/libkdcraw/libraw/LICENSE.LGPL	(révision 0)
+++ libs/libkdcraw/libraw/LICENSE.LGPL	(révision 0)
@@ -0,0 +1,458 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
Index: libs/libkdcraw/libraw/libraw/libraw_alloc.h
===================================================================
--- libs/libkdcraw/libraw/libraw/libraw_alloc.h	(révision 1122317)
+++ libs/libkdcraw/libraw/libraw/libraw_alloc.h	(copie de travail)
@@ -1,24 +1,22 @@
 /* -*- C++ -*-
  * File: libraw_alloc.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  22, 2008 
  *
  * LibRaw C++ interface
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef __LIBRAW_ALLOC_H
Index: libs/libkdcraw/libraw/libraw/libraw_internal.h
===================================================================
--- libs/libkdcraw/libraw/libraw/libraw_internal.h	(révision 1122317)
+++ libs/libkdcraw/libraw/libraw/libraw_internal.h	(copie de travail)
@@ -1,24 +1,22 @@
 /* -*- C++ -*-
  * File: libraw_internal.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw internal data structures (not visible outside)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef _LIBRAW_INTERNAL_TYPES_H
@@ -61,7 +59,6 @@
     {
          unsigned pad[128], p;
     }sony_decrypt;
-    unsigned foveon_decoder_huff[1024];
     uchar jpeg_buffer[4096];
     struct
     {
Index: libs/libkdcraw/libraw/libraw/libraw.h
===================================================================
--- libs/libkdcraw/libraw/libraw/libraw.h	(révision 1122317)
+++ libs/libkdcraw/libraw/libraw/libraw.h	(copie de travail)
@@ -1,26 +1,25 @@
 /* -*- C++ -*-
  * File: libraw.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8, 2008 
  *
  * LibRaw C++ interface
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
- */
 
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+*/
+
 #ifndef _LIBRAW_CLASS_H
 #define _LIBRAW_CLASS_H
 
@@ -100,6 +99,7 @@
     int                         unpack_thumb(void);
 
     int                         adjust_sizes_info_only(void);
+    int                         adjust_maximum();
     void                        set_memerror_handler( memory_callback cb,void *data) {callbacks.memcb_data = data; callbacks.mem_cb = cb; }
     void                        set_dataerror_handler(data_callback func, void *data) { callbacks.datacb_data = data; callbacks.data_cb = func;}
     void                        set_progress_handler(progress_callback pcb, void *data) { callbacks.progresscb_data = data; callbacks.progress_cb = pcb;}
@@ -124,6 +124,8 @@
     void         recycle(); 
     ~LibRaw(void) { recycle(); delete tls; }
 
+    int COLOR(int row, int col) { return libraw_internal_data.internal_output_params.fuji_width? FCF(row,col):FC(row,col);}
+
     int FC(int row,int col) { return (imgdata.idata.filters >> ((((row) << 1 & 14) + ((col) & 1)) << 1) & 3);}
     int         fc (int row, int col);
     int add_masked_borders_to_bitmap();
@@ -132,6 +134,19 @@
     int         rotate_fuji_raw();
 
   private:
+
+    int FCF(int row,int col) { 
+        int rr,cc;
+        if (libraw_internal_data.unpacker_data.fuji_layout) {
+            rr = libraw_internal_data.internal_output_params.fuji_width - 1 - col + (row >> 1);
+            cc = col + ((row+1) >> 1);
+        } else {
+            rr = libraw_internal_data.internal_output_params.fuji_width - 1 + row - (col >> 1);
+            cc = row + ((col+1) >> 1);
+        }
+        return FC(rr,cc);
+    }
+
     void*        malloc(size_t t);
     void*        calloc(size_t n,size_t t);
     void        free(void *p);
@@ -153,8 +168,6 @@
 
     void        kodak_thumb_loader();
     void        write_thumb_ppm_tiff(FILE *); 
-    void        foveon_thumb_loader (void);
-
     
     void init_masked_ptrs();
     ushort *get_masked_pointer(int row, int col); 
@@ -188,7 +201,6 @@
     void        fuji_rotate();
     void        stretch();
 
-    void        foveon_thumb ();
     void        jpeg_thumb_writer (FILE *tfp,char *thumb,int thumb_length);
     void        jpeg_thumb ();
     void        ppm_thumb ();
@@ -196,7 +208,6 @@
     void        rollei_thumb ();
     void        kodak_thumb_load_raw();
 
-    void        foveon_decoder (unsigned size, unsigned code);
     unsigned    get4();
 
     int         flip_index (int row, int col);
Index: libs/libkdcraw/libraw/libraw/libraw_types.h
===================================================================
--- libs/libkdcraw/libraw/libraw/libraw_types.h	(révision 1122317)
+++ libs/libkdcraw/libraw/libraw/libraw_types.h	(copie de travail)
@@ -1,24 +1,23 @@
 /* -*- C++ -*-
  * File: libraw_types.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw C data structures
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef _LIBRAW_TYPES_H
@@ -30,6 +29,9 @@
 #endif
 #include <stdio.h>
 #ifdef _OPENMP
+#ifdef _MSC_VER
+#error OpenMP is not supported under MS Visual Studio
+#endif
 #include <omp.h>
 #endif
 
@@ -102,9 +104,11 @@
                 width,
                 colors,
                 bits;
+#ifdef LIBRAW_LIBRARY_BUILD
 #ifdef _OPENMP
 #pragma omp firstprivate(colors,height,width)
 #endif
+#endif
     unsigned int  data_size; 
     unsigned char data[1]; 
 }libraw_processed_image_t;
@@ -117,7 +121,6 @@
 
     unsigned    raw_count;
     unsigned    dng_version;
-    unsigned    is_foveon;
     int         colors;
 
     unsigned    filters; 
@@ -135,9 +138,11 @@
                 left_margin;
     ushort      iheight,
                 iwidth;
+#ifdef LIBRAW_LIBRARY_BUILD
 #ifdef _OPENMP
 #pragma omp firstprivate(iheight,iwidth)
 #endif
+#endif
     double      pixel_aspect;
     int         flip;
 
@@ -174,6 +179,7 @@
     ushort      curve[0x10000]; 
     unsigned    black;
     unsigned    maximum;
+    unsigned    channel_maximum[4];
     struct ph1_t       phase_one_data;
     float       flash_used; 
     float       canon_ev; 
@@ -215,9 +221,11 @@
     unsigned    shot_select;    /* -s */
     float       bright;         /* -b */
     float       threshold;      /*  -n */
+#ifdef LIBRAW_LIBRARY_BUILD
 #ifdef _OPENMP
 #pragma omp firstprivate(threshold)
 #endif
+#endif
     int         half_size;      /* -h */
     int         four_color_rgb; /* -f */
     int         document_mode;  /* -d/-D */
@@ -239,6 +247,7 @@
 
     int         med_passes;     /* -m */
     float       auto_bright_thr; 
+    float       adjust_maximum_thr;
     int         no_auto_bright; /* -W */
     int         use_fuji_rotate;/* -j */
     enum LibRaw_filtering    filtering_mode; 
@@ -269,9 +278,11 @@
     libraw_thumbnail_t          thumbnail;
     libraw_masked_t             masked_pixels;
     ushort                      (*image)[4] ;
+#ifdef LIBRAW_LIBRARY_BUILD
 #ifdef _OPENMP
 #pragma omp shared(image)
 #endif
+#endif
     libraw_output_params_t     params;
     void                *parent_class;      
 } libraw_data_t;
Index: libs/libkdcraw/libraw/libraw/libraw_datastream.h
===================================================================
--- libs/libkdcraw/libraw/libraw/libraw_datastream.h	(révision 1122317)
+++ libs/libkdcraw/libraw/libraw/libraw_datastream.h	(copie de travail)
@@ -1,24 +1,22 @@
 /* -*- C -*-
  * File: libraw_datastream.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sun Jan 18 13:07:35 2009
  *
  * LibRaw Data stream interface
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef __LIBRAW_DATASTREAM_H
Index: libs/libkdcraw/libraw/libraw/libraw_version.h
===================================================================
--- libs/libkdcraw/libraw/libraw/libraw_version.h	(révision 1122317)
+++ libs/libkdcraw/libraw/libraw/libraw_version.h	(copie de travail)
@@ -1,32 +1,31 @@
 /* -*- C++ -*-
  * File: libraw_version.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Mon Sept  8, 2008 
  *
  * LibRaw C++ interface
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See the file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See the file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See the file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef __VERSION_H
 #define __VERSION_H
 
 #define LIBRAW_MAJOR_VERSION  0
-#define LIBRAW_MINOR_VERSION  8
-#define LIBRAW_PATCH_VERSION  5
+#define LIBRAW_MINOR_VERSION  9
+#define LIBRAW_PATCH_VERSION  0
 #define LIBRAW_VERSION_TAIL   Release
 
 #define _LIBRAW_VERSION_MAKE(a,b,c,d) #a"."#b"."#c"-"#d
Index: libs/libkdcraw/libraw/libraw/libraw_const.h
===================================================================
--- libs/libkdcraw/libraw/libraw/libraw_const.h	(révision 1122317)
+++ libs/libkdcraw/libraw/libraw/libraw_const.h	(copie de travail)
@@ -1,29 +1,29 @@
 /* -*- C++ -*-
  * File: libraw_const.h
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw error codes
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #ifndef _LIBRAW_ERRORS_H
 #define _LIBRAW_ERRORS_H
 
+#define LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD 0.75
+#define LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD 0.01
+
 enum LibRaw_constructor_flags
 {
     LIBRAW_OPTIONS_NONE         =0,
@@ -34,8 +34,6 @@
 enum LibRaw_warnings
 {
     LIBRAW_WARN_NONE            =0,
-    LIBRAW_WARN_FOVEON_NOMATRIX =1,
-    LIBRAW_WARN_FOVEON_INVALIDWB =1<<1,
     LIBRAW_WARN_BAD_CAMERA_WB   =1<<2,
     LIBRAW_WARN_NO_METADATA     =1<<3,
     LIBRAW_WARN_NO_JPEGLIB     = 1<<4,
@@ -94,7 +92,6 @@
     LIBRAW_PROGRESS_REMOVE_ZEROES       = 1<<4,
     LIBRAW_PROGRESS_BAD_PIXELS          = 1<<5,
     LIBRAW_PROGRESS_DARK_FRAME          = 1<<6,
-    LIBRAW_PROGRESS_FOVEON_INTERPOLATE  = 1<<7,
     LIBRAW_PROGRESS_SCALE_COLORS        = 1<<8,
     LIBRAW_PROGRESS_PRE_INTERPOLATE     = 1<<9,
     LIBRAW_PROGRESS_INTERPOLATE         = 1<<10,
Index: libs/libkdcraw/libraw/samples/4channels.cpp
===================================================================
--- libs/libkdcraw/libraw/samples/4channels.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/samples/4channels.cpp	(copie de travail)
@@ -1,25 +1,26 @@
 /* -*- C++ -*-
  * File: 4channels.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Mon Feb 09, 2009
  *
  * LibRaw sample
  * Generates 4 TIFF file from RAW data, one file per channel
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <stdio.h>
 #include <string.h>
@@ -111,11 +112,6 @@
                     fprintf(stderr,"Cannot open %s: %s\n",av[i],libraw_strerror(ret));
                     continue; // no recycle b/c open file will recycle itself
                 }
-            if(P1.is_foveon)
-                {
-                    printf("Cannot process foveon image %s\n",av[i]);
-                    continue ;
-                }
             if( (ret = RawProcessor.unpack() ) != LIBRAW_SUCCESS)
                 {
                     fprintf(stderr,"Cannot unpack %s: %s\n",av[i],libraw_strerror(ret));
Index: libs/libkdcraw/libraw/samples/mem_image.cpp
===================================================================
--- libs/libkdcraw/libraw/samples/mem_image.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/samples/mem_image.cpp	(copie de travail)
@@ -1,25 +1,24 @@
 /* -*- C++ -*-
  * File: mem_image.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw mem_image/mem_thumb API test. Results should be same (bitwise) to dcraw [-4] [-6] [-e]
  * Testing note: for ppm-thumbnails you should use dcraw -w -e for thumbnail extraction
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
  */
 #include <stdio.h>
 #include <string.h>
Index: libs/libkdcraw/libraw/samples/raw-identify.cpp
===================================================================
--- libs/libkdcraw/libraw/samples/raw-identify.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/samples/raw-identify.cpp	(copie de travail)
@@ -1,24 +1,24 @@
 /* -*- C++ -*-
  * File: identify.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw C++ demo: emulates dcraw -i [-v]
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
  */
 
 #include <stdio.h>
Index: libs/libkdcraw/libraw/samples/unprocessed_raw.cpp
===================================================================
--- libs/libkdcraw/libraw/samples/unprocessed_raw.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/samples/unprocessed_raw.cpp	(copie de travail)
@@ -1,25 +1,24 @@
 /* -*- C++ -*-
  * File: unprocessed_raw.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Fri Jan 02, 2009
  *
  * LibRaw sample
  * Generates unprocessed raw image: with masked pixels and without black subtraction
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 #include <stdio.h>
 #include <string.h>
@@ -115,6 +114,7 @@
                     fprintf(stderr,"Cannot unpack %s: %s\n",av[i],libraw_strerror(ret));
                     continue;
                 }
+
             if(verbose)
                 printf("Unpacked....\n");
 
@@ -122,10 +122,13 @@
                 {
                     fprintf(stderr,"Cannot add mask data to bitmap %s\n",av[i]);
                 }
+
+            // move all pixel data to component 0
+
             for(int r=0;r<S.iheight;r++)
                 for(c=0;c<S.iwidth;c++)
                     RawProcessor.imgdata.image[r*S.iwidth+c][0] 
-                        = RawProcessor.imgdata.image[r*S.iwidth+c][RawProcessor.FC(r,c)];
+		      = RawProcessor.imgdata.image[r*S.iwidth+c][RawProcessor.COLOR(r,c)];
 
             P1.colors=1;
             if(autoscale)
@@ -144,6 +147,7 @@
                                 RawProcessor.imgdata.image[j][0] *= scale;
                         }
                 }
+
             
             if(OUT.shot_select)
                 snprintf(outfn,sizeof(outfn),"%s-%d.tiff",av[i],OUT.shot_select);
Index: libs/libkdcraw/libraw/samples/dcraw_emu.cpp
===================================================================
--- libs/libkdcraw/libraw/samples/dcraw_emu.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/samples/dcraw_emu.cpp	(copie de travail)
@@ -1,24 +1,25 @@
 /* -*- C++ -*-
  * File: dcraw_emu.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sun Mar 23,   2008
  *
  * LibRaw simple C++ API sample: almost complete dcraw emulator
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <stdio.h>
 #include <string.h>
@@ -43,6 +44,7 @@
     printf("dcraw_emu: almost complete dcraw emulator\n");
     printf("Usage:  %s [OPTION]... [FILE]...\n", prog);
     printf(
+"-c float-num       Set adjust maximum threshold (default 0.75)\n"
 "-v        Verbose: print progress messages (repeated -v will add verbosity)\n"
 "-w        Use camera white balance, if possible\n"
 "-a        Average the whole image for white balance\n"
@@ -119,8 +121,8 @@
   for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == '+'; ) 
       {
           opt = argv[arg++][1];
-          if ((cp = strchr (sp=(char*)"nbrkStqmHACgU", opt)))
-              for (i=0; i < "11411111142"[cp-sp]-'0'; i++)
+          if ((cp = strchr (sp=(char*)"cnbrkStqmHACgU", opt)))
+              for (i=0; i < "111411111142"[cp-sp]-'0'; i++)
                   if (!isdigit(argv[arg+i][0])) 
                       {
                           fprintf (stderr,"Non-numeric argument to \"-%c\"\n", opt);
@@ -129,7 +131,7 @@
           switch (opt) 
               {
               case 'v':  verbosity++;  break;
-                  
+              case 'c':  OUT.adjust_maximum_thr   = atof(argv[arg++]);  break;
               case 'U':  OUT.auto_bright_thr   = atof(argv[arg++]);  break;
               case 'n':  OUT.threshold   = atof(argv[arg++]);  break;
               case 'b':  OUT.bright      = atof(argv[arg++]);  break;
@@ -263,7 +265,10 @@
                      "%s.%s",
                      argv[arg], OUT.output_tiff ? "tiff" : (P1.colors>1?"ppm":"pgm"));
 
-            if(verbosity) printf("Writing file %s\n",outfn);
+            if(verbosity)
+                {
+                    printf("Writing file %s\n",outfn);
+                }
 
             if( LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_ppm_tiff_writer(outfn)))
                 fprintf(stderr,"Cannot write %s: %s\n",outfn,libraw_strerror(ret));
Index: libs/libkdcraw/libraw/samples/simple_dcraw.cpp
===================================================================
--- libs/libkdcraw/libraw/samples/simple_dcraw.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/samples/simple_dcraw.cpp	(copie de travail)
@@ -1,24 +1,24 @@
 /* -*- C++ -*-
  * File: simple_dcraw.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw simple C++ API:  emulates call to "dcraw  [-D]  [-T] [-v] [-e] [-4]"
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <stdio.h>
 #include <string.h>
Index: libs/libkdcraw/libraw/samples/dcraw_half.c
===================================================================
--- libs/libkdcraw/libraw/samples/dcraw_half.c	(révision 1122317)
+++ libs/libkdcraw/libraw/samples/dcraw_half.c	(copie de travail)
@@ -1,24 +1,24 @@
 /* -*- C++ -*-
  * File: dcraw_half.c
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw  C API sample:  emulates "dcraw  -h"
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <stdio.h>
 #include <string.h>
Index: libs/libkdcraw/libraw/samples/half_mt.c
===================================================================
--- libs/libkdcraw/libraw/samples/half_mt.c	(révision 1122317)
+++ libs/libkdcraw/libraw/samples/half_mt.c	(copie de travail)
@@ -1,24 +1,24 @@
 /* -*- C++ -*-
  * File: halt_mt.c
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw  C API mutithreaded sample: emulates call to "dcraw  -h [-w] [-a] [-v]"
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
  */
 #include <stdio.h>
 #include <string.h>
Index: libs/libkdcraw/libraw/samples/half_mt_win32.c
===================================================================
--- libs/libkdcraw/libraw/samples/half_mt_win32.c	(révision 1122317)
+++ libs/libkdcraw/libraw/samples/half_mt_win32.c	(copie de travail)
@@ -1,25 +1,24 @@
 /* -*- C++ -*-
  * File: halt_mt_win32.c
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw  C API mutithreaded sample:  emulates call to "dcraw  -h [-w] [-a] [-v]"
  * Win32 version
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
- * 02111-1307, USA.
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
  */
 #include <stdio.h>
 #include <string.h>
@@ -61,17 +60,17 @@
     if(!queue) return NULL;
     if(qptr>=qsize) return NULL;
 
-	dwWaitResult = WaitForSingleObject(
+	dwWaitResult = WaitForSingleObject( 
             qmutex,    // handle to mutex
             INFINITE);  // no time-out interval
-	switch (dwWaitResult)
+	switch (dwWaitResult) 
         {
             // The thread got ownership of the mutex
-            case WAIT_OBJECT_0:
+            case WAIT_OBJECT_0:     
 				ret = queue[qptr++];
 				ReleaseMutex(qmutex);
 				break;
-			case WAIT_ABANDONED:
+			case WAIT_ABANDONED: 
                 return NULL; // cannot obtain the lock
 	};
     return ret;
@@ -99,17 +98,17 @@
             iprc->params.use_camera_wb = use_camera_wb;
             iprc->params.use_auto_wb = use_auto_wb;
             iprc->params.output_tiff = tiff_mode;
-
+            
             ret = libraw_open_file(iprc,fn);
             if(verbose) fprintf(stderr,"%s: %s/%s\n",fn,iprc->idata.make,iprc->idata.model);
             HANDLE_ERRORS(ret);
 
             ret = libraw_unpack(iprc);
             HANDLE_ERRORS(ret);
-
+            
             ret = libraw_dcraw_process(iprc);
             HANDLE_ERRORS(ret);
-
+            
             snprintf(outfn,1023,"%s.%s",fn,tiff_mode?"tif":"ppm");
 
             if(verbose) fprintf(stderr,"Writing file %s\n",outfn);
@@ -179,15 +178,15 @@
             else
                 queue[qsize++] = av[i];
         }
-    qmutex = CreateMutex(NULL,FALSE,NULL);
+    qmutex = CreateMutex(NULL,FALSE,NULL);	
     threads = calloc(max_threads,sizeof(threads[0]));
     for(i=0;i<max_threads;i++)
 	{
 
-		if (NULL == (threads[i] = CreateThread(
+		if (NULL == (threads[i] = CreateThread( 
                      NULL,       // default security attributes
                      0,          // default stack size
-                     (LPTHREAD_START_ROUTINE) process_files,
+                     (LPTHREAD_START_ROUTINE) process_files, 
                      NULL,       // no thread function arguments
                      0,          // default creation flags
                      &ThreadID) // receive thread identifier
@@ -198,7 +197,7 @@
             return 1;
         }
 	}
-
+        
 	WaitForMultipleObjects(max_threads, threads, TRUE, INFINITE);
 
     // Close thread and mutex handles
@@ -207,6 +206,6 @@
         CloseHandle(threads[i]);
 
     CloseHandle(qmutex);
-
+           
     return 0;
 }
Index: libs/libkdcraw/libraw/Changelog.txt
===================================================================
--- libs/libkdcraw/libraw/Changelog.txt	(révision 1122317)
+++ libs/libkdcraw/libraw/Changelog.txt	(copie de travail)
@@ -1,3 +1,119 @@
+2010-04-26 Alex Tutubalin <lexa@lexa.ru>
+           * OpenMP support: OpenMP is possible under MinGW (untested)
+           * LibRaw 0.9.0-Release
+
+2010-04-21 Alex Tutubalin <lexa@lexa.ru>
+           * Finally fixed inconsistency in Fuji files processing
+           * New COLOR(row,col) call to get bayer color index in image[] array
+           * Old FC() call is deprecated and will be removed in future releases
+           * unprocessed_raw sample switched to COLOR() call
+           * LibRaw 0.9.0-Beta5
+
+
+2010-04-10 Alex Tutubalin <lexa@lexa.ru>
+           * Fixed bug in unpacking DNG files made from Fuji RAFs.
+           * LibRaw 0.9.0-Beta4
+
+2010-04-09 Alex Tutubalin <lexa@lexa.ru>
+
+           * Fixed typecast error (problem reported only on gcc 4.2.1/32bit)
+            in CRW files processing.
+
+           * C++ API call LibRaw::adjust_maximum() is now deprecated and
+             de-documented, use params.adjust_maximum_thr instead (on by default)
+
+           *  C-API call libraw_adjust_maximum() removed.
+
+           * New postprocessing parameter params.adjust_maximum_thr
+             This parameter replaces LibRaw::adjust_maximum(), but more flexible
+             Defaults are reasonable (0.75, same as in old adjust_maximum),
+             look into documentation for more details.
+
+           * Removed last OpenMP warning
+
+           * dcraw_emu's -c parameter now wants numeric (float) argument. This value
+             is assigned to params.adjust_maximum_thr.
+             Use -c 0.0 for dcraw compatibility.
+
+           * all client code should be recompiled due to structures size 
+             change
+
+           * LibRaw 0.9.0-Beta3
+
+
+2010-03-29 Alex Tutubalin <lexa@lexa.ru>
+           * Fixed a bug in channel_maximum[] calculation for
+             Panasonic cameras.
+           * channel_maximum[] data now calculated for ALL cameras.
+           * OpenMP warnings suppressed.
+           * Documented the -c command-line switch for dcraw_emu sample.
+           * Removed extra messages from dcraw_emu sample.
+           * LibRaw 0.9.0-Beta2
+
+2010-03-28 Alex Tutubalin <lexa@lexa.ru>
+           
+           New licensing:
+
+           * Triple licensing (selected by LibRaw user):
+
+              + LGPL 2.1 (http://www.gnu.org/licenses/lgpl-2.1.html)
+              + CDDL 1.0 (http://www.opensource.org/licenses/cddl1.txt)
+              + LibRaw Software License (27 March 2010 version)
+               (http://www.libraw.org/data/LICENSE.LibRaw.pdf)
+
+           * There is no separate LibRaw-Lite and LibRaw-Commercial versions,
+             only single LibRaw.
+             Current LibRaw-Lite and LibRaw-Commercial users should switch
+             to LibRaw without loss of functionality.
+             It is possible to change licensig too (e.g. from LGPL to CDDL
+             for LibRaw-Lite users and from LibRaw License to LGPL or CDDL
+             for LibRaw-Commercial users).
+
+           * No Foveon support :(
+             It is not possible to get good color from Foveon sensors with
+             *any* converter. So, there is no need to support these cameras.
+             Dcraw's Foveon-processing code is too strict licensed (GPL),
+             so we choose to drop it.
+             
+           New Features:
+
+           * New data field  colordata.channel_maximum[4] - per channel data
+            maximum (calculated for most cameras, 0 for others).
+
+           * New call LibRaw::adjust_maximum() (and libraw_adjust_maximum() in C API).
+             This call changes hardcoded colordata.maximum value to calculated
+             at unpack stage. This helps suppress false color in highlights
+             (magenta clouds and so).
+
+           * New command line parameter -c for dcraw_emu sample. Calls adjust_maximum()
+             for each processed file.
+
+           * all client code should be recompiled due to structures size 
+             change
+
+           * LibRaw 0.9.0-Beta1
+
+2010-02-06 Alex Tutubalin <lexa@lexa.ru>
+           * Fixed ambiguity in pow/sqrt calls (to make Sun C++ compiler happy)
+           * OpenMP is not supported under MS Visual Studio
+           * Masked a bug in RIFF format parser 
+           * LibRaw 0.8.6
+
+2009-12-30 Alex Tutubalin <lexa@lexa.ru>
+           * Fixed bug in simple_dcraw sample parameters processing
+           * Imported dcraw 8.99 (1.432):
+             + New cameras: Canon:  1D mk IV, Canon S90; Casio Z750, 
+               Nikon D3S, Pentax K-x, Sony A-500/550, Fuji S200EXR
+             + New color data for Canon G11 and Sony A850
+             + Changes in Canon sRAW processing
+             + Changes in Kodak metadata processing
+             + Changes in uncompressed Fuji files processing (FinePix S5xxx)
+           * LibRaw 0.8.5
+
+2009-11-21 Alex Tutubalin <lexa@lexa.ru>
+           + Fixed a bug in processing of uncompressed Phase One files 
+           * LibRaw 0.8.4
+
 2009-10-24 Alex Tutubalin <lexa@lexa.ru>
            + Imported dcraw 8.98/1.431:
              * New Cameras: Canon 7D, Panasonic GF1, Sony A850 and A380, 
Index: libs/libkdcraw/libraw/src/libraw_cxx.cpp
===================================================================
--- libs/libkdcraw/libraw/src/libraw_cxx.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/src/libraw_cxx.cpp	(copie de travail)
@@ -1,9 +1,22 @@
 /* -*- C++ -*-
  * File: libraw_cxx.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw C++ interface (implementation)
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
  */
 
 #include <errno.h>
@@ -170,7 +183,8 @@
     imgdata.params.output_color=1;
     imgdata.params.output_bps=8;
     imgdata.params.use_fuji_rotate=1;
-    imgdata.params.auto_bright_thr = 0.01;
+    imgdata.params.auto_bright_thr = LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD;
+    imgdata.params.adjust_maximum_thr= LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;
     imgdata.parent_class = this;
     imgdata.progress_flags = 0;
     tls = new LibRaw_TLS;
@@ -239,6 +253,7 @@
 #undef FREE
     ZERO(imgdata.masked_pixels);
     ZERO(imgdata.sizes);
+    ZERO(imgdata.color);
     ZERO(libraw_internal_data.internal_output_params);
     memmgr.cleanup();
     imgdata.thumbnail.tformat = LIBRAW_THUMBNAIL_UNKNOWN;
@@ -252,62 +267,87 @@
     if(!load_raw) return "Function not set";
 
     // sorted names order
-    if (load_raw == &LibRaw::adobe_dng_load_raw_lj)     return "adobe_dng_load_raw_lj()";
-    if (load_raw == &LibRaw::adobe_dng_load_raw_nc)     return "adobe_dng_load_raw_nc()";
-    if (load_raw == &LibRaw::canon_600_load_raw)        return "canon_600_load_raw()";
+    if (load_raw == &LibRaw::adobe_dng_load_raw_lj)     return "adobe_dng_load_raw_lj()"; //+
+    if (load_raw == &LibRaw::adobe_dng_load_raw_nc)     return "adobe_dng_load_raw_nc()"; //+
+    if (load_raw == &LibRaw::canon_600_load_raw)        return "canon_600_load_raw()";    //+
 
-    if (load_raw == &LibRaw::canon_compressed_load_raw) return "canon_compressed_load_raw()";
-    if (load_raw == &LibRaw::canon_sraw_load_raw)       return "canon_sraw_load_raw()";
+    if (load_raw == &LibRaw::canon_compressed_load_raw) return "canon_compressed_load_raw()"; //+
+    if (load_raw == &LibRaw::canon_sraw_load_raw)       return "canon_sraw_load_raw()"; //+
 
-    if (load_raw == &LibRaw::eight_bit_load_raw )       return "eight_bit_load_raw()";
-    if (load_raw == &LibRaw::foveon_load_raw )          return "foveon_load_raw()";
-    if (load_raw == &LibRaw::fuji_load_raw )            return "fuji_load_raw()";
+    if (load_raw == &LibRaw::eight_bit_load_raw )       return "eight_bit_load_raw()"; //+
+    if (load_raw == &LibRaw::fuji_load_raw )            return "fuji_load_raw()"; //+
     // 10
-    if (load_raw == &LibRaw::hasselblad_load_raw )      return "hasselblad_load_raw()";
-    if (load_raw == &LibRaw::imacon_full_load_raw )     return "imacon_full_load_raw()";
-    if (load_raw == &LibRaw::kodak_262_load_raw )       return "kodak_262_load_raw()";
+    if (load_raw == &LibRaw::hasselblad_load_raw )      return "hasselblad_load_raw()"; //+
+    if (load_raw == &LibRaw::imacon_full_load_raw )     return "imacon_full_load_raw()"; //+ (untested)
+    if (load_raw == &LibRaw::kodak_262_load_raw )       return "kodak_262_load_raw()"; //+
 
-    if (load_raw == &LibRaw::kodak_65000_load_raw )     return "kodak_65000_load_raw()";
-    if (load_raw == &LibRaw::kodak_dc120_load_raw )     return "kodak_dc120_load_raw()";
-    if (load_raw == &LibRaw::kodak_jpeg_load_raw )      return "kodak_jpeg_load_raw()";
+    if (load_raw == &LibRaw::kodak_65000_load_raw )     return "kodak_65000_load_raw()";//+
+    if (load_raw == &LibRaw::kodak_dc120_load_raw )     return "kodak_dc120_load_raw()"; //+
+    if (load_raw == &LibRaw::kodak_jpeg_load_raw )      return "kodak_jpeg_load_raw()"; //+ (untested)
 
-    if (load_raw == &LibRaw::kodak_radc_load_raw )      return "kodak_radc_load_raw()";
-    if (load_raw == &LibRaw::kodak_rgb_load_raw )       return "kodak_rgb_load_raw()";
-    if (load_raw == &LibRaw::kodak_yrgb_load_raw )      return "kodak_yrgb_load_raw()";
-    if (load_raw == &LibRaw::kodak_ycbcr_load_raw )     return "kodak_ycbcr_load_raw()";
+    if (load_raw == &LibRaw::kodak_radc_load_raw )      return "kodak_radc_load_raw()"; //+
+    if (load_raw == &LibRaw::kodak_rgb_load_raw )       return "kodak_rgb_load_raw()"; //+ (untested)
+    if (load_raw == &LibRaw::kodak_yrgb_load_raw )      return "kodak_yrgb_load_raw()"; //+
+    if (load_raw == &LibRaw::kodak_ycbcr_load_raw )     return "kodak_ycbcr_load_raw()"; //+ (untested)
     // 20
-    if (load_raw == &LibRaw::leaf_hdr_load_raw )        return "leaf_hdr_load_raw()";
-    if (load_raw == &LibRaw::lossless_jpeg_load_raw)    return "lossless_jpeg_load_raw()";
-    if (load_raw == &LibRaw::minolta_rd175_load_raw )   return "minolta_rd175_load_raw()";
+    if (load_raw == &LibRaw::leaf_hdr_load_raw )        return "leaf_hdr_load_raw()"; //+
+    if (load_raw == &LibRaw::lossless_jpeg_load_raw)    return "lossless_jpeg_load_raw()"; //+
+    if (load_raw == &LibRaw::minolta_rd175_load_raw )   return "minolta_rd175_load_raw()"; //+
 
-    if (load_raw == &LibRaw::nikon_compressed_load_raw) return "nikon_compressed_load_raw()";
-    if (load_raw == &LibRaw::nokia_load_raw )           return "nokia_load_raw()";
+    if (load_raw == &LibRaw::nikon_compressed_load_raw) return "nikon_compressed_load_raw()";//+
+    if (load_raw == &LibRaw::nokia_load_raw )           return "nokia_load_raw()";//+ (untested)
 
-    if (load_raw == &LibRaw::olympus_load_raw )    return "olympus_load_raw()";
-    if (load_raw == &LibRaw::packed_load_raw )       return "packed_load_raw()";
-    if (load_raw == &LibRaw::panasonic_load_raw )       return "panasonic_load_raw()";
+    if (load_raw == &LibRaw::olympus_load_raw )    return "olympus_load_raw()"; //+
+    if (load_raw == &LibRaw::packed_load_raw )       return "packed_load_raw()"; //+
+    if (load_raw == &LibRaw::panasonic_load_raw )       return "panasonic_load_raw()";//+
     // 30
-    if (load_raw == &LibRaw::pentax_load_raw )          return "pentax_load_raw()";
-    if (load_raw == &LibRaw::phase_one_load_raw )       return "phase_one_load_raw()";
-    if (load_raw == &LibRaw::phase_one_load_raw_c )     return "phase_one_load_raw_c()";
+    if (load_raw == &LibRaw::pentax_load_raw )          return "pentax_load_raw()"; //+
+    if (load_raw == &LibRaw::phase_one_load_raw )       return "phase_one_load_raw()"; //+
+    if (load_raw == &LibRaw::phase_one_load_raw_c )     return "phase_one_load_raw_c()"; //+
 
-    if (load_raw == &LibRaw::quicktake_100_load_raw )   return "quicktake_100_load_raw()";
-    if (load_raw == &LibRaw::rollei_load_raw )          return "rollei_load_raw()";
-    if (load_raw == &LibRaw::sinar_4shot_load_raw )     return "sinar_4shot_load_raw()";
+    if (load_raw == &LibRaw::quicktake_100_load_raw )   return "quicktake_100_load_raw()";//+ (untested)
+    if (load_raw == &LibRaw::rollei_load_raw )          return "rollei_load_raw()"; //+ (untested)
+    if (load_raw == &LibRaw::sinar_4shot_load_raw )     return "sinar_4shot_load_raw()";//+
 
-    if (load_raw == &LibRaw::smal_v6_load_raw )         return "smal_v6_load_raw()";
-    if (load_raw == &LibRaw::smal_v9_load_raw )         return "smal_v9_load_raw()";
-    if (load_raw == &LibRaw::sony_load_raw )            return "sony_load_raw()";
-    if (load_raw == &LibRaw::sony_arw_load_raw )        return "sony_arw_load_raw()";
+    if (load_raw == &LibRaw::smal_v6_load_raw )         return "smal_v6_load_raw()";//+ (untested)
+    if (load_raw == &LibRaw::smal_v9_load_raw )         return "smal_v9_load_raw()";//+ (untested)
+    if (load_raw == &LibRaw::sony_load_raw )            return "sony_load_raw()"; //+
+    if (load_raw == &LibRaw::sony_arw_load_raw )        return "sony_arw_load_raw()";//+
     // 40
-    if (load_raw == &LibRaw::sony_arw2_load_raw )       return "sony_arw2_load_raw()";
-    if (load_raw == &LibRaw::unpacked_load_raw )        return "unpacked_load_raw()";
+    if (load_raw == &LibRaw::sony_arw2_load_raw )       return "sony_arw2_load_raw()";//+
+    if (load_raw == &LibRaw::unpacked_load_raw )        return "unpacked_load_raw()"; //+
     // 42 total
         
     return "Unknown unpack function";
 }
 
+int LibRaw::adjust_maximum()
+{
+    int i;
+    ushort real_max;
+    float  auto_threshold;
 
+    if(O.adjust_maximum_thr < 0.00001)
+        return LIBRAW_SUCCESS;
+    else if (O.adjust_maximum_thr > 0.99999)
+        auto_threshold = LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD;
+    else
+        auto_threshold = O.adjust_maximum_thr;
+        
+    
+    real_max = C.channel_maximum[0];
+    for(i = 1; i< 4; i++)
+        if(real_max < C.channel_maximum[i])
+            real_max = C.channel_maximum[i];
+
+    if (real_max > 0 && real_max < C.maximum && real_max > C.maximum* auto_threshold)
+        {
+            C.maximum = real_max;
+        }
+    return LIBRAW_SUCCESS;
+}
+
+
 void LibRaw:: merror (void *ptr, const char *where)
 {
     if (ptr) return;
@@ -413,7 +453,6 @@
     M.br = M.bottom + (S.width * S.bottom_margin);
 
 }
-
 int LibRaw::add_masked_borders_to_bitmap()
 {
     CHECK_ORDER_HIGH(LIBRAW_PROGRESS_PRE_INTERPOLATE);
@@ -422,7 +461,7 @@
     if(S.width != S.iwidth || S.height!=S.iheight)
         return LIBRAW_CANNOT_ADDMASK;
 
-    if(P1.is_foveon || !P1.filters)
+    if(!P1.filters)
         return LIBRAW_CANNOT_ADDMASK;
         
     if(!imgdata.image)
@@ -446,7 +485,7 @@
             {
                 ushort *p = get_masked_pointer(r,c);
                 if(p)
-                    newimage[r*S.raw_width+c][FC(r,c)] = *p;
+                    newimage[r*S.raw_width+c][COLOR(r,c)] = *p;
             }
     // middle rows
     for (r=S.top_margin; r<S.top_margin+S.height;r++)
@@ -456,18 +495,20 @@
                 {
                     ushort *p = get_masked_pointer(r,c);
                     if(p)
-                        newimage[r*S.raw_width+c][FC(r,c)] =  *p;
+                        newimage[r*S.raw_width+c][COLOR(r,c)] =  *p;
                 }
             for(c=S.left_margin; c<S.left_margin+S.iwidth;c++)
                 {
                     int col = c - S.left_margin;
-                    newimage[r*S.raw_width+c][FC(r,c)] = imgdata.image[row*S.iwidth+col][FC(row,col)];
+                    newimage[r*S.raw_width+c][COLOR(r,c)] = imgdata.image[row*S.iwidth+col][COLOR(r,c)];
+//                    for(int cc=0;cc<4;cc++)
+//                        newimage[r*S.raw_width+c][cc] = imgdata.image[row*S.iwidth+col][cc];
                 }
             for(c=S.left_margin+S.iwidth;c<S.raw_width;c++)
                 {
                     ushort *p = get_masked_pointer(r,c);
                     if(p)
-                        newimage[r*S.raw_width+c][FC(r,c)] =  *p;
+                        newimage[r*S.raw_width+c][COLOR(r,c)] =  *p;
                 }
         }
     // bottom rows
@@ -476,7 +517,7 @@
             {
                 ushort *p = get_masked_pointer(r,c);
                 if(p)
-                    newimage[r*S.raw_width+c][FC(r,c)] = *p;
+                    newimage[r*S.raw_width+c][COLOR(r,c)] = *p;
             }
     free(imgdata.image);
     imgdata.image=newimage;
@@ -670,8 +711,6 @@
                 merror (libraw_internal_data.internal_data.meta_data, "LibRaw::unpack()");
             }
         ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);
-        // foveon_load_raw produces different data for document_mode, we'll
-        // deal with it in dcraw_document_mode_processing
         int save_document_mode = O.document_mode;
         O.document_mode = 0;
 
@@ -709,17 +748,6 @@
             O.filtering_mode = LIBRAW_FILTERING_AUTOMATIC_BIT; // turn on black and zeroes filtering
 
         O.document_mode = 2;
-        if(P1.is_foveon)
-            {
-                // filter image data for foveon document mode
-                short *iptr = (short *)imgdata.image;
-                for (int i=0; i < S.height*S.width*4; i++)
-                    {
-                        if ((short) iptr[i] < 0) 
-                            iptr[i] = 0;
-                    }
-                SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);
-            }
 
         O.use_fuji_rotate = 0;
         if (!(O.filtering_mode & LIBRAW_FILTERING_NOZEROES) && IO.zero_is_bad)
@@ -757,14 +785,14 @@
             }
         SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);
 
-        if (!P1.is_foveon && P1.colors == 3) 
+        if ( P1.colors == 3) 
             median_filter();
         SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);
 
-        if (!P1.is_foveon && O.highlight == 2) 
+        if ( O.highlight == 2) 
             blend_highlights();
 
-        if (!P1.is_foveon && O.highlight > 2) 
+        if ( O.highlight > 2) 
             recover_highlights();
         SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
 
@@ -1189,62 +1217,6 @@
 #undef SWAP
 
 
-void LibRaw::foveon_thumb_loader (void)
-{
-    unsigned bwide, row, col, bitbuf=0, bit=1, c, i;
-    struct decode *dindex;
-    short pred[3];
-    
-    if(T.thumb) free(T.thumb);
-    T.thumb = NULL;
-    
-    bwide = get4();
-    if (bwide > 0) 
-        {
-            if (bwide < (unsigned)T.twidth*3) return;
-            T.thumb = (char*)malloc(3*T.twidth * T.theight);
-            merror (T.thumb, "foveon_thumb()");
-            char *buf = (char*)malloc(bwide); 
-            merror (buf, "foveon_thumb()");
-            for (row=0; row < T.theight; row++) 
-                {
-                    ID.input->read(buf, 1, bwide);
-                    memmove(T.thumb+(row*T.twidth*3),buf,T.twidth*3);
-                }
-            free(buf);
-            T.tlength = 3*T.twidth * T.theight;
-            T.tformat = LIBRAW_THUMBNAIL_BITMAP;
-            return;
-        }
-    else 
-        {
-            foveon_decoder (256, 0);
-            T.thumb = (char*)malloc(3*T.twidth * T.theight);
-            char *bufp = T.thumb;
-            merror (T.thumb, "foveon_thumb()");
-            for (row=0; row < T.theight; row++) 
-                {
-                    memset (pred, 0, sizeof pred);
-                    if (!bit) get4();
-                    for (bit=col=0; col < T.twidth; col++)
-                        for(c=0;c<3;c++) 
-                            {
-                                for (dindex=first_decode; dindex->branch[0]; ) 
-                                    {
-                                        if ((bit = (bit-1) & 31) == 31)
-                                            for (i=0; i < 4; i++)
-                                                bitbuf = (bitbuf << 8) + ID.input->get_char();
-                                        dindex = dindex->branch[bitbuf >> bit & 1];
-                                    }
-                                pred[c] += dindex->leaf;
-                                (*bufp++)=pred[c];
-                            }
-                }
-            T.tformat = LIBRAW_THUMBNAIL_BITMAP;
-            T.tlength = 3*T.twidth * T.theight;
-        }
-    return;
-}
 
 
 //  thumbnail  ,  thumb_format    
@@ -1294,14 +1266,6 @@
                         return 0;
 
                     }
-                else if (write_thumb == &LibRaw::foveon_thumb)
-                    {
-                        foveon_thumb_loader();
-                        // may return with error, so format is set in
-                        // foveon thumb loader itself
-                        SET_PROC_FLAG(LIBRAW_PROGRESS_THUMB_LOAD);
-                        return 0;
-                    }
                 // else if -- all other write_thumb cases!
                 else
                     {
@@ -1418,7 +1382,6 @@
         {
             for(col=0;col<S.width;col++)
                 {
-
                     if (libraw_internal_data.unpacker_data.fuji_layout) {
                         r = IO.fuji_width - 1 - col + (row >> 1);
                         c = col + ((row+1) >> 1);
@@ -1426,8 +1389,8 @@
                         r = IO.fuji_width - 1 + row - (col >> 1);
                         c = row + ((col+1) >> 1);
                     }
-                    newimage[((r) >> IO.shrink)*fiwidth + ((c) >> IO.shrink)][FC(r,c)] = 
-                        imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][FC(r,c)];
+                    newimage[((r) >> IO.shrink)*fiwidth + ((c) >> IO.shrink)][FCF(row,col)] = 
+                        imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][FCF(row,col)];
                 }
         }
     // restore fuji sizes!
@@ -1455,6 +1418,7 @@
 
     try {
 
+        adjust_maximum();
         if(IO.fwidth) 
             rotate_fuji_raw();
 
@@ -1490,13 +1454,8 @@
         if (O.user_black >= 0) C.black = O.user_black;
         if (O.user_sat > 0) C.maximum = O.user_sat;
 
-        if (P1.is_foveon && !O.document_mode) 
-            {
-                foveon_interpolate();
-                SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE);
-            }
 
-        if (!P1.is_foveon && O.document_mode < 2)
+        if ( O.document_mode < 2)
             {
                 scale_colors();
                 SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS);
@@ -1524,26 +1483,24 @@
                 SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN);
             }
 
-        if(!P1.is_foveon)
+        if (P1.colors == 3) 
             {
-                if (P1.colors == 3) 
-                    {
-                        median_filter();
-                        SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);
-                    }
-            
-                if (O.highlight == 2) 
-                    {
-                        blend_highlights();
-                        SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
-                    }
-            
-                if (O.highlight > 2) 
-                    {
-                        recover_highlights();
-                        SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
-                    }
+                median_filter();
+                SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER);
             }
+        
+        if (O.highlight == 2) 
+            {
+                blend_highlights();
+                SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
+            }
+        
+        if (O.highlight > 2) 
+            {
+                recover_highlights();
+                SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS);
+            }
+        
         if (O.use_fuji_rotate) 
             {
                 fuji_rotate();
@@ -1911,7 +1868,6 @@
 "Phase One P 45",
 "Phase One P 45+",
 "Pixelink A782",
-"Polaroid x530",
 "Rollei d530flex",
 "RoverShot 3320af",
 "Samsung GX-1S",
@@ -1919,9 +1875,6 @@
 "Samsung S85 (hacked)",
 "Samsung S850 (hacked)",
 "Sarnoff 4096x5440",
-"Sigma SD9",
-"Sigma SD10",
-"Sigma SD14",
 "Sinar 3072x2048",
 "Sinar 4080x4080",
 "Sinar 4080x5440",
@@ -1973,8 +1926,6 @@
             return "Removing dead pixels";
         case LIBRAW_PROGRESS_DARK_FRAME:
             return "Subtracting dark frame data";
-        case LIBRAW_PROGRESS_FOVEON_INTERPOLATE:
-            return "Interpolating Foveon sensor data";
         case LIBRAW_PROGRESS_SCALE_COLORS:
             return "Scaling colors";
         case LIBRAW_PROGRESS_PRE_INTERPOLATE:
Index: libs/libkdcraw/libraw/src/libraw_c_api.cpp
===================================================================
--- libs/libkdcraw/libraw/src/libraw_c_api.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/src/libraw_c_api.cpp	(copie de travail)
@@ -1,9 +1,25 @@
 /* -*- C++ -*-
  * File: libraw_c_api.cpp
- * Copyright 2008-2009 LibRaw LLC (info@libraw.org)
+ * Copyright 2008-2010 LibRaw LLC (info@libraw.org)
  * Created: Sat Mar  8 , 2008
  *
  * LibRaw C interface 
+
+
+LibRaw is free software; you can redistribute it and/or modify
+it under the terms of the one of three licenses as you choose:
+
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
+
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
+
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
+
+
+
  */
 #include <errno.h>
 #include "libraw/libraw.h"
@@ -110,7 +126,6 @@
         LibRaw *ip = (LibRaw*) lr->parent_class;
         return ip->adjust_sizes_info_only();
     }
-
     int  libraw_dcraw_document_mode_processing(libraw_data_t* lr)
     {
         if(!lr) return EINVAL;
Index: libs/libkdcraw/libraw/LICENSE.CDDL
===================================================================
--- libs/libkdcraw/libraw/LICENSE.CDDL	(révision 0)
+++ libs/libkdcraw/libraw/LICENSE.CDDL	(révision 0)
@@ -0,0 +1,340 @@
+COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+
+1. Definitions.
+
+1.1. Contributor means each individual or entity that creates or
+contributes to the creation of Modifications.
+
+1.2. Contributor Version means the combination of the Original
+Software, prior Modifications used by a Contributor (if any),
+and the Modifications made by that particular Contributor.
+
+1.3. Covered Software means (a) the Original Software, or (b)
+Modifications, or (c) the combination of files containing
+Original Software with files containing Modifications, in each
+case including portions thereof.
+
+1.4. Executable means the Covered Software in any form other
+than Source Code.
+
+1.5. Initial Developer means the individual or entity that first
+makes Original Software available under this License.
+
+1.6. Larger Workmeans a work which combines Covered Software or
+portions thereof with code not governed by the terms of this
+License.
+
+1.7. License means this document.
+
+1.8. Licensable means having the right to grant, to the maximum
+extent possible, whether at the time of the initial grant or 
+subsequently acquired, any and all of the rights conveyed herein.
+
+1.9. Modifications means the Source Code and Executable form of
+any of the following: A. Any file that results from an addition
+to, deletion from or modification of the contents of a file
+containing Original Software or previous Modifications; B. Any
+new file that contains any part of the Original Software or
+previous Modification; or C. Any new file that is contributed or
+otherwise made available under the terms of this License.
+
+1.10. Original Software means the Source Code and Executable
+form of computer software code that is originally released under
+this License.
+
+1.11. Patent Claims means any patent claim(s), now owned or
+hereafter acquired, including without limitation, method,
+process, and apparatus claims, in any patent Licensable by
+grantor.
+
+1.12. Source Code means (a) the common form of computer software
+code in which modifications are made and (b) associated
+documentation included in or with such code.
+
+1.13. You (or Your) means an individual or a legal entity
+exercising rights under, and complying with all of the terms of,
+this License. For legal entities, You includes any entity which
+controls, is controlled by, or is under common control with You.
+For purposes of this definition, control means (a) the power,
+direct or indirect, to cause the direction or management of such
+entity, whether by contract or otherwise, or (b) ownership of
+more than fifty percent (50%) of the outstanding shares or
+beneficial ownership of such entity.
+
+2. License Grants.
+
+2.1. The Initial Developer Grant. Conditioned upon Your
+compliance with Section 3.1 below and subject to third party
+intellectual property claims, the Initial Developer hereby
+grants You a world-wide, royalty-free, non-exclusive license:
+
+(a) under intellectual property rights (other than patent or
+trademark) Licensable by Initial Developer, to use, reproduce,
+modify, display, perform, sublicense and distribute the Original
+Software (or portions thereof), with or without Modifications,
+and/or as part of a Larger Work; and
+
+(b) under Patent Claims infringed by the making, using or
+selling of Original Software, to make, have made, use, practice,
+sell, and offer for sale, and/or otherwise dispose of the
+Original Software (or portions thereof);
+
+(c) The licenses granted in Sections 2.1(a) and (b) are
+effective on the date Initial Developer first distributes or
+otherwise makes the Original Software available to a third party
+under the terms of this License;
+
+(d) Notwithstanding Section 2.1(b) above, no patent license is
+granted: (1) for code that You delete from the Original
+Software, or (2) for infringements caused by: (i) the
+modification of the Original Software, or (ii) the combination
+of the Original Software with other software or devices.
+
+2.2. Contributor Grant. Conditioned upon Your compliance with
+Section 3.1 below and subject to third party intellectual
+property claims, each Contributor hereby grants You a
+world-wide, royalty-free, non-exclusive license:
+
+(a) under intellectual property rights (other than patent or
+trademark) Licensable by Contributor to use, reproduce, modify,
+display, perform, sublicense and distribute the Modifications
+created by such Contributor (or portions thereof), either on an
+unmodified basis, with other Modifications, as Covered Software
+and/or as part of a Larger Work; and
+
+(b) under Patent Claims infringed by the making, using, or
+selling of Modifications made by that Contributor either alone
+and/or in combination with its Contributor Version (or portions
+of such combination), to make, use, sell, offer for sale, have
+made, and/or otherwise dispose of: (1) Modifications made by
+that Contributor (or portions thereof); and (2) the combination
+of Modifications made by that Contributor with its Contributor
+Version (or portions of such combination).
+
+(c) The licenses granted in Sections 2.2(a) and 2.2(b)
+areeffective on the date Contributor first distributes or
+otherwise makes the Modifications available to a third party.
+
+(d) Notwithstanding Section 2.2(b) above, no patent license is
+granted: (1) for any code that Contributor has deleted from the
+Contributor Version; (2) for infringements caused by: (i) third
+party modifications of Contributor Version, or (ii) the
+combination of Modifications made by that Contributor with other
+software (except as part of the Contributor Version) or other
+devices; or (3) under Patent Claims infringed by Covered
+Software in the absence of Modifications made by that
+Contributor.
+
+3. Distribution Obligations.
+
+3.1. Availability of Source Code. Any Covered Software that You
+distribute or otherwise make available in Executable form must
+also be made available in Source Code form and that Source Code
+form must be distributed only under the terms of this License.
+You must include a copy of this License with every copy of the
+Source Code form of the Covered Software You distribute or
+otherwise make available. You must inform recipients of any such
+Covered Software in Executable form as to how they can obtain
+such Covered Software in Source Code form in a reasonable manner
+on or through a medium customarily used for software exchange.
+
+3.2. Modifications. The Modifications that You create or to
+which You contribute are governed by the terms of this License.
+You represent that You believe Your Modifications are Your
+original creation(s) and/or You have sufficient rights to grant
+the rights conveyed by this License.
+
+3.3. Required Notices. You must include a notice in each of Your
+Modifications that identifies You as the Contributor of the
+Modification. You may not remove or alter any copyright, patent
+or trademark notices contained within the Covered Software, or
+any notices of licensing or any descriptive text giving
+attribution to any Contributor or the Initial Developer.
+
+3.4. Application of Additional Terms. You may not offer or
+impose any terms on any Covered Software in Source Code form
+that alters or restricts the applicable version of this License
+or the recipients rights hereunder. You may choose to offer, and
+to charge a fee for, warranty, support, indemnity or liability
+obligations to one or more recipients of Covered
+Software. However, you may do so only on Your own behalf, and
+not on behalf of the Initial Developer or any Contributor. You
+must make it absolutely clear that any such warranty, support,
+indemnity or liability obligation is offered by You alone, and
+You hereby agree to indemnify the Initial Developer and every
+Contributor for any liability incurred by the Initial Developer
+or such Contributor as a result of warranty, support, indemnity
+or liability terms You offer.
+
+3.5. Distribution of Executable Versions. You may distribute the
+Executable form of the Covered Software under the terms of this
+License or under the terms of a license of Your choice, which
+may contain terms different from this License, provided that You
+are in compliance with the terms of this License and that the
+license for the Executable form does not attempt to limit or
+alter the recipients rights in the Source Code form from the
+rights set forth in this License. If You distribute the Covered
+Software in Executable form under a different license, You must
+make it absolutely clear that any terms which differ from this
+License are offered by You alone, not by the Initial Developer
+or Contributor. You hereby agree to indemnify the Initial
+Developer and every Contributor for any liability incurred by
+the Initial Developer or such Contributor as a result of any
+such terms You offer.
+
+3.6. Larger Works. You may create a Larger Work by combining
+Covered Software with other code not governed by the terms of
+this License and distribute the Larger Work as a single product.
+In such a case, You must make sure the requirements of this
+License are fulfilled for the Covered Software.
+
+4. Versions of the License.
+
+4.1. New Versions. Sun Microsystems, Inc. is the initial license
+steward and may publish revised and/or new versions of this
+License from time to time. Each version will be given a
+distinguishing version number. Except as provided in Section
+4.3, no one other than the license steward has the right to
+modify this License.
+
+4.2. Effect of New Versions. You may always continue to use,
+distribute or otherwise make the Covered Software available
+under the terms of the version of the License under which You
+originally received the Covered Software. If the Initial
+Developer includes a notice in the Original Software prohibiting
+it from being distributed or otherwise made available under any
+subsequent version of the License, You must distribute and make
+the Covered Software available under the terms of the version of
+the License under which You originally received the Covered
+Software.  Otherwise, You may also choose to use, distribute or
+otherwise make the Covered Software available under the terms of
+any subsequent version of the License published by the license
+steward.
+
+4.3. Modified Versions. When You are an Initial Developer and
+You want to create a new license for Your Original Software, You
+may create and use a modified version of this License if You:
+(a) rename the license and remove any references to the name of
+the license steward (except to note that the license differs
+from this License); and (b) otherwise make it clear that the
+license contains terms which differ from this License.
+
+5. DISCLAIMER OF WARRANTY. COVERED SOFTWARE IS PROVIDED UNDER
+THIS LICENSE ON AN AS IS BASIS, WITHOUT WARRANTY OF ANY KIND,
+EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
+WARRANTIES THAT THE COVERED SOFTWARE IS FREE OF DEFECTS,
+MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING.
+THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE COVERED
+SOFTWARE IS WITH YOU. SHOULD ANY COVERED SOFTWARE PROVE
+DEFECTIVE IN ANY RESPECT, YOU (NOT THE INITIAL DEVELOPER OR ANY
+OTHER CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY SERVICING,
+REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN
+ESSENTIAL PART OF THIS LICENSE. NO USE OF ANY COVERED SOFTWARE
+IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER.
+
+6. TERMINATION.
+
+6.1. This License and the rights granted hereunder will
+terminate automatically if You fail to comply with terms herein
+and fail to cure such breach within 30 days of becoming aware of
+the breach. Provisions which, by their nature, must remain in
+effect beyond the termination of this License shall survive.
+
+6.2. If You assert a patent infringement claim (excluding
+declaratory judgment actions) against Initial Developer or a
+Contributor (the Initial Developer or Contributor against whom
+You assert such claim is referred to as Participant) alleging
+that the Participant Software (meaning the Contributor Version
+where the Participant is a Contributor or the Original Software
+where the Participant is the Initial Developer) directly or
+indirectly infringes any patent, then any and all rights granted
+directly or indirectly to You by such Participant, the Initial
+Developer (if the Initial Developer is not the Participant) and
+all Contributors under Sections 2.1 and/or 2.2 of this License
+shall, upon 60 days notice from Participant terminate
+prospectively and automatically at the expiration of such 60 day
+notice period, unless if within such 60 day period You withdraw
+Your claim with respect to the Participant Software against such
+Participant either unilaterally or pursuant to a written
+agreement with Participant.
+
+6.3. In the event of termination under Sections 6.1 or 6.2
+above, all end user licenses that have been validly granted by
+You or any distributor hereunder prior to termination (excluding
+licenses granted to You by any distributor) shall survive
+termination.
+
+7. LIMITATION OF LIABILITY. UNDER NO CIRCUMSTANCES AND UNDER NO
+LEGAL THEORY, WHETHER TORT (INCLUDING NEGLIGENCE), CONTRACT, OR
+OTHERWISE, SHALL YOU, THE INITIAL DEVELOPER, ANY OTHER
+CONTRIBUTOR, OR ANY DISTRIBUTOR OF COVERED SOFTWARE, OR ANY
+SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR ANY
+INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY
+CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOST
+PROFITS, LOSS OF GOODWILL, WORK STOPPAGE, COMPUTER FAILURE OR
+MALFUNCTION, OR ANY AND ALL OTHER COMMERCIAL DAMAGES OR LOSSES,
+EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE POSSIBILITY
+OF SUCH DAMAGES. THIS LIMITATION OF LIABILITY SHALL NOT APPLY TO
+LIABILITY FOR DEATH OR PERSONAL INJURY RESULTING FROM SUCH
+PARTYS NEGLIGENCE TO THE EXTENT APPLICABLE LAW PROHIBITS SUCH
+LIMITATION. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OR
+LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THIS
+EXCLUSION AND LIMITATION MAY NOT APPLY TO YOU.
+
+8. U.S. GOVERNMENT END USERS. The Covered Software is a
+commercial item, as that term is defined in 48 C.F.R. 2.101
+(Oct. 1995), consisting of commercial computer software (as that
+term is defined at 48 C.F.R. 252.227-7014(a)(1)) and commercial
+computer software documentation as such terms are used in 48
+C.F.R. 12.212 (Sept. 1995). Consistent with 48 C.F.R. 12.212 and
+48 C.F.R. 227.7202-1 through 227.7202-4 (June 1995), all
+U.S. Government End Users acquire Covered Software with only
+those rights set forth herein. This U.S. Government Rights
+clause is in lieu of, and supersedes, any other FAR, DFAR, or
+other clause or provision that addresses Government rights in
+computer software under this License.
+
+9. MISCELLANEOUS. This License represents the complete agreement
+concerning subject matter hereof. If any provision of this
+License is held to be unenforceable, such provision shall be
+reformed only to the extent necessary to make it enforceable.
+This License shall be governed by the law of the jurisdiction
+specified in a notice contained within the Original Software
+(except to the extent applicable law, if any, provides
+otherwise), excluding such jurisdictions conflict-of-law
+provisions. Any litigation relating to this License shall be
+subject to the jurisdiction of the courts located in the
+jurisdiction and venue specified in a notice contained within
+the Original Software, with the losing party responsible for
+costs, including, without limitation, court costs and reasonable
+attorneys fees and expenses. The application of the United
+Nations Convention on Contracts for the International Sale of
+Goods is expressly excluded. Any law or regulation which
+provides that the language of a contract shall be construed
+against the drafter shall not apply to this License. You agree
+that You alone are responsible for compliance with the United
+States export administration regulations (and the export control
+laws and regulation of any other countries) when You use,
+distribute or otherwise make available any Covered Software.
+
+10. RESPONSIBILITY FOR CLAIMS. As between Initial Developer and
+the Contributors, each party is responsible for claims and
+damages arising, directly or indirectly, out of its utilization
+of rights under this License and You agree to work with Initial
+Developer and Contributors to distribute such responsibility on
+an equitable basis. Nothing herein is intended or shall be
+deemed to constitute any admission of liability.
+
+----------------------------------------------------------------
+
+NOTICE PURSUANT TO SECTION 9 OF THE COMMON DEVELOPMENT AND
+DISTRIBUTION LICENSE (CDDL): This code is released under the
+CDDL and shall be governed by the laws of the State of
+California (excluding conflict-of-law provisions). Any
+litigation relating to this License shall be subject to the
+jurisdiction of the Federal Courts of the Northern District of
+California and the state courts of the State of California, with
+venue lying in Santa Clara County, California.
+
+----------------------------------------------------------------
+
Index: libs/libkdcraw/libraw/COPYRIGHT
===================================================================
--- libs/libkdcraw/libraw/COPYRIGHT	(révision 1122317)
+++ libs/libkdcraw/libraw/COPYRIGHT	(copie de travail)
@@ -1,358 +1,19 @@
-
  ** LibRaw: Raw images processing library **
 
- Copyright (C) 2008-2009 Alex Tutubalin <lexa@lexa.ru> and Illiah Borg <ib@pochtar.com>
+ Copyright (C) 2008-2010 LibRaw LLC (http://www.libraw.org, info@libraw.org)
  
 LibRaw is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.  See below details.
+it under the terms of the one of three licenses as you choose:
 
-Contact author if you want to use and/or redistribute LibRaw under non
-GNU GPL license.
+1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
+   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
 
+2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
+   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
 
-LibRaw uses code from dcraw.c -- Dave Coffin's raw photo decoder,
-dcraw.c is copyright 1997-2008 by Dave Coffin, dcoffin a cybercom o net.
+3. LibRaw Software License 27032010
+   (See file LICENSE.LibRaw.pdf provided in LibRaw distribution archive for details).
 
-========================================================================
 
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
+LibRaw uses code from dcraw.c -- Dave Coffin's raw photo decoder,
+dcraw.c is copyright 1997-2009 by Dave Coffin, dcoffin a cybercom o net.
Index: libs/libkdcraw/libraw/internal/libraw_internal_funcs.h
===================================================================
--- libs/libkdcraw/libraw/internal/libraw_internal_funcs.h	(révision 1122317)
+++ libs/libkdcraw/libraw/internal/libraw_internal_funcs.h	(copie de travail)
@@ -148,20 +148,6 @@
     void        sony_arw2_load_raw();
     void        parse_minolta (int base);
 
-// Foveon/Sigma
-    void        foveon_load_camf();
-    void        foveon_load_raw();
-    const char* foveon_camf_param (const char *block, const char *param);
-    void *      foveon_camf_matrix (unsigned dim[3], const char *name);
-    int         foveon_fixed (void *ptr, int size, const char *name);
-    float       foveon_avg (short *pix, int range[2], float cfilt);
-    short *     foveon_make_curve (double max, double mul, double filt);
-    void        foveon_make_curves(short **curvep, float dq[3], float div[3], float filt);
-    int         foveon_apply_curve (short *curve, int i);
-    void        foveon_interpolate();
-    char *      foveon_gets (int offset, char *str, int len);
-    void        parse_foveon();
-
 // CAM/RGB
     void        pseudoinverse (double (*in)[3], double (*out)[3], int size);
     void        cam_xyz_coeff (double cam_xyz[4][3]);
Index: libs/libkdcraw/libraw/internal/defines.h
===================================================================
--- libs/libkdcraw/libraw/internal/defines.h	(révision 1122317)
+++ libs/libkdcraw/libraw/internal/defines.h	(copie de travail)
@@ -1,11 +1,13 @@
 /* 
    GENERATED FILE, DO NOT EDIT
-   Generated from dcraw/dcraw.c at Wed Dec 30 14:11:09 2009
+   Generated from dcraw/dcraw.c at Wed Apr 21 09:55:20 2010
    Look into original file (probably http://cybercom.net/~dcoffin/dcraw/dcraw.c)
    for copyright information.
 */
 
+#line 27 "dcraw/dcraw.c"
 #define NO_JPEG
+#line 32 "dcraw/dcraw.c"
 #define VERSION "8.99"
 
 #ifndef _GNU_SOURCE
@@ -43,6 +45,7 @@
 #else
 #define _(String) (String)
 #endif
+#line 77 "dcraw/dcraw.c"
 #ifdef __CYGWIN__
 #include <io.h>
 #endif
@@ -53,10 +56,12 @@
 #define snprintf _snprintf
 #define strcasecmp _stricmp
 #define strncasecmp strnicmp
+#line 91 "dcraw/dcraw.c"
 #else
 #include <unistd.h>
 #include <utime.h>
 #include <netinet/in.h>
+#line 99 "dcraw/dcraw.c"
 #endif
 
 #ifdef LJPEG_DECODE
@@ -67,6 +72,7 @@
 #ifndef LONG_BIT
 #define LONG_BIT (8 * sizeof (long))
 #endif
+#line 175 "dcraw/dcraw.c"
 #define FORC(cnt) for (c=0; c < cnt; c++)
 #define FORC3 FORC(3)
 #define FORC4 FORC(4)
@@ -120,8 +126,8 @@
 	3 G R G R G R	3 B G B G B G	3 R G R G R G	3 G B G B G B
  */
 
+#line 233 "dcraw/dcraw.c"
 #define BAYER(row,col) \
 	image[((row) >> shrink)*iwidth + ((col) >> shrink)][FC(row,col)]
-
 #define BAYER2(row,col) \
 	image[((row) >> shrink)*iwidth + ((col) >> shrink)][fc(row,col)]
Index: libs/libkdcraw/libraw/internal/dcraw_fileio.cpp
===================================================================
--- libs/libkdcraw/libraw/internal/dcraw_fileio.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/internal/dcraw_fileio.cpp	(copie de travail)
@@ -1,16 +1,18 @@
 /* 
    GENERATED FILE, DO NOT EDIT
-   Generated from dcraw/dcraw.c at Wed Dec 30 14:11:10 2009
+   Generated from dcraw/dcraw.c at Wed Apr 21 09:55:26 2010
    Look into original file (probably http://cybercom.net/~dcoffin/dcraw/dcraw.c)
    for copyright information.
 */
 
+#line 3976 "dcraw/dcraw.c"
 #define CLASS LibRaw::
 #include "libraw/libraw_types.h"
 #define LIBRAW_LIBRARY_BUILD
 #include "libraw/libraw.h"
 #include "internal/defines.h"
 #include "internal/var_defines.h"
+#line 3986 "dcraw/dcraw.c"
 
 /*
    Seach from the current directory up to the root looking for
@@ -28,6 +30,7 @@
 #endif
   if (cfname)
     fp = fopen (cfname, "r");
+#line 4029 "dcraw/dcraw.c"
   if (!fp) 
       {
 #ifdef LIBRAW_LIBRARY_BUILD
@@ -123,6 +126,7 @@
   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);
 #endif
 }
+#line 9550 "dcraw/dcraw.c"
 
 #ifndef NO_LCMS
 void CLASS apply_profile (const char *input, const char *output)
Index: libs/libkdcraw/libraw/internal/dcraw_common.cpp
===================================================================
--- libs/libkdcraw/libraw/internal/dcraw_common.cpp	(révision 1122317)
+++ libs/libkdcraw/libraw/internal/dcraw_common.cpp	(copie de travail)
@@ -1,10 +1,11 @@
 /* 
    GENERATED FILE, DO NOT EDIT
-   Generated from dcraw/dcraw.c at Wed Dec 30 14:11:09 2009
+   Generated from dcraw/dcraw.c at Wed Apr 21 09:55:20 2010
    Look into original file (probably http://cybercom.net/~dcoffin/dcraw/dcraw.c)
    for copyright information.
 */
 
+#line 264 "dcraw/dcraw.c"
 #define CLASS LibRaw::
 #include "libraw/libraw_types.h"
 #define LIBRAW_LIBRARY_BUILD
@@ -13,6 +14,7 @@
 #include "internal/defines.h"
 #include "internal/var_defines.h"
 
+#line 274 "dcraw/dcraw.c"
 
 #ifndef __GLIBC__
 char *my_memmem (char *haystack, size_t haystacklen,
@@ -27,6 +29,7 @@
 #define memmem my_memmem
 #endif
 
+#line 308 "dcraw/dcraw.c"
 
 ushort CLASS sget2 (uchar *s)
 {
@@ -101,6 +104,7 @@
   if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))
       swab ((char*)pixel, (char*)pixel, count*2);
 }
+#line 385 "dcraw/dcraw.c"
 void CLASS canon_black (double dark[2], int nblack)
 {
   int c, diff, row, col;
@@ -268,7 +272,9 @@
       pix[7] = (dp[8] << 2) + (dp[9] >> 6    );
     }
     for (col=0; col < width; col++)
-      BAYER(row,col) = pixel[col];
+        {
+            BAYER(row,col) = pixel[col];
+        }
     for (col=width; col < raw_width; col++)
         {
             black += pixel[col];
@@ -291,6 +297,9 @@
       if ((val = BAYER(row,col) - black) < 0) val = 0;
       val = val * mul[row & 3][col & 1] >> 9;
       BAYER(row,col) = val;
+#ifdef LIBRAW_LIBRARY_BUILD
+      if((int)channel_maximum[FC(row,col)] < val ) channel_maximum[FC(row,col)] = val;
+#endif
     }
   canon_600_fixed_wb(1311);
   canon_600_auto_wb();
@@ -497,7 +506,8 @@
 int CLASS canon_has_lowbits()
 {
   uchar test[0x4000];
-  int ret=1, i;
+  int ret=1;
+  unsigned i;
 
   fseek (ifp, 0, SEEK_SET);
   fread (test, 1, sizeof test, ifp);
@@ -576,7 +586,14 @@
 #endif
 	icol = col - left_margin;
 	if (icol < width)
-	  BAYER(irow,icol) = pixel[r*raw_width+col];
+            {
+#ifdef LIBRAW_LIBRARY_BUILD
+                ushort val = pixel[r*raw_width+col];
+                ushort color = FC(irow,icol);
+                if(channel_maximum[color] < val) channel_maximum[color]=val;
+#endif
+                BAYER(irow,icol) = pixel[r*raw_width+col];
+            }
 	else if (col > 1 && (unsigned) (col-left_margin+2) > width+3)
 	  dark[icol & 1] += (nblack++,pixel[r*raw_width+col]);
       }
@@ -587,6 +604,7 @@
   canon_black (dark, nblack);
 }
 
+#line 895 "dcraw/dcraw.c"
 int CLASS ljpeg_start (struct jhead *jh, int info_only)
 {
   int c, tag, len;
@@ -733,6 +751,10 @@
 #endif
       if ((unsigned) (row-top_margin) < height) {
 	if ((unsigned) (col-left_margin) < width) {
+#ifdef LIBRAW_LIBRARY_BUILD
+            ushort color = FC(row-top_margin,col-left_margin);
+            if(channel_maximum[color] < val) channel_maximum[color] = val;
+#endif
 	  BAYER(row-top_margin,col-left_margin) = val;
 	  if (min > val) min = val;
 	} else if (col > 1 && (unsigned) (col-left_margin+2) > width+3)
@@ -809,7 +831,15 @@
       pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);
       pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);
     }
-    FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);
+    FORC3 { 
+#ifdef LIBRAW_LIBRARY_BUILD
+        ushort val = CLIP(pix[c] * sraw_mul[c] >> 10);
+        rp[c] = val;
+        if(channel_maximum[c] < val) channel_maximum[c] = val;
+#else
+        rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);
+#endif
+    }
   }
   ljpeg_end (&jh);
   maximum = 0x3fff;
@@ -834,7 +864,11 @@
     if(!(filtering_mode & LIBRAW_FILTERING_NORAWCURVE))
         val = **rp < 0x1000 ? curve[**rp] : **rp;
     if (r < height && c < width)
-        BAYER(r,c) = val;
+        {
+            ushort color = COLOR(r,c);
+            image[((row) >> shrink)*iwidth + ((col) >> shrink)][color] = val;
+            if(channel_maximum[color] < val) channel_maximum[color] = val;
+        }
     else
         {
             ushort *dfp = get_masked_pointer(row+top_margin,col+left_margin);
@@ -929,8 +963,14 @@
       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
       else	   hpred[col & 1] += diff;
       if ((unsigned) (row-top_margin) < height && col < width)
-	BAYER(row-top_margin,col) = hpred[col & 1];
+          {
 #ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row-top_margin,col);
+              if(channel_maximum[color] < hpred[col & 1])  channel_maximum[color] = hpred[col & 1];
+#endif
+              BAYER(row-top_margin,col) = hpred[col & 1];
+          }
+#ifdef LIBRAW_LIBRARY_BUILD
       else
         {
           ushort *dfp = get_masked_pointer(row,col);
@@ -1020,6 +1060,8 @@
           xval = curve[LIM((short)xval,0,0x3fff)];
       if ((unsigned) (col-left_margin) < width)
           {
+              ushort color = FC(row,col-left_margin);
+              if(channel_maximum[color] < xval ) channel_maximum[color] = xval;
               BAYER(row,col-left_margin) =  xval;
           }
       else
@@ -1166,15 +1208,9 @@
             {
                 int rrow = row-top_margin;
                 int ccol = col-left_margin;
-                if (fuji_layout) {
-                    r = fuji_width - 1 - ccol + (rrow >> 1);
-                    c = ccol + ((rrow+1) >> 1);
-                } else {
-                    r = fuji_width - 1 + rrow - (ccol >> 1);
-                    c = rrow + ((ccol+1) >> 1);
-                }
-
-                image[((row-top_margin) >> shrink)*iwidth + ((col-left_margin) >> shrink)][FC(r,c)] = pixel[col];
+                ushort color = FCF(rrow,ccol);
+                image[((rrow) >> shrink)*iwidth + ((ccol) >> shrink)][color] = pixel[col];
+                if(channel_maximum[color] < pixel[col] ) channel_maximum[color] = pixel[col];
             }
         else
             {
@@ -1186,6 +1222,7 @@
   free (pixel);
 #endif
 }
+#line 1517 "dcraw/dcraw.c"
 void CLASS ppm_thumb()
 {
   char *thumb;
@@ -1253,8 +1290,15 @@
       row = todo[i] / raw_width - top_margin;
       col = todo[i] % raw_width - left_margin;
       if (row < height && col < width)
-	BAYER(row,col) = (todo[i+1] & 0x3ff);
+          {
 #ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,col);
+              if(channel_maximum[color] < (todo[i+1] & 0x3ff))
+                  channel_maximum[color] = (todo[i+1] & 0x3ff);
+#endif
+              BAYER(row,col) = (todo[i+1] & 0x3ff);
+          }
+#ifdef LIBRAW_LIBRARY_BUILD
       else
           {
               ushort *dfp = get_masked_pointer(todo[i] / raw_width,todo[i] % raw_width);
@@ -1484,7 +1528,11 @@
             if(dfp)
                 *dfp = pixel[col];
             else
-                BAYER(row-top_margin,col-left_margin) = pixel[col];
+                {
+                    ushort color = FC(row-top_margin,col-left_margin);
+                    if(channel_maximum[color] < pixel[col]) channel_maximum[color] = pixel[col];
+                    BAYER(row-top_margin,col-left_margin) = pixel[col];
+                }
         }
   }
   free (pixel);
@@ -1595,7 +1643,11 @@
                   - ph1.t_black + t_black[row][(col /* - left_margin */) >= ph1.split_col]; // changed to fix Coffin's bug!
           if(col >= left_margin && col < width+left_margin)
               {
-                  if (i > 0) BAYER(row-top_margin,col-left_margin) = i;
+                  if (i > 0){
+                      ushort color = FC(row-top_margin,col-left_margin);
+                      BAYER(row-top_margin,col-left_margin) = i;
+                      if(channel_maximum[color] < i) channel_maximum[color] = i ;
+                  }
               }
           else
               {
@@ -1646,7 +1698,13 @@
 	if (diff == 65535) diff = -32768;
 	pred[c] += diff;
 	if (row >= 0 && row < height && (unsigned)(col+c) < width)
+            {
+#ifdef LIBRAW_LIBRARY_BUILD
+                ushort color = FC(row,col+c);
+                if(channel_maximum[color] < pred[c] ) channel_maximum[color]=pred[c];
+#endif
 	  BAYER(row,col+c) = pred[c];
+            }
 #ifdef LIBRAW_LIBRARY_BUILD
         else
             {
@@ -1678,8 +1736,19 @@
       read_shorts (pixel, raw_width);
       if ((row = r - top_margin) >= height) continue;
       for (col=0; col < width; col++)
-	if (filters)  BAYER(row,col) = pixel[col];
-	else image[row*width+col][c] = pixel[col];
+          {
+              if (filters)  BAYER(row,col) = pixel[col];
+              else image[row*width+col][c] = pixel[col];
+#ifdef LIBRAW_LIBRARY_BUILD
+              if(filters)
+                  {
+                      ushort color = FC(row,col);
+                      if(channel_maximum[color] < pixel[col]) channel_maximum[color] = pixel[col];
+                  }
+              else
+                  if(channel_maximum[c] < pixel[col]) channel_maximum[c] = pixel[col];
+#endif              
+          }
     }
   free (pixel);
   if (!filters) {
@@ -1688,6 +1757,7 @@
   }
 }
 
+#line 2055 "dcraw/dcraw.c"
 void CLASS sinar_4shot_load_raw()
 {
   ushort *pixel;
@@ -1729,7 +1799,13 @@
 
   for (row=0; row < height; row++)
     for (col=0; col < width; col++)
+        {
       read_shorts (image[row*width+col], 3);
+#ifdef LIBRAW_LIBRARY_BUILD
+      for(int c=0; c<3; c++)
+          if(image[row*width+col][c] > channel_maximum[c]) channel_maximum[c] = image[row*width+col][c];
+#endif
+        }
 }
 
 void CLASS packed_load_raw()
@@ -1766,7 +1842,16 @@
       val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);
       i = (col ^ (bite == 24)) - left_margin;
       if ((unsigned) i < width)
+          {
+#ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,i);
+              ushort xval = val << (load_flags >> 6);
+              if( channel_maximum[color] < xval ) channel_maximum[color] = xval;
+              BAYER(row,i) = xval;
+#else
 	BAYER(row,i) = val << (load_flags >> 6);
+#endif
+          }
       else if (load_flags & 32)
 #ifdef LIBRAW_LIBRARY_BUILD
           {
@@ -1817,7 +1902,9 @@
                 *dfp = pixel[col];
             else
                 {
+                    ushort color = FC(row-top_margin,col-left_margin);
                     if ((BAYER2(row-top_margin,col-left_margin) = pixel[col]) >> bits) derror();
+                    if (channel_maximum[color] < pixel[col] ) channel_maximum[color] = pixel[col];
                 }
         }
   }
@@ -1854,8 +1941,14 @@
 #else
       FORC(width) black += pixel[c];
 #endif
-    else
-      FORC(width) BAYER(row-top_margin,c) = pixel[c];
+      else
+              FORC(width){
+#ifdef LIBRAW_LIBRARY_BUILD
+                  ushort color = FC(row-top_margin,c);
+                  if(channel_maximum[color] < pixel[c]) channel_maximum[color] = pixel[c];
+#endif
+                  BAYER(row-top_margin,c) = pixel[c];
+              }
   }
   free (data);
   if (top_margin) black /= top_margin * width;
@@ -1906,8 +1999,16 @@
       } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
 	pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
       if (col < width)
-      if ((BAYER(row,col) = pred[col & 1]) > 4098) derror();
+          {
 #ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,col);
+#endif
+              if ((BAYER(row,col) = pred[col & 1]) > 4098) derror();
+#ifdef LIBRAW_LIBRARY_BUILD
+              if( channel_maximum[color] < pred[col &1] ) channel_maximum[color] = pred[col &1];
+#endif
+          }
+#ifdef LIBRAW_LIBRARY_BUILD
       if(col>=width)
           {
               ushort *dfp = get_masked_pointer(row,col);
@@ -1956,7 +2057,17 @@
 	  else pred = (w + n) >> 1;
 	} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;
       }
+#ifdef LIBRAW_LIBRARY_BUILD
+      {
+          ushort val = pred + ((diff << 2) | low);
+          ushort color = FC(row,col);
+          if(val >> 12) derror();
+          BAYER(row,col)=val;
+          if(channel_maximum[color] < val ) channel_maximum[color] = val;
+      }
+#else
       if ((BAYER(row,col) = pred + ((diff << 2) | low)) >> 12) derror();
+#endif
     }
   }
 }
@@ -1984,7 +2095,14 @@
       BAYER(row,1533) = pixel[765] << 1;
     } else
       for (col=row & 1; col < 1534; col+=2)
-	BAYER(row,col) = pixel[col/2] << 1;
+          {
+#ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,col);
+              if(channel_maximum[color] < pixel[col/2] << 1)
+                  channel_maximum[color] = pixel[col/2] << 1;
+#endif
+              BAYER(row,col) = pixel[col/2] << 1;
+          }
   }
   maximum = 0xff << 1;
 }
@@ -2052,7 +2170,14 @@
     }
   for (row=0; row < height; row++)
     for (col=0; col < width; col++)
-      BAYER(row,col) = t_curve[pixel[row+2][col+2]];
+        {
+#ifdef LIBRAW_LIBRARY_BUILD
+            ushort color = FC(row,col);
+            if(channel_maximum[color] < t_curve[pixel[row+2][col+2]])
+                channel_maximum[color] = t_curve[pixel[row+2][col+2]];
+#endif
+            BAYER(row,col) = t_curve[pixel[row+2][col+2]];
+        }
   maximum = 0x3ff;
 }
 
@@ -2156,7 +2281,15 @@
 	}
   }
   for (i=0; i < iheight*iwidth*4; i++)
+#ifdef LIBRAW_LIBRARY_BUILD
+      {
+          ushort c = i%4;
+          image[0][i] = curve[image[0][i]];
+          if(channel_maximum[c] < image[0][i]) channel_maximum[c] = image[0][i];
+      }
+#else
     image[0][i] = curve[image[0][i]];
+#endif
   maximum = 0x3fff;
 }
 
@@ -2226,6 +2359,15 @@
       BAYER(row+1,col+1) = pixel[col+1][1] << 1;
       BAYER(row+0,col+1) = pixel[col][0] + pixel[col+1][0];
       BAYER(row+1,col+0) = pixel[col][2] + pixel[col+1][2];
+
+#ifdef LIBRAW_LIBRARY_BUILD
+      if(channel_maximum[FC(row+0,col+0)] < pixel[col+0][1] << 1) channel_maximum[FC(row+0,col+0)]=pixel[col+0][1]<<1;
+      if(channel_maximum[FC(row+1,col+1)] < pixel[col+1][1] << 1) channel_maximum[FC(row+1,col+1)]=pixel[col+1][1]<<1;
+      if(channel_maximum[FC(row+0,col+1)] < pixel[col][0] + pixel[col+1][0])
+          channel_maximum[FC(row+0,col+1)] = pixel[col][0] + pixel[col+1][0];
+      if(channel_maximum[FC(row+1,col+0)] < pixel[col][2] + pixel[col+1][2])
+          channel_maximum[FC(row+1,col+0)] = pixel[col][2] + pixel[col+1][2];
+#endif
     }
   }
   jpeg_finish_decompress (&cinfo);
@@ -2245,7 +2387,16 @@
     if (fread (pixel, 1, 848, ifp) < 848) derror();
     shift = row * mul[row & 3] + add[row & 3];
     for (col=0; col < width; col++)
+#ifdef LIBRAW_LIBRARY_BUILD
+        {
+            ushort val = pixel[(col + shift) % 848];
+            ushort color = FC(row,col);
+            BAYER(row,col) = val;
+            if(channel_maximum[color] < val) channel_maximum[color] = val;
+        }
+#else
       BAYER(row,col) = (ushort) pixel[(col + shift) % 848];
+#endif
   }
   maximum = 0xff;
 }
@@ -2282,7 +2433,11 @@
       if((unsigned) (row-top_margin)< height)
           {
               if ((unsigned) (col-left_margin) < width)
-                  BAYER(row,col-left_margin) = val;
+                  {
+                      ushort color=FC(row,col);
+                      if(channel_maximum[color] < val) channel_maximum[color] = val;
+                      BAYER(row,col-left_margin) = val;
+                  }
               else
                   {
                       ushort *dfp = get_masked_pointer(row,col);
@@ -2327,7 +2482,12 @@
       rgb[1] = y-((cb + cr + 2) >> 2);
       rgb[2] = rgb[1] + cb;
       rgb[0] = rgb[1] + cr;
-      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];
+      FORC3{
+          image[row*width+col][c] = curve[LIM(rgb[c],0,255)];
+#ifdef LIBRAW_LIBRARY_BUILD
+          if(channel_maximum[c] < image[row*width+col][c]) channel_maximum[c] = image[row*width+col][c];
+#endif
+      }
     }
   }
   free (pixel);
@@ -2376,7 +2536,13 @@
       val = curve[pixel[pi++]];
 #endif
       if ((unsigned) (col-left_margin) < width)
+          {
+#ifdef LIBRAW_LIBRARY_BUILD
+              ushort color = FC(row,col-left_margin);
+              if(channel_maximum[color] < val ) channel_maximum[color]=val;
+#endif
 	BAYER(row,col-left_margin) = val;
+          }
       else
 #ifndef LIBRAW_LIBRARY_BUILD
           black += val;
@@ -2458,9 +2624,11 @@
 #else
       {
           ushort val = ret ? buf[i] : (pred[i & 1] += buf[i]);
+          ushort color = FC(row,col);
           if(!(filtering_mode & LIBRAW_FILTERING_NORAWCURVE))
               val = curve[val];
           BAYER(row,col+i)=val;
+          if(channel_maximum[color] < val ) channel_maximum[color]=val;
           if(curve[val]>>12) derror();
       }
 #endif
@@ -2495,6 +2663,9 @@
               FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];
           else
               FORC3 ip[c] = y[j][k]+rgb[c];;
+          FORC3
+              if(channel_maximum[c] < ip[c])
+                  channel_maximum[c] = ip[c];
 #endif
 	  }
       }
@@ -2513,7 +2684,12 @@
       kodak_65000_decode (buf, len*3);
       memset (rgb, 0, sizeof rgb);
       for (bp=buf, i=0; i < len; i++, ip+=4)
-	FORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();
+          FORC3{
+              if ((ip[c] = rgb[c] += *bp++) >> 12) derror();
+#ifdef LIBRAW_LIBRARY_BUILD
+              if(channel_maximum[c] < ip[c]) channel_maximum[c] = ip[c];
+#endif
+          }
     }
 }
 
@@ -2589,8 +2765,19 @@
     for (col=9; col < left_margin; col++)
       black += ntohs(pixel[col]);
     for (col=0; col < width; col++)
+#ifdef LIBRAW_LIBRARY_BUILD
+        {
+            ushort color = FC(row,col);
+            ushort  val = ntohs(pixel[col+left_margin]);
+            if(val>>14)
+                derror();
+            BAYER(row,col)=val;
+            if(channel_maximum[color] < val ) channel_maximum[color] = val;
+        }
+#else
       if ((BAYER(row,col) = ntohs(pixel[col+left_margin])) >> 14)
 	derror();
+#endif    
   }
   free (pixel);
   if (left_margin > 9)
@@ -2617,8 +2804,15 @@
       if ((diff & (1 << (len-1))) == 0)
 	diff -= (1 << len) - 1;
       if ((sum += diff) >> 12) derror();
-      if (row < height) BAYER(row,col) = sum;
+      if (row < height)
+          {
+              BAYER(row,col) = sum;
 #ifdef LIBRAW_LIBRARY_BUILD
+            ushort color = FC(row,col);
+            if(channel_maximum[color] < sum ) channel_maximum[color] = sum;
+#endif
+          }
+#ifdef LIBRAW_LIBRARY_BUILD
       else
           {
               ushort *dfp = get_masked_pointer(row,col);
@@ -2658,9 +2852,11 @@
 #else
         {
             ushort val = pix[i];
+            ushort color = FC(row,col);
             if(!(filtering_mode & LIBRAW_FILTERING_NORAWCURVE))
                 val = curve[val<<1]>>1;
             BAYER(row,col)=val;
+            if(channel_maximum[color] < val ) channel_maximum[color] = val;
         }
 #endif
       col -= col & 1 ? 1:31;
@@ -2732,8 +2928,15 @@
     row = pix / raw_width - top_margin;
     col = pix % raw_width - left_margin;
     if (row < height && col < width)
-      BAYER(row,col) = pred[pix & 1];
+        {
 #ifdef LIBRAW_LIBRARY_BUILD
+            ushort color = FC(row,col);
+            if(channel_maximum[color] < pred[pix & 1])
+                channel_maximum[color] = pred[pix & 1];
+#endif
+            BAYER(row,col) = pred[pix & 1];
+        }
+#ifdef LIBRAW_LIBRARY_BUILD
     else
         {
             ushort *dfp = get_masked_pointer(row+top_margin,col+left_margin);
@@ -2815,6 +3018,7 @@
     smal_decode_segment (seg+i, holes);
   if (holes) fill_holes (holes);
 }
+#line 4127 "dcraw/dcraw.c"
 
 void CLASS gamma_curve (double pwr, double ts, int mode, int imax)
 {
@@ -3160,7 +3364,7 @@
 		window[2][col-1] + window[2][col+1] - black*4 )
 	      * mul[row & 1] + (window[1][col] - black) * 0.5 + black;
 	avg = avg < 0 ? 0 : sqrt(avg);
-	diff = sqrt(BAYER(row,col)) - avg;
+	diff = sqrt((double)BAYER(row,col)) - avg;
 	if      (diff < -thold) diff += thold;
 	else if (diff >  thold) diff -= thold;
 	else diff = 0;
@@ -3254,6 +3458,13 @@
   sat = maximum;
   if (threshold) wavelet_denoise();
   maximum -= black;
+#ifdef LIBRAW_LIBRARY_BUILD
+  for(i=0;i<4;i++)
+      if(channel_maximum[i]>=black)
+          channel_maximum[i]-=black;
+      else
+          channel_maximum[i] = 0;
+#endif
   for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {
     if (dmin > pre_mul[c])
 	dmin = pre_mul[c];
@@ -3785,7 +3996,7 @@
 
   for (i=0; i < 0x10000; i++) {
     r = i / 65535.0;
-    cbrt[i] = r > 0.008856 ? pow(r,1/3.0) : 7.787*r + 16/116.0;
+    cbrt[i] = r > 0.008856 ? pow((double)r,1/3.0) : 7.787*r + 16/116.0;
   }
   for (i=0; i < 3; i++)
     for (j=0; j < colors; j++)
@@ -4093,6 +4304,7 @@
   }
 }
 
+#line 5416 "dcraw/dcraw.c"
 void CLASS parse_makernote (int base, int uptag)
 {
   static const uchar xlat[2][256] = {
@@ -4634,6 +4846,7 @@
   }
 }
 
+#line 5961 "dcraw/dcraw.c"
 int CLASS parse_tiff_ifd (int base)
 {
   unsigned entries, tag, type, len, plen=16, save;
@@ -5406,7 +5619,7 @@
       fread (artist, 64, 1, ifp);
     if (type == 0x080a) {
       fread (make, 64, 1, ifp);
-      fseek (ifp, strlen(make) - 63, SEEK_CUR);
+      fseek (ifp, ((INT64)strlen(make)) - 63, SEEK_CUR);
       fread (model, 64, 1, ifp);
     }
     if (type == 0x1810) {
@@ -5717,9 +5930,13 @@
   size = get4();
   end = ftell(ifp) + size;
   if (!memcmp(tag,"RIFF",4) || !memcmp(tag,"LIST",4)) {
+      int cnt=0;
     get4();
     while (ftell(ifp)+7 < end)
-      parse_riff();
+        {
+            parse_riff();
+            if(cnt++>10000) break; // no more than 10k times
+        }
   } else if (!memcmp(tag,"nctg",4)) {
     while (ftell(ifp)+7 < end) {
       i = get2();
@@ -5814,6 +6031,7 @@
   data_offset  = (INT64) get4() + 8;
   data_offset += (INT64) get4() << 32;
 }
+#line 7247 "dcraw/dcraw.c"
 void CLASS adobe_coeff (const char *p_make, const char *p_model)
 {
   static const struct {
@@ -6376,6 +6594,7 @@
   return sum[0] < sum[1] ? 0x4d4d : 0x4949;
 }
 
+#line 7813 "dcraw/dcraw.c"
 
 float CLASS find_green (int bps, int bite, int off0, int off1)
 {
@@ -6511,7 +6730,11 @@
   write_thumb = &CLASS jpeg_thumb;
   data_offset = meta_length = tiff_bps = tiff_compress = 0;
   kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;
-  timestamp = shot_order = tiff_samples = black = is_foveon = 0;
+  timestamp = shot_order = tiff_samples = black = 
+#ifndef LIBRAW_LIBRARY_BUILD
+      is_foveon = 
+#endif
+      0;
   mix_green = profile_length = data_error = zero_is_bad = 0;
   pixel_aspect = is_raw = raw_color = 1;
   tile_width = tile_length = INT_MAX;
@@ -6539,8 +6762,8 @@
   fread (head, 1, 32, ifp);
   fseek (ifp, 0, SEEK_END);
   fsize = ftell(ifp);
-  if ((cp = (char *) memmem (head, 32, "MMMM", 4)) ||
-      (cp = (char *) memmem (head, 32, "IIII", 4))) {
+  if ((cp = (char *) memmem (head, 32, (char*)"MMMM", 4)) ||
+      (cp = (char *) memmem (head, 32, (char*)"IIII", 4))) {
     parse_phase_one (cp-head);
     if (cp-head) parse_tiff(0);
   } else if (order == 0x4949 || order == 0x4d4d) {
@@ -6612,8 +6835,10 @@
     parse_sinar_ia();
   else if (!memcmp (head,"\0MRM",4))
     parse_minolta(0);
+#ifndef LIBRAW_LIBRARY_BUILD
   else if (!memcmp (head,"FOVb",4))
     parse_foveon();
+#endif
   else if (!memcmp (head,"CI",2))
     parse_cine();
   else
@@ -6689,13 +6914,16 @@
 
 /* Set parameters based on camera name (for non-DNG files). */
 
+#ifndef LIBRAW_LIBRARY_BUILD
   if (is_foveon) {
     if (height*2 < width) pixel_aspect = 0.5;
     if (height   > width) pixel_aspect = 2;
     filters = 0;
     load_raw = &CLASS foveon_load_raw;
     simple_coeff(0);
-  } else if (is_canon && tiff_bps == 15) {
+  } else 
+#endif
+if (is_canon && tiff_bps == 15) {
     switch (width) {
       case 3344: width -= 66;
       case 3872: width -= 6;
@@ -8101,6 +8329,7 @@
   }
 }
 
+#line 9639 "dcraw/dcraw.c"
 void CLASS convert_to_rgb()
 {
   int row, col, c, i, j, k;
@@ -8319,6 +8548,7 @@
   return row * iwidth + col;
 }
 
+#line 9882 "dcraw/dcraw.c"
 void CLASS tiff_set (ushort *ntag,
 	ushort tag, ushort type, int count, int val)
 {
Index: libs/libkdcraw/libraw/internal/var_defines.h
===================================================================
--- libs/libkdcraw/libraw/internal/var_defines.h	(révision 1122317)
+++ libs/libkdcraw/libraw/internal/var_defines.h	(copie de travail)
@@ -29,7 +29,6 @@
 #define model           (imgdata.idata.model)
 #define is_raw          (imgdata.idata.raw_count)
 #define dng_version     (imgdata.idata.dng_version)
-#define is_foveon       (imgdata.idata.is_foveon)
 #define colors          (imgdata.idata.colors)
 #define cdesc           (imgdata.idata.cdesc)
 #define filters         (imgdata.idata.filters)
@@ -64,6 +63,7 @@
 #define black           (imgdata.color.black)
 #endif
 #define maximum         (imgdata.color.maximum)
+#define channel_maximum         (imgdata.color.channel_maximum)
 #define profile_length  (imgdata.color.profile_length)
 #define color_flags     (imgdata.color.color_flags)
 #define ph1             (imgdata.color.phase_one_data)
@@ -173,6 +173,9 @@
 #define fseeko(stream,o,w)	 stream->seek(o,w)
 #define ftell(stream)		 stream->tell()
 #define ftello(stream)		 stream->tell()
+#ifdef getc
+#undef getc
+#endif
 #define getc(stream)		 stream->get_char()
 #define fgetc(stream)		 stream->get_char()
 #define fgets(str,n,stream)	 stream->gets(str,n)
Index: libs/libkdcraw/libkdcraw/kdcraw_p.h
===================================================================
--- libs/libkdcraw/libkdcraw/kdcraw_p.h	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/kdcraw_p.h	(copie de travail)
@@ -6,7 +6,7 @@
  * Date        : 2008-10-09
  * Description : internal private container for KDcraw
  *
- * Copyright (C) 2008-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2008-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
Index: libs/libkdcraw/libkdcraw/rexpanderbox.cpp
===================================================================
--- libs/libkdcraw/libkdcraw/rexpanderbox.cpp	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/rexpanderbox.cpp	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2008-03-14
  * Description : A widget to host settings as expander box
  *
- * Copyright (C) 2008-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2008-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -34,6 +34,7 @@
 #include <QStyleOption>
 #include <QGridLayout>
 #include <QHBoxLayout>
+#include <QCheckBox>
 
 // KDE includes
 
@@ -47,13 +48,13 @@
 namespace KDcrawIface
 {
 
-RClickLabel::RClickLabel(QWidget *parent)
+RClickLabel::RClickLabel(QWidget* parent)
            : QLabel(parent)
 {
     setCursor(Qt::PointingHandCursor);
 }
 
-RClickLabel::RClickLabel(const QString& text, QWidget *parent)
+RClickLabel::RClickLabel(const QString& text, QWidget* parent)
            : QLabel(text, parent)
 {
     setCursor(Qt::PointingHandCursor);
@@ -71,7 +72,7 @@
     }
 }
 
-void RClickLabel::keyPressEvent(QKeyEvent *e)
+void RClickLabel::keyPressEvent(QKeyEvent* e)
 {
     switch (e->key())
     {
@@ -89,13 +90,13 @@
 
 // ------------------------------------------------------------------------
 
-RSqueezedClickLabel::RSqueezedClickLabel(QWidget *parent)
+RSqueezedClickLabel::RSqueezedClickLabel(QWidget* parent)
                    : KSqueezedTextLabel(parent)
 {
     setCursor(Qt::PointingHandCursor);
 }
 
-RSqueezedClickLabel::RSqueezedClickLabel(const QString& text, QWidget *parent)
+RSqueezedClickLabel::RSqueezedClickLabel(const QString& text, QWidget* parent)
                    : KSqueezedTextLabel(text, parent)
 {
     setCursor(Qt::PointingHandCursor);
@@ -113,7 +114,7 @@
     }
 }
 
-void RSqueezedClickLabel::keyPressEvent(QKeyEvent *e)
+void RSqueezedClickLabel::keyPressEvent(QKeyEvent* e)
 {
     switch (e->key())
     {
@@ -131,7 +132,7 @@
 
 // ------------------------------------------------------------------------
 
-RArrowClickLabel::RArrowClickLabel(QWidget *parent)
+RArrowClickLabel::RArrowClickLabel(QWidget* parent)
                 : QWidget(parent), m_arrowType(Qt::DownArrow)
 {
     setCursor(Qt::PointingHandCursor);
@@ -259,34 +260,38 @@
         arrow           = 0;
         line            = 0;
         hbox            = 0;
+        checkBox        = 0;
         expandByDefault = true;
     }
 
     bool              expandByDefault;
 
-    QLabel           *pixmapLabel;
-    QWidget          *containerWidget;
-    QGridLayout      *grid;
+    QCheckBox*        checkBox;
+    QLabel*           pixmapLabel;
+    QWidget*          containerWidget;
+    QGridLayout*      grid;
 
-    KSeparator       *line;
-    QWidget          *hbox;
+    KSeparator*       line;
+    QWidget*          hbox;
 
-    RArrowClickLabel *arrow;
-    RClickLabel      *clickLabel;
+    RArrowClickLabel* arrow;
+    RClickLabel*      clickLabel;
 };
 
-RLabelExpander::RLabelExpander(QWidget *parent)
+RLabelExpander::RLabelExpander(QWidget* parent)
               : QWidget(parent), d(new RLabelExpanderPriv)
 {
     d->grid        = new QGridLayout(this);
     d->line        = new KSeparator(Qt::Horizontal, this);
     d->hbox        = new QWidget(this);
     d->arrow       = new RArrowClickLabel(d->hbox);
+    d->checkBox    = new QCheckBox(d->hbox);
     d->pixmapLabel = new QLabel(d->hbox);
     d->clickLabel  = new RClickLabel(d->hbox);
 
-    QHBoxLayout *hlay = new QHBoxLayout(d->hbox);
+    QHBoxLayout* hlay = new QHBoxLayout(d->hbox);
     hlay->addWidget(d->arrow);
+    hlay->addWidget(d->checkBox);
     hlay->addWidget(d->pixmapLabel);
     hlay->addWidget(d->clickLabel, 10);
     hlay->setMargin(0);
@@ -296,6 +301,7 @@
     d->pixmapLabel->setCursor(Qt::PointingHandCursor);
 
     d->hbox->setCursor(Qt::PointingHandCursor);
+    setCheckBoxVisible(false);
 
     d->grid->addWidget(d->line, 0, 0, 1, 3);
     d->grid->addWidget(d->hbox, 1, 0, 1, 3);
@@ -308,6 +314,9 @@
 
     connect(d->clickLabel, SIGNAL(activated()),
             this, SLOT(slotToggleContainer()));
+
+    connect(d->checkBox, SIGNAL(toggled(bool)),
+            this, SIGNAL(signalToggled(bool)));
 }
 
 RLabelExpander::~RLabelExpander()
@@ -315,6 +324,26 @@
     delete d;
 }
 
+void RLabelExpander::setCheckBoxVisible(bool b)
+{
+    d->checkBox->setVisible(b);
+}
+
+bool RLabelExpander::checkBoxIsVisible() const
+{
+    return d->checkBox->isVisible();
+}
+
+void RLabelExpander::setChecked(bool b)
+{
+    d->checkBox->setChecked(b);
+}
+
+bool RLabelExpander::isChecked() const
+{
+    return d->checkBox->isChecked();
+}
+
 void RLabelExpander::setLineVisible(bool b)
 {
     d->line->setVisible(b);
@@ -395,7 +424,7 @@
         setExpanded(!d->containerWidget->isVisible());
 }
 
-bool RLabelExpander::eventFilter(QObject *obj, QEvent *ev)
+bool RLabelExpander::eventFilter(QObject* obj, QEvent* ev)
 {
     if ( obj == d->pixmapLabel)
     {
@@ -429,10 +458,10 @@
         vbox   = 0;
     }
 
-    void createItem(int index, QWidget *w, const QPixmap& pix, const QString& txt,
+    void createItem(int index, QWidget* w, const QPixmap& pix, const QString& txt,
                     const QString& objName, bool expandBydefault)
     {
-        RLabelExpander *exp = new RLabelExpander(parent->viewport());
+        RLabelExpander* exp = new RLabelExpander(parent->viewport());
         exp->setText(txt);
         exp->setIcon(pix);
         exp->setWidget(w);
@@ -453,21 +482,24 @@
 
         parent->connect(exp, SIGNAL(signalExpanded(bool)),
                         parent, SLOT(slotItemExpanded(bool)));
+
+        parent->connect(exp, SIGNAL(signalToggled(bool)),
+                        parent, SLOT(slotItemToggled(bool)));
     }
 
-    QList<RLabelExpander*>  wList;
+    QList<RLabelExpander*> wList;
 
-    QVBoxLayout            *vbox;
+    QVBoxLayout*           vbox;
 
-    RExpanderBox           *parent;
+    RExpanderBox*          parent;
 };
 
-RExpanderBox::RExpanderBox(QWidget *parent)
+RExpanderBox::RExpanderBox(QWidget* parent)
             : QScrollArea(parent), d(new RExpanderBoxPriv(this))
 {
     setFrameStyle(QFrame::NoFrame);
     setWidgetResizable(true);
-    QWidget *main = new QWidget(viewport());
+    QWidget* main = new QWidget(viewport());
     d->vbox       = new QVBoxLayout(main);
     d->vbox->setMargin(0);
     d->vbox->setSpacing(KDialog::spacingHint());
@@ -485,13 +517,37 @@
     delete d;
 }
 
-void RExpanderBox::addItem(QWidget *w, const QPixmap& pix, const QString& txt,
+void RExpanderBox::setCheckBoxVisible(int index, bool b)
+{
+    if (index > d->wList.count() || index < 0) return;
+    d->wList[index]->setCheckBoxVisible(b);
+}
+
+bool RExpanderBox::checkBoxIsVisible(int index) const
+{
+    if (index > d->wList.count() || index < 0) return false;
+    return d->wList[index]->checkBoxIsVisible();
+}
+
+void RExpanderBox::setChecked(int index, bool b)
+{
+    if (index > d->wList.count() || index < 0) return;
+    d->wList[index]->setChecked(b);
+}
+
+bool RExpanderBox::isChecked(int index) const
+{
+    if (index > d->wList.count() || index < 0) return false;
+    return d->wList[index]->isChecked();
+}
+
+void RExpanderBox::addItem(QWidget* w, const QPixmap& pix, const QString& txt,
                            const QString& objName, bool expandBydefault)
 {
     d->createItem(-1, w, pix, txt, objName, expandBydefault);
 }
 
-void RExpanderBox::addItem(QWidget *w, const QString& txt,
+void RExpanderBox::addItem(QWidget* w, const QString& txt,
                            const QString& objName, bool expandBydefault)
 {
     addItem(w, QPixmap(), txt, objName, expandBydefault);
@@ -502,7 +558,7 @@
     d->vbox->addStretch(10);
 }
 
-void RExpanderBox::insertItem(int index, QWidget *w, const QPixmap& pix, const QString& txt,
+void RExpanderBox::insertItem(int index, QWidget* w, const QPixmap& pix, const QString& txt,
                               const QString& objName, bool expandBydefault)
 {
     d->createItem(index, w, pix, txt, objName, expandBydefault);
@@ -518,7 +574,17 @@
     }
 }
 
-void RExpanderBox::insertItem(int index, QWidget *w, const QString& txt,
+void RExpanderBox::slotItemToggled(bool b)
+{
+    RLabelExpander* exp = dynamic_cast<RLabelExpander*>(sender());
+    if (exp)
+    {
+        int index = indexOf(exp);
+        emit signalItemToggled(index, b);
+    }
+}
+
+void RExpanderBox::insertItem(int index, QWidget* w, const QString& txt,
                               const QString& objName, bool expandBydefault)
 {
     insertItem(index, w, QPixmap(), txt, objName, expandBydefault);
@@ -596,7 +662,7 @@
     return d->wList[index];
 }
 
-int RExpanderBox::indexOf(RLabelExpander *widget) const
+int RExpanderBox::indexOf(RLabelExpander* widget) const
 {
     for (int i = 0 ; i < count(); ++i)
     {
Index: libs/libkdcraw/libkdcraw/rexpanderbox.h
===================================================================
--- libs/libkdcraw/libkdcraw/rexpanderbox.h	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/rexpanderbox.h	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2008-03-14
  * Description : A widget to host settings as expander box
  *
- * Copyright (C) 2008-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
- * Copyright (C) 2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2008-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2009-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -50,8 +50,8 @@
 
 public:
 
-    RClickLabel(QWidget *parent = 0);
-    RClickLabel(const QString& text, QWidget *parent = 0);
+    RClickLabel(QWidget* parent = 0);
+    RClickLabel(const QString& text, QWidget* parent = 0);
     ~RClickLabel(){};
 
 Q_SIGNALS:
@@ -75,8 +75,8 @@
 
 public:
 
-    RSqueezedClickLabel(QWidget *parent = 0);
-    RSqueezedClickLabel(const QString& text, QWidget *parent = 0);
+    RSqueezedClickLabel(QWidget* parent = 0);
+    RSqueezedClickLabel(const QString& text, QWidget* parent = 0);
     ~RSqueezedClickLabel(){};
 
 Q_SIGNALS:
@@ -98,7 +98,7 @@
 
 public:
 
-    RArrowClickLabel(QWidget *parent = 0);
+    RArrowClickLabel(QWidget* parent = 0);
     ~RArrowClickLabel(){};
 
     void setArrowType(Qt::ArrowType arrowType);
@@ -132,9 +132,15 @@
 
 public:
 
-    RLabelExpander(QWidget *parent = 0);
+    RLabelExpander(QWidget* parent = 0);
     ~RLabelExpander();
 
+    void setCheckBoxVisible(bool b);
+    bool checkBoxIsVisible() const;
+
+    void setChecked(bool b);
+    bool isChecked() const;
+
     void setLineVisible(bool b);
     bool lineIsVisible() const;
 
@@ -155,7 +161,8 @@
 
 Q_SIGNALS:
 
-    void signalExpanded(bool b);
+    void signalExpanded(bool);
+    void signalToggled(bool);
 
 private Q_SLOTS:
 
@@ -163,7 +170,7 @@
 
 private:
 
-    bool eventFilter(QObject *obj, QEvent *ev);
+    bool eventFilter(QObject* obj, QEvent* ev);
 
 private:
 
@@ -180,7 +187,7 @@
 
 public:
 
-    RExpanderBox(QWidget *parent = 0);
+    RExpanderBox(QWidget* parent = 0);
     ~RExpanderBox();
 
     /** Add RLabelExpander item at end of box layout with these settings :
@@ -190,9 +197,9 @@
         'objName'         : item object name used to read/save expanded settings to rc file.
         'expandBydefault' : item state by default (expanded or not).
      */
-    void addItem(QWidget *w, const QPixmap& pix, const QString& txt,
+    void addItem(QWidget* w, const QPixmap& pix, const QString& txt,
                  const QString& objName, bool expandBydefault);
-    void addItem(QWidget *w, const QString& txt,
+    void addItem(QWidget* w, const QString& txt,
                  const QString& objName, bool expandBydefault);
 
     /** Insert RLabelExpander item at box layout index with these settings :
@@ -202,13 +209,19 @@
         'objName'         : item object name used to read/save expanded settings to rc file.
         'expandBydefault' : item state by default (expanded or not).
      */
-    void insertItem(int index, QWidget *w, const QPixmap& pix, const QString& txt,
+    void insertItem(int index, QWidget* w, const QPixmap& pix, const QString& txt,
                     const QString& objName, bool expandBydefault);
-    void insertItem(int index, QWidget *w, const QString& txt,
+    void insertItem(int index, QWidget* w, const QString& txt,
                     const QString& objName, bool expandBydefault);
 
     void removeItem(int index);
 
+    void setCheckBoxVisible(int index, bool b);
+    bool checkBoxIsVisible(int index) const;
+
+    void setChecked(int index, bool b);
+    bool isChecked(int index) const;
+
     void setItemText(int index, const QString& txt);
     QString itemText (int index) const;
 
@@ -230,7 +243,7 @@
     int  count() const;
 
     RLabelExpander* widget(int index) const;
-    int indexOf(RLabelExpander *widget) const;
+    int indexOf(RLabelExpander* widget) const;
 
     void readSettings();
     void writeSettings();
@@ -238,10 +251,12 @@
 Q_SIGNALS:
 
     void signalItemExpanded(int index, bool b);
+    void signalItemToggled(int index, bool b);
 
 private Q_SLOTS:
 
     void slotItemExpanded(bool b);
+    void slotItemToggled(bool b);
 
 private:
 
Index: libs/libkdcraw/libkdcraw/rawdecodingsettings.cpp
===================================================================
--- libs/libkdcraw/libkdcraw/rawdecodingsettings.cpp	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/rawdecodingsettings.cpp	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2006-12-09
  * Description : Raw decoding settings
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -22,7 +22,31 @@
  *
  * ============================================================ */
 
-// Local includes
+#define OPTIONFIXCOLORSHIGHLIGHTSENTRY      "FixColorsHighlights"
+#define OPTIONDECODESIXTEENBITENTRY         "SixteenBitsImage"
+#define OPTIONWHITEBALANCEENTRY             "White Balance"
+#define OPTIONCUSTOMWHITEBALANCEENTRY       "Custom White Balance"
+#define OPTIONCUSTOMWBGREENENTRY            "Custom White Balance Green"
+#define OPTIONFOURCOLORRGBENTRY             "Four Color RGB"
+#define OPTIONUNCLIPCOLORSENTRY             "Unclip Color"
+#define OPTIONDONTSTRETCHPIXELSENTRY        "Dont Stretch Pixels"
+#define OPTIONNOISEREDUCTIONENTRY           "Use Noise Reduction"
+#define OPTIONMEDIANFILTERPASSESENTRY       "Median Filter Passes"
+#define OPTIONNRTHRESHOLDENTRY              "NR Threshold"
+#define OPTIONUSECACORRECTIONENTRY          "EnableCACorrection"
+#define OPTIONCAREDMULTIPLIERENTRY          "caRedMultiplier"
+#define OPTIONCABLUEMULTIPLIERENTRY         "caBlueMultiplier"
+#define OPTIONAUTOBRIGHTNESSENTRY           "AutoBrightness"
+#define OPTIONDECODINGQUALITYENTRY          "Decoding Quality"
+#define OPTIONINPUTCOLORSPACEENTRY          "Input Color Space"
+#define OPTIONOUTPUTCOLORSPACEENTRY         "Output Color Space"
+#define OPTIONINPUTCOLORPROFILEENTRY        "Input Color Profile"
+#define OPTIONOUTPUTCOLORPROFILEENTRY       "Output Color Profile"
+#define OPTIONBRIGHTNESSMULTIPLIERENTRY     "Brightness Multiplier"
+#define OPTIONUSEBLACKPOINTENTRY            "Use Black Point"
+#define OPTIONBLACKPOINTENTRY               "Black Point"
+#define OPTIONUSEWHITEPOINTENTRY            "Use White Point"
+#define OPTIONWHITEPOINTENTRY               "White Point"
 
 #include "rawdecodingsettings.h"
 
@@ -31,6 +55,7 @@
 
 RawDecodingSettings::RawDecodingSettings()
 {
+    fixColorsHighlights        = false;
     autoBrightness             = true;
     sixteenBitsImage           = false;
     brightness                 = 1.0;
@@ -68,9 +93,47 @@
     whiteBalanceArea           = QRect();
 }
 
-bool RawDecodingSettings::operator==(const RawDecodingSettings &o) const
+RawDecodingSettings::~RawDecodingSettings()
 {
-    return autoBrightness          == o.autoBrightness
+}
+
+RawDecodingSettings& RawDecodingSettings::operator=(const RawDecodingSettings& o)
+{
+    fixColorsHighlights     = o.fixColorsHighlights;
+    autoBrightness          = o.autoBrightness;
+    sixteenBitsImage        = o.sixteenBitsImage;
+    brightness              = o.brightness;
+    RAWQuality              = o.RAWQuality;
+    inputColorSpace         = o.inputColorSpace;
+    outputColorSpace        = o.outputColorSpace;
+    RGBInterpolate4Colors   = o.RGBInterpolate4Colors;
+    DontStretchPixels       = o.DontStretchPixels;
+    unclipColors            = o.unclipColors;
+    whiteBalance            = o.whiteBalance;
+    customWhiteBalance      = o.customWhiteBalance;
+    customWhiteBalanceGreen = o.customWhiteBalanceGreen;
+    halfSizeColorImage      = o.halfSizeColorImage;
+    enableBlackPoint        = o.enableBlackPoint;
+    blackPoint              = o.blackPoint;
+    enableWhitePoint        = o.enableWhitePoint;
+    whitePoint              = o.whitePoint;
+    enableNoiseReduction    = o.enableNoiseReduction;
+    NRThreshold             = o.NRThreshold;
+    enableCACorrection      = o.enableCACorrection;
+    caMultiplier[0]         = o.caMultiplier[0];
+    caMultiplier[1]         = o.caMultiplier[1];
+    medianFilterPasses      = o.medianFilterPasses;
+    inputProfile            = o.inputProfile;
+    outputProfile           = o.outputProfile;
+    deadPixelMap            = o.deadPixelMap;
+    whiteBalanceArea        = o.whiteBalanceArea;
+    return *this;
+}
+
+bool RawDecodingSettings::operator==(const RawDecodingSettings& o) const
+{
+    return fixColorsHighlights     == o.fixColorsHighlights
+        && autoBrightness          == o.autoBrightness
         && sixteenBitsImage        == o.sixteenBitsImage
         && brightness              == o.brightness
         && RAWQuality              == o.RAWQuality
@@ -100,12 +163,9 @@
         ;
 }
 
-RawDecodingSettings::~RawDecodingSettings()
-{
-}
-
 void RawDecodingSettings::optimizeTimeLoading()
 {
+    fixColorsHighlights     = false;
     autoBrightness          = true;
     sixteenBitsImage        = true;
     brightness              = 1.0;
@@ -142,6 +202,60 @@
     whiteBalanceArea        = QRect();
 }
 
+void RawDecodingSettings::readSettings(KConfigGroup& group)
+{
+    RawDecodingSettings defaultPrm;
+
+    fixColorsHighlights     = group.readEntry(OPTIONFIXCOLORSHIGHLIGHTSENTRY, defaultPrm.fixColorsHighlights);
+    sixteenBitsImage        = group.readEntry(OPTIONDECODESIXTEENBITENTRY, defaultPrm.sixteenBitsImage);
+    whiteBalance            = (WhiteBalance)group.readEntry(OPTIONWHITEBALANCEENTRY, (int)defaultPrm.whiteBalance);
+    customWhiteBalance      = group.readEntry(OPTIONCUSTOMWHITEBALANCEENTRY, defaultPrm.customWhiteBalance);
+    customWhiteBalanceGreen = group.readEntry(OPTIONCUSTOMWBGREENENTRY, defaultPrm.customWhiteBalanceGreen);
+    RGBInterpolate4Colors   = group.readEntry(OPTIONFOURCOLORRGBENTRY, defaultPrm.RGBInterpolate4Colors);
+    unclipColors            = group.readEntry(OPTIONUNCLIPCOLORSENTRY, defaultPrm.unclipColors);
+    DontStretchPixels       = group.readEntry(OPTIONDONTSTRETCHPIXELSENTRY, defaultPrm.DontStretchPixels);
+    enableNoiseReduction    = group.readEntry(OPTIONNOISEREDUCTIONENTRY, defaultPrm.enableNoiseReduction);
+    brightness              = group.readEntry(OPTIONBRIGHTNESSMULTIPLIERENTRY, defaultPrm.brightness);
+    enableBlackPoint        = group.readEntry(OPTIONUSEBLACKPOINTENTRY, defaultPrm.enableBlackPoint);
+    blackPoint              = group.readEntry(OPTIONBLACKPOINTENTRY, defaultPrm.blackPoint);
+    enableWhitePoint        = group.readEntry(OPTIONUSEWHITEPOINTENTRY, defaultPrm.enableWhitePoint);
+    whitePoint              = group.readEntry(OPTIONWHITEPOINTENTRY, defaultPrm.whitePoint);
+    medianFilterPasses      = group.readEntry(OPTIONMEDIANFILTERPASSESENTRY, defaultPrm.medianFilterPasses);
+    NRThreshold             = group.readEntry(OPTIONNRTHRESHOLDENTRY, defaultPrm.NRThreshold);
+    enableCACorrection      = group.readEntry(OPTIONUSECACORRECTIONENTRY, defaultPrm.enableCACorrection);
+    caMultiplier[0]         = group.readEntry(OPTIONCAREDMULTIPLIERENTRY, defaultPrm.caMultiplier[0]);
+    caMultiplier[1]         = group.readEntry(OPTIONCABLUEMULTIPLIERENTRY, defaultPrm.caMultiplier[1]);
+    RAWQuality              = (DecodingQuality)group.readEntry(OPTIONDECODINGQUALITYENTRY, (int)defaultPrm.RAWQuality);
+    outputColorSpace        = (OutputColorSpace)group.readEntry(OPTIONOUTPUTCOLORSPACEENTRY, (int)defaultPrm.outputColorSpace);
+    autoBrightness          = group.readEntry(OPTIONAUTOBRIGHTNESSENTRY, defaultPrm.autoBrightness);
+}
+
+void RawDecodingSettings::writeSettings(KConfigGroup& group)
+{
+    group.writeEntry(OPTIONFIXCOLORSHIGHLIGHTSENTRY,  fixColorsHighlights);
+    group.writeEntry(OPTIONDECODESIXTEENBITENTRY,     sixteenBitsImage);
+    group.writeEntry(OPTIONWHITEBALANCEENTRY,         (int)whiteBalance);
+    group.writeEntry(OPTIONCUSTOMWHITEBALANCEENTRY,   customWhiteBalance);
+    group.writeEntry(OPTIONCUSTOMWBGREENENTRY,        customWhiteBalanceGreen);
+    group.writeEntry(OPTIONFOURCOLORRGBENTRY,         RGBInterpolate4Colors);
+    group.writeEntry(OPTIONUNCLIPCOLORSENTRY,         unclipColors);
+    group.writeEntry(OPTIONDONTSTRETCHPIXELSENTRY,    DontStretchPixels);
+    group.writeEntry(OPTIONNOISEREDUCTIONENTRY,       enableNoiseReduction);
+    group.writeEntry(OPTIONBRIGHTNESSMULTIPLIERENTRY, brightness);
+    group.writeEntry(OPTIONUSEBLACKPOINTENTRY,        enableBlackPoint);
+    group.writeEntry(OPTIONBLACKPOINTENTRY,           blackPoint);
+    group.writeEntry(OPTIONUSEWHITEPOINTENTRY,        enableWhitePoint);
+    group.writeEntry(OPTIONWHITEPOINTENTRY,           whitePoint);
+    group.writeEntry(OPTIONMEDIANFILTERPASSESENTRY,   medianFilterPasses);
+    group.writeEntry(OPTIONNRTHRESHOLDENTRY,          NRThreshold);
+    group.writeEntry(OPTIONUSECACORRECTIONENTRY,      enableCACorrection);
+    group.writeEntry(OPTIONCAREDMULTIPLIERENTRY,      caMultiplier[0]);
+    group.writeEntry(OPTIONCABLUEMULTIPLIERENTRY,     caMultiplier[1]);
+    group.writeEntry(OPTIONDECODINGQUALITYENTRY,      (int)RAWQuality);
+    group.writeEntry(OPTIONOUTPUTCOLORSPACEENTRY,     (int)outputColorSpace);
+    group.writeEntry(OPTIONAUTOBRIGHTNESSENTRY,       autoBrightness);
+}
+
 QDebug operator<<(QDebug dbg, const RawDecodingSettings& s)
 {
     dbg.nospace() << "RawDecodingSettings::autoBrightness: "          << s.autoBrightness   << ", ";
Index: libs/libkdcraw/libkdcraw/kdcraw.cpp
===================================================================
--- libs/libkdcraw/libkdcraw/kdcraw.cpp	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/kdcraw.cpp	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2006-12-09
  * Description : a tread-safe libraw C++ program interface
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com> 
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com> 
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -191,7 +191,7 @@
         return false;
     }
 
-    libraw_processed_image_t *halfImg = raw.dcraw_make_mem_image(&ret);
+    libraw_processed_image_t* halfImg = raw.dcraw_make_mem_image(&ret);
     if(!halfImg)
     {
         kDebug(51002) << "LibRaw: failed to run dcraw_make_mem_image: " << libraw_strerror(ret) << endl;
@@ -249,7 +249,8 @@
 
 // ----------------------------------------------------------------------------------
 
-bool KDcraw::extractRAWData(const QString& filePath, QByteArray& rawData, DcrawInfoContainer& identify)
+bool KDcraw::extractRAWData(const QString& filePath, QByteArray& rawData, DcrawInfoContainer& identify,
+                            bool addMaskedBorders)
 {
     QFileInfo fileInfo(filePath);
     QString   rawFilesExt(rawFiles());
@@ -294,6 +295,18 @@
         return false;
     }
 
+    if (addMaskedBorders)
+    {
+
+        ret = raw.add_masked_borders_to_bitmap();
+        if (ret != LIBRAW_SUCCESS)
+        {
+            kDebug(51002) << "LibRaw: failed to add masked borders: " << libraw_strerror(ret) << endl;
+            raw.recycle();
+            return false;
+        }
+    }
+
     if (m_cancel)
     {
         raw.recycle();
@@ -319,7 +332,7 @@
     {
         for (uint col=0 ; col < raw.imgdata.sizes.iwidth ; col++)
         {
-            *output = raw.imgdata.image[raw.imgdata.sizes.iwidth*row + col] [raw.FC(row, col)];
+            *output = raw.imgdata.image[raw.imgdata.sizes.iwidth*row + col] [raw.COLOR(row, col)];
             *output++;
         }
     }
@@ -629,6 +642,7 @@
 
     args.append(filePath);
     kDebug(51002) << "LibRaw: dcraw emulation: " << args << endl;
+    kDebug(51002) << "LibRaw highlights adjustements : " << m_rawDecodingSettings.fixColorsHighlights << endl;
 
     int ret = raw.open_file(QFile::encodeName(filePath));
     if (ret != LIBRAW_SUCCESS)
@@ -660,6 +674,19 @@
     }
     d->setProgress(0.25);
 
+    if (m_rawDecodingSettings.fixColorsHighlights)
+    {
+        kDebug(51002) << "Applying LibRaw highlights adjustements" << endl;
+        // 1.0 is fallback to default value
+        raw.imgdata.params.adjust_maximum_thr = 1.0; 
+    }
+    else
+    {
+        kDebug(51002) << "Disabling LibRaw highlights adjustements" << endl;
+        // 0.0 disables this feature
+        raw.imgdata.params.adjust_maximum_thr = 0.0; 
+    }
+
     ret = raw.dcraw_process();
     if (ret != LIBRAW_SUCCESS)
     {
@@ -675,7 +702,7 @@
     }
     d->setProgress(0.3);
 
-    libraw_processed_image_t *img = raw.dcraw_make_mem_image(&ret);
+    libraw_processed_image_t* img = raw.dcraw_make_mem_image(&ret);
     if(!img)
     {
         kDebug(51002) << "LibRaw: failed to run dcraw_make_mem_image: " << libraw_strerror(ret) << endl;
@@ -709,7 +736,7 @@
     return true;
 }
 
-const char *KDcraw::rawFiles()
+const char* KDcraw::rawFiles()
 {
     return raw_file_extentions;
 }
Index: libs/libkdcraw/libkdcraw/rawdecodingsettings.h
===================================================================
--- libs/libkdcraw/libkdcraw/rawdecodingsettings.h	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/rawdecodingsettings.h	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2006-12-09
  * Description : Raw decoding settings
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -31,6 +31,10 @@
 #include <QtCore/QString>
 #include <QtCore/QDebug>
 
+// KDE includes
+
+#include <kconfiggroup.h>
+
 // Local includes
 
 #include "libkdcraw_export.h"
@@ -118,6 +122,9 @@
     /** Standard constructor with default settings */
     RawDecodingSettings();
 
+    /** Equivalent to the copy constructor */
+    RawDecodingSettings& operator=(const RawDecodingSettings& prm);  
+
     /** Compare for equality */
     bool operator==(const RawDecodingSettings &o) const;
 
@@ -127,8 +134,17 @@
     /** Method to use a settings to optimize time loading, for exemple to compute image histogram */
     void optimizeTimeLoading();
 
+    /** Methods to read/write settings from/to a config file */
+    void readSettings(KConfigGroup& group);
+    void writeSettings(KConfigGroup& group);
+
 public:
 
+    /** If true, images with overblown channels are processed much more accurate, 
+        without 'pink clouds' (and blue highlights under tungsteen lamps).
+     */
+    bool fixColorsHighlights;
+
     /** If false, use a fixed white level, ignoring the image histogram.
     */
     bool autoBrightness;
@@ -203,7 +219,7 @@
 
     /** Brightness of output image.
     */
-    float brightness;
+    double brightness;
 
     /** Set on the black point setting to decode RAW image.
     */
Index: libs/libkdcraw/libkdcraw/dcrawinfocontainer.cpp
===================================================================
--- libs/libkdcraw/libkdcraw/dcrawinfocontainer.cpp	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/dcrawinfocontainer.cpp	(copie de travail)
@@ -49,6 +49,8 @@
     whitePoint        = 0;
     topMargin         = 0;
     leftMargin        = 0;
+    rightMargin       = 0;
+    bottomMargin      = 0;
     orientation       = ORIENTATION_NONE;
 
     for (int x=0 ; x<3 ; x++)
@@ -71,6 +73,7 @@
     if (make.isEmpty()                  &&
         model.isEmpty()                 &&
         filterPattern.isEmpty()         &&
+        colorKeys.isEmpty()             &&
         DNGVersion.isEmpty()            &&
         exposureTime     == -1.0        &&
         aperture         == -1.0        &&
@@ -83,6 +86,8 @@
         whitePoint       == 0           &&
         topMargin        == 0           &&
         leftMargin       == 0           &&
+        rightMargin      == 0           &&
+        bottomMargin     == 0           &&
         !dateTime.isValid()             &&
         !imageSize.isValid()            &&
         !fullSize.isValid()             &&
@@ -153,6 +158,8 @@
     dbg.nospace() << "DcrawInfoContainer::blackPoint: "       << c.blackPoint << ", ";
     dbg.nospace() << "DcrawInfoContainer::topMargin: "        << c.topMargin << ", ";
     dbg.nospace() << "DcrawInfoContainer::leftMargin: "       << c.leftMargin << ", ";
+    dbg.nospace() << "DcrawInfoContainer::rightMargin: "      << c.rightMargin << ", ";
+    dbg.nospace() << "DcrawInfoContainer::bottomMargin: "     << c.bottomMargin << ", ";
     dbg.nospace() << "DcrawInfoContainer::orientation: "      << c.orientation;
     return dbg.space();
 }
Index: libs/libkdcraw/libkdcraw/kdcraw.h
===================================================================
--- libs/libkdcraw/libkdcraw/kdcraw.h	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/kdcraw.h	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2006-12-09
  * Description : a tread-safe libraw C++ program interface
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -127,7 +127,8 @@
             - All info about Raw image into 'identify' container. 
             - 'false' is returned if loadding failed, else 'true'.  
      */
-    bool extractRAWData(const QString& filePath, QByteArray& rawData, DcrawInfoContainer& identify);
+    bool extractRAWData(const QString& filePath, QByteArray& rawData, DcrawInfoContainer& identify,
+                        bool addMaskedBorders = false);
 
     /** Extract a small size of decode RAW data from 'filePath' picture file using 
         'rawDecodingSettings' settings. This is a cancelable method which require 
Index: libs/libkdcraw/libkdcraw/dcrawinfocontainer.h
===================================================================
--- libs/libkdcraw/libkdcraw/dcrawinfocontainer.h	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/dcrawinfocontainer.h	(copie de travail)
@@ -88,6 +88,12 @@
     /** Left margin of raw image. */
     unsigned int     leftMargin;
 
+    /** Right margin of raw image. */
+    unsigned int     rightMargin;
+
+    /** Bottom margin of raw image. */
+    unsigned int     bottomMargin;
+
     /** The raw image orientation */
     ImageOrientation orientation;
 
@@ -111,8 +117,11 @@
     /** Camera Color Matrix */
     float            cameraColorMatrix1[3][4];
     float            cameraColorMatrix2[3][4];
-    float            cameraXYZMatrix[3][4];
+    float            cameraXYZMatrix[4][3];
 
+    /** The used Color Keys */
+    QString          colorKeys;
+
     /** The camera maker. */
     QString          make;
     /** The camera model. */
Index: libs/libkdcraw/libkdcraw/dcrawsettingswidget.cpp
===================================================================
--- libs/libkdcraw/libkdcraw/dcrawsettingswidget.cpp	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/dcrawsettingswidget.cpp	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2006-09-13
  * Description : LibRaw settings widgets
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -24,7 +24,7 @@
 
 #include "dcrawsettingswidget.moc"
 
-// Qt includes.
+// Qt includes
 
 #include <QCheckBox>
 #include <QLabel>
@@ -32,7 +32,7 @@
 #include <QWhatsThis>
 #include <QToolTip>
 
-// KDE includes.
+// KDE includes
 
 #include <kapplication.h>
 #include <kdialog.h>
@@ -40,7 +40,7 @@
 #include <kurllabel.h>
 #include <ktoolinvocation.h>
 
-// Local includes.
+// Local includes
 
 #include "kdcraw.h"
 #include "rnuminput.h"
@@ -98,59 +98,61 @@
         outIccUrlEdit                  = 0;
         inputColorSpaceLabel           = 0;
         inputColorSpaceComboBox        = 0;
+        fixColorsHighlights            = 0;
     }
 
-    QWidget         *demosaicingSettings;
-    QWidget         *whiteBalanceSettings;
-    QWidget         *correctionsSettings;
-    QWidget         *colormanSettings;
+    QWidget*         demosaicingSettings;
+    QWidget*         whiteBalanceSettings;
+    QWidget*         correctionsSettings;
+    QWidget*         colormanSettings;
 
-    QLabel          *whiteBalanceLabel;
-    QLabel          *customWhiteBalanceLabel;
-    QLabel          *customWhiteBalanceGreenLabel;
-    QLabel          *brightnessLabel;
-    QLabel          *RAWQualityLabel;
-    QLabel          *NRThresholdLabel;
-    QLabel          *caRedMultLabel;
-    QLabel          *caBlueMultLabel;
-    QLabel          *unclipColorLabel;
-    QLabel          *reconstructLabel;
-    QLabel          *inputColorSpaceLabel;
-    QLabel          *outputColorSpaceLabel;
-    QLabel          *medianFilterPassesLabel;
+    QLabel*          whiteBalanceLabel;
+    QLabel*          customWhiteBalanceLabel;
+    QLabel*          customWhiteBalanceGreenLabel;
+    QLabel*          brightnessLabel;
+    QLabel*          RAWQualityLabel;
+    QLabel*          NRThresholdLabel;
+    QLabel*          caRedMultLabel;
+    QLabel*          caBlueMultLabel;
+    QLabel*          unclipColorLabel;
+    QLabel*          reconstructLabel;
+    QLabel*          inputColorSpaceLabel;
+    QLabel*          outputColorSpaceLabel;
+    QLabel*          medianFilterPassesLabel;
 
-    QCheckBox       *blackPointCheckBox;
-    QCheckBox       *whitePointCheckBox;
-    QCheckBox       *sixteenBitsImage;
-    QCheckBox       *autoBrightnessBox;
-    QCheckBox       *fourColorCheckBox;
-    QCheckBox       *dontStretchPixelsCheckBox;
-    QCheckBox       *enableNoiseReduction;
-    QCheckBox       *enableCACorrection;
+    QCheckBox*       blackPointCheckBox;
+    QCheckBox*       whitePointCheckBox;
+    QCheckBox*       sixteenBitsImage;
+    QCheckBox*       autoBrightnessBox;
+    QCheckBox*       fourColorCheckBox;
+    QCheckBox*       dontStretchPixelsCheckBox;
+    QCheckBox*       enableNoiseReduction;
+    QCheckBox*       enableCACorrection;
+    QCheckBox*       fixColorsHighlights;
 
-    KUrlRequester   *inIccUrlEdit;
-    KUrlRequester   *outIccUrlEdit;
+    KUrlRequester*   inIccUrlEdit;
+    KUrlRequester*   outIccUrlEdit;
 
-    RComboBox       *whiteBalanceComboBox;
-    RComboBox       *RAWQualityComboBox;
-    RComboBox       *unclipColorComboBox;
-    RComboBox       *inputColorSpaceComboBox;
-    RComboBox       *outputColorSpaceComboBox;
+    RComboBox*       whiteBalanceComboBox;
+    RComboBox*       RAWQualityComboBox;
+    RComboBox*       unclipColorComboBox;
+    RComboBox*       inputColorSpaceComboBox;
+    RComboBox*       outputColorSpaceComboBox;
 
-    RIntNumInput    *customWhiteBalanceSpinBox;
-    RIntNumInput    *reconstructSpinBox;
-    RIntNumInput    *blackPointSpinBox;
-    RIntNumInput    *whitePointSpinBox;
-    RIntNumInput    *NRThresholdSpinBox;
-    RIntNumInput    *medianFilterPassesSpinBox;
+    RIntNumInput*    customWhiteBalanceSpinBox;
+    RIntNumInput*    reconstructSpinBox;
+    RIntNumInput*    blackPointSpinBox;
+    RIntNumInput*    whitePointSpinBox;
+    RIntNumInput*    NRThresholdSpinBox;
+    RIntNumInput*    medianFilterPassesSpinBox;
 
-    RDoubleNumInput *customWhiteBalanceGreenSpinBox;
-    RDoubleNumInput *caRedMultSpinBox;
-    RDoubleNumInput *caBlueMultSpinBox;
-    RDoubleNumInput *brightnessSpinBox;
+    RDoubleNumInput* customWhiteBalanceGreenSpinBox;
+    RDoubleNumInput* caRedMultSpinBox;
+    RDoubleNumInput* caBlueMultSpinBox;
+    RDoubleNumInput* brightnessSpinBox;
 };
 
-DcrawSettingsWidget::DcrawSettingsWidget(QWidget *parent, int advSettings)
+DcrawSettingsWidget::DcrawSettingsWidget(QWidget* parent, int advSettings)
                    : RExpanderBox(parent), d(new DcrawSettingsWidgetPriv)
 {
     setup(advSettings);
@@ -328,6 +330,11 @@
                                              "Specify the reconstruct highlight level. "
                                              "Low values favor whites and high values favor colors."));
 
+    d->fixColorsHighlights = new QCheckBox(i18n("Correct false colors in highlights"), d->whiteBalanceSettings);
+    d->fixColorsHighlights->setWhatsThis(i18n("<p>If enabled, images with overblown channels are processed much "
+                                              "more accurately, without 'pink clouds' (and blue highlights under "
+                                              "tungsten lamps)."));
+
     d->autoBrightnessBox = new QCheckBox(i18n("Auto Brightness"), d->whiteBalanceSettings);
     d->autoBrightnessBox->setWhatsThis(i18n("<p>If disable, use a fixed white level "
                                             "and ignore the image histogram to adjust brightness."));
@@ -389,13 +396,14 @@
     whiteBalanceLayout->addWidget(d->unclipColorComboBox,            3, 1, 1, 2);
     whiteBalanceLayout->addWidget(d->reconstructLabel,               4, 0, 1, 1);
     whiteBalanceLayout->addWidget(d->reconstructSpinBox,             4, 1, 1, 2);
-    whiteBalanceLayout->addWidget(d->autoBrightnessBox,              5, 0, 1, 2);
-    whiteBalanceLayout->addWidget(d->brightnessLabel,                6, 0, 1, 1);
-    whiteBalanceLayout->addWidget(d->brightnessSpinBox,              6, 1, 1, 2);
-    whiteBalanceLayout->addWidget(d->blackPointCheckBox,             7, 0, 1, 1);
-    whiteBalanceLayout->addWidget(d->blackPointSpinBox,              7, 1, 1, 2);
-    whiteBalanceLayout->addWidget(d->whitePointCheckBox,             8, 0, 1, 1);
-    whiteBalanceLayout->addWidget(d->whitePointSpinBox,              8, 1, 1, 2);
+    whiteBalanceLayout->addWidget(d->fixColorsHighlights,            5, 0, 1, 2);
+    whiteBalanceLayout->addWidget(d->autoBrightnessBox,              6, 0, 1, 2);
+    whiteBalanceLayout->addWidget(d->brightnessLabel,                7, 0, 1, 1);
+    whiteBalanceLayout->addWidget(d->brightnessSpinBox,              7, 1, 1, 2);
+    whiteBalanceLayout->addWidget(d->blackPointCheckBox,             8, 0, 1, 1);
+    whiteBalanceLayout->addWidget(d->blackPointSpinBox,              8, 1, 1, 2);
+    whiteBalanceLayout->addWidget(d->whitePointCheckBox,             9, 0, 1, 1);
+    whiteBalanceLayout->addWidget(d->whitePointSpinBox,              9, 1, 1, 2);
     whiteBalanceLayout->setSpacing(KDialog::spacingHint());
     whiteBalanceLayout->setMargin(KDialog::spacingHint());
 
@@ -587,6 +595,9 @@
     connect(d->sixteenBitsImage, SIGNAL(toggled(bool)),
             this, SIGNAL(signalSettingsChanged()));
 
+    connect(d->fixColorsHighlights, SIGNAL(toggled(bool)),
+            this, SIGNAL(signalSettingsChanged()));
+
     connect(d->autoBrightnessBox, SIGNAL(toggled(bool)),
             this, SIGNAL(signalSettingsChanged()));
 
@@ -665,28 +676,14 @@
 
 void DcrawSettingsWidget::setDefaultSettings()
 {
-    setWhiteBalance((RawDecodingSettings::WhiteBalance)d->whiteBalanceComboBox->defaultIndex());
-    setCustomWhiteBalance(d->customWhiteBalanceSpinBox->defaultValue());
-    setCustomWhiteBalanceGreen(d->customWhiteBalanceGreenSpinBox->defaultValue());
-    setFourColor(false);
-    setUnclipColor(d->unclipColorComboBox->defaultIndex());
-    setDontStretchPixels(false);
-    setNoiseReduction(false);
-    setUseCACorrection(false);
-    setcaRedMultiplier(d->caRedMultSpinBox->defaultValue());
-    setcaBlueMultiplier(d->caBlueMultSpinBox->defaultValue());
-    setBrightness(d->brightnessSpinBox->defaultValue());
-    setUseBlackPoint(false);
-    setUseWhitePoint(false);
-    setBlackPoint(d->blackPointSpinBox->defaultValue());
-    setWhitePoint(d->whitePointSpinBox->defaultValue());
-    setNRThreshold(d->NRThresholdSpinBox->defaultValue());
-    setQuality((RawDecodingSettings::DecodingQuality)d->RAWQualityComboBox->defaultIndex());
-    setInputColorSpace((RawDecodingSettings::InputColorSpace)d->inputColorSpaceComboBox->defaultIndex());
-    setOutputColorSpace((RawDecodingSettings::OutputColorSpace)d->outputColorSpaceComboBox->defaultIndex());
-    setMedianFilterPasses(d->medianFilterPassesSpinBox->defaultValue());
+    resetToDefault();
 }
 
+void DcrawSettingsWidget::resetToDefault()
+{
+    setSettings(RawDecodingSettings());
+}
+
 void DcrawSettingsWidget::slotsixteenBitsImageToggled(bool b)
 {
     setEnabledBrightnessSettings(!b);
@@ -749,8 +746,6 @@
     d->outIccUrlEdit->setEnabled(item == RawDecodingSettings::CUSTOMOUTPUTCS);
 }
 
-// ---------------------------------------------------------------
-
 void DcrawSettingsWidget::setEnabledBrightnessSettings(bool b)
 {
     d->brightnessLabel->setEnabled(b);
@@ -762,8 +757,189 @@
     return d->brightnessSpinBox->isEnabled();
 }
 
-// ---------------------------------------------------------------
+void DcrawSettingsWidget::setSettings(const RawDecodingSettings& settings)
+{
+    d->sixteenBitsImage->setChecked(settings.sixteenBitsImage);
 
+    switch(settings.whiteBalance)
+    {
+        case RawDecodingSettings::CAMERA:
+            d->whiteBalanceComboBox->setCurrentIndex(1);
+            break;
+        case RawDecodingSettings::AUTO:
+            d->whiteBalanceComboBox->setCurrentIndex(2);
+            break;
+        case RawDecodingSettings::CUSTOM:
+            d->whiteBalanceComboBox->setCurrentIndex(3);
+            break;
+        default:
+            d->whiteBalanceComboBox->setCurrentIndex(0);
+            break;
+    }
+    slotWhiteBalanceToggled(d->whiteBalanceComboBox->currentIndex());
+
+    d->medianFilterPassesSpinBox->setValue(settings.medianFilterPasses);
+    d->customWhiteBalanceSpinBox->setValue(settings.customWhiteBalance);
+    d->customWhiteBalanceGreenSpinBox->setValue(settings.customWhiteBalanceGreen);
+    d->fourColorCheckBox->setChecked(settings.RGBInterpolate4Colors);
+    d->autoBrightnessBox->setChecked(settings.autoBrightness);
+    d->fixColorsHighlights->setChecked(settings.fixColorsHighlights);
+
+    switch(settings.unclipColors)
+    {
+        case 0:
+            d->unclipColorComboBox->setCurrentIndex(0);
+            break;
+        case 1:
+            d->unclipColorComboBox->setCurrentIndex(1);
+            break;
+        case 2:
+            d->unclipColorComboBox->setCurrentIndex(2);
+            break;
+        default:         // Reconstruct Highlight method
+            d->unclipColorComboBox->setCurrentIndex(3);
+            d->reconstructSpinBox->setValue(settings.unclipColors-3);
+            break;
+    }
+    slotUnclipColorActivated(d->unclipColorComboBox->currentIndex());
+
+    d->dontStretchPixelsCheckBox->setChecked(settings.DontStretchPixels);
+    d->brightnessSpinBox->setValue(settings.brightness);
+    d->blackPointCheckBox->setChecked(settings.enableBlackPoint);
+    d->blackPointSpinBox->setEnabled(settings.enableBlackPoint);
+    d->blackPointSpinBox->setValue(settings.blackPoint);
+    d->whitePointCheckBox->setChecked(settings.enableWhitePoint);
+    d->whitePointSpinBox->setEnabled(settings.enableWhitePoint);
+    d->whitePointSpinBox->setValue(settings.whitePoint);
+
+    switch(settings.RAWQuality)
+    {
+        case RawDecodingSettings::VNG:
+            d->RAWQualityComboBox->setCurrentIndex(1);
+            break;
+        case RawDecodingSettings::PPG:
+            d->RAWQualityComboBox->setCurrentIndex(2);
+            break;
+        case RawDecodingSettings::AHD:
+            d->RAWQualityComboBox->setCurrentIndex(3);
+            break;
+        default:
+            d->RAWQualityComboBox->setCurrentIndex(0);
+            break;
+    }
+
+    d->inputColorSpaceComboBox->setCurrentIndex((int)settings.inputColorSpace);
+    slotInputColorSpaceChanged((int)settings.inputColorSpace);
+    d->outputColorSpaceComboBox->setCurrentIndex((int)settings.outputColorSpace);
+    slotOutputColorSpaceChanged((int)settings.outputColorSpace);
+    d->enableNoiseReduction->setChecked(settings.enableNoiseReduction);
+    slotNoiseReductionToggled(settings.enableNoiseReduction);
+    d->NRThresholdSpinBox->setValue(settings.NRThreshold);
+    d->enableCACorrection->setChecked(settings.enableCACorrection);
+    slotCACorrectionToggled(settings.enableCACorrection);
+    d->caRedMultSpinBox->setValue(settings.caMultiplier[0]);
+    d->caBlueMultSpinBox->setValue(settings.caMultiplier[1]);
+    d->inIccUrlEdit->setUrl(KUrl(settings.inputProfile));
+    d->outIccUrlEdit->setUrl(KUrl(settings.outputProfile));
+}
+
+RawDecodingSettings DcrawSettingsWidget::settings() const
+{
+    RawDecodingSettings prm;
+    prm.sixteenBitsImage = d->sixteenBitsImage->isChecked();
+
+    switch(d->whiteBalanceComboBox->currentIndex())
+    {
+        case 1:
+            prm.whiteBalance = RawDecodingSettings::CAMERA;
+            break;
+        case 2:
+            prm.whiteBalance = RawDecodingSettings::AUTO;
+            break;
+        case 3:
+            prm.whiteBalance = RawDecodingSettings::CUSTOM;
+            break;
+        default:
+            prm.whiteBalance = RawDecodingSettings::NONE;
+            break;
+    }
+
+    prm.medianFilterPasses      = d->medianFilterPassesSpinBox->value();
+    prm.customWhiteBalance      = d->customWhiteBalanceSpinBox->value();
+    prm.customWhiteBalanceGreen = d->customWhiteBalanceGreenSpinBox->value();
+    prm.RGBInterpolate4Colors   = d->fourColorCheckBox->isChecked();
+    prm.autoBrightness          = d->autoBrightnessBox->isChecked();
+    prm.fixColorsHighlights     = d->fixColorsHighlights->isChecked();
+
+    switch(d->unclipColorComboBox->currentIndex())
+    {
+        case 0:
+            prm.unclipColors = 0;
+            break;
+        case 1:
+            prm.unclipColors = 1;
+            break;
+        case 2:
+            prm.unclipColors = 2;
+            break;
+        default:         // Reconstruct Highlight method
+            prm.unclipColors =  d->reconstructSpinBox->value()+3;
+            break;
+    }
+
+    prm.DontStretchPixels = d->dontStretchPixelsCheckBox->isChecked();
+    prm.brightness        = d->brightnessSpinBox->value();
+    prm.enableBlackPoint  = d->blackPointCheckBox->isChecked();
+    prm.blackPoint        = d->blackPointSpinBox->value();
+    prm.enableWhitePoint  = d->whitePointCheckBox->isChecked();
+    prm.whitePoint        = d->whitePointSpinBox->value();
+
+    switch(d->RAWQualityComboBox->currentIndex())
+    {
+        case 1:
+            prm.RAWQuality = RawDecodingSettings::VNG;
+            break;
+        case 2:
+            prm.RAWQuality = RawDecodingSettings::PPG;
+            break;
+        case 3:
+            prm.RAWQuality = RawDecodingSettings::AHD;
+            break;
+        default:
+            prm.RAWQuality = RawDecodingSettings::BILINEAR;
+            break;
+    }
+
+    prm.inputColorSpace      = (RawDecodingSettings::InputColorSpace)(d->inputColorSpaceComboBox->currentIndex());
+    prm.outputColorSpace     = (RawDecodingSettings::OutputColorSpace)(d->outputColorSpaceComboBox->currentIndex());
+    prm.enableNoiseReduction = d->enableNoiseReduction->isChecked();
+    prm.NRThreshold          = d->NRThresholdSpinBox->value();
+    prm.enableCACorrection   = d->enableCACorrection->isChecked();
+    prm.caMultiplier[0]      = d->caRedMultSpinBox->value();
+    prm.caMultiplier[1]      = d->caBlueMultSpinBox->value();
+    prm.inputProfile         = d->inIccUrlEdit->url().toLocalFile();
+    prm.outputProfile        = d->outIccUrlEdit->url().toLocalFile();
+
+    return prm;
+}
+
+void DcrawSettingsWidget::writeSettings(KConfigGroup& group)
+{
+    RawDecodingSettings prm = settings();
+    prm.writeSettings(group);
+    RExpanderBox::writeSettings();
+}
+
+void DcrawSettingsWidget::readSettings(KConfigGroup& group)
+{
+    RawDecodingSettings prm;
+    prm.readSettings(group);
+    setSettings(prm);
+    RExpanderBox::readSettings();
+}
+
+// -- DEPRECATED METHODS -------------------------------------------------------------
+
 bool DcrawSettingsWidget::sixteenBits()
 {
     return d->sixteenBitsImage->isChecked();
@@ -774,8 +950,6 @@
     d->sixteenBitsImage->setChecked(b);
 }
 
-// ---------------------------------------------------------------
-
 RawDecodingSettings::WhiteBalance DcrawSettingsWidget::whiteBalance()
 {
     switch(d->whiteBalanceComboBox->currentIndex())
@@ -815,8 +989,6 @@
     slotWhiteBalanceToggled(d->whiteBalanceComboBox->currentIndex());
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::medianFilterPasses()
 {
     return d->medianFilterPassesSpinBox->value();
@@ -827,8 +999,6 @@
     d->medianFilterPassesSpinBox->setValue(p);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::customWhiteBalance()
 {
     return d->customWhiteBalanceSpinBox->value();
@@ -839,8 +1009,6 @@
     d->customWhiteBalanceSpinBox->setValue(v);
 }
 
-// ---------------------------------------------------------------
-
 double DcrawSettingsWidget::customWhiteBalanceGreen()
 {
     return d->customWhiteBalanceGreenSpinBox->value();
@@ -851,8 +1019,6 @@
     d->customWhiteBalanceGreenSpinBox->setValue(v);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useFourColor()
 {
     return d->fourColorCheckBox->isChecked();
@@ -863,8 +1029,6 @@
     d->fourColorCheckBox->setChecked(b);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useAutoBrightness()
 {
     return d->autoBrightnessBox->isChecked();
@@ -875,8 +1039,6 @@
     d->autoBrightnessBox->setChecked(b);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::unclipColor()
 {
     switch(d->unclipColorComboBox->currentIndex())
@@ -918,8 +1080,6 @@
     slotUnclipColorActivated(d->unclipColorComboBox->currentIndex());
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useDontStretchPixels()
 {
     return d->dontStretchPixelsCheckBox->isChecked();
@@ -930,8 +1090,6 @@
     d->dontStretchPixelsCheckBox->setChecked(b);
 }
 
-// ---------------------------------------------------------------
-
 double DcrawSettingsWidget::brightness()
 {
     return d->brightnessSpinBox->value();
@@ -942,8 +1100,6 @@
     d->brightnessSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useBlackPoint()
 {
     return d->blackPointCheckBox->isChecked();
@@ -955,8 +1111,6 @@
     d->blackPointSpinBox->setEnabled(b);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::blackPoint()
 {
     return d->blackPointSpinBox->value();
@@ -967,8 +1121,6 @@
     d->blackPointSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useWhitePoint()
 {
     return d->whitePointCheckBox->isChecked();
@@ -980,8 +1132,6 @@
     d->whitePointSpinBox->setEnabled(b);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::whitePoint()
 {
     return d->whitePointSpinBox->value();
@@ -992,8 +1142,6 @@
     d->whitePointSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 RawDecodingSettings::DecodingQuality DcrawSettingsWidget::quality()
 {
     switch(d->RAWQualityComboBox->currentIndex())
@@ -1032,8 +1180,6 @@
     }
 }
 
-// ---------------------------------------------------------------
-
 RawDecodingSettings::InputColorSpace DcrawSettingsWidget::inputColorSpace()
 {
     return (RawDecodingSettings::InputColorSpace)(d->inputColorSpaceComboBox->currentIndex());
@@ -1045,8 +1191,6 @@
     slotInputColorSpaceChanged((int)c);
 }
 
-// ---------------------------------------------------------------
-
 RawDecodingSettings::OutputColorSpace DcrawSettingsWidget::outputColorSpace()
 {
     return (RawDecodingSettings::OutputColorSpace)(d->outputColorSpaceComboBox->currentIndex());
@@ -1058,8 +1202,6 @@
     slotOutputColorSpaceChanged((int)c);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useNoiseReduction()
 {
     return d->enableNoiseReduction->isChecked();
@@ -1071,8 +1213,6 @@
     slotNoiseReductionToggled(b);
 }
 
-// ---------------------------------------------------------------
-
 int DcrawSettingsWidget::NRThreshold()
 {
     return d->NRThresholdSpinBox->value();
@@ -1083,8 +1223,6 @@
     d->NRThresholdSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 bool DcrawSettingsWidget::useCACorrection()
 {
     return d->enableCACorrection->isChecked();
@@ -1096,8 +1234,6 @@
     slotCACorrectionToggled(b);
 }
 
-// ---------------------------------------------------------------
-
 double DcrawSettingsWidget::caRedMultiplier()
 {
     return d->caRedMultSpinBox->value();
@@ -1108,8 +1244,6 @@
     d->caRedMultSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 double DcrawSettingsWidget::caBlueMultiplier()
 {
     return d->caBlueMultSpinBox->value();
@@ -1120,11 +1254,9 @@
     d->caBlueMultSpinBox->setValue(b);
 }
 
-// ---------------------------------------------------------------
-
 QString DcrawSettingsWidget::inputColorProfile()
 {
-    return d->inIccUrlEdit->url().path();
+    return d->inIccUrlEdit->url().toLocalFile();
 }
 
 void DcrawSettingsWidget::setInputColorProfile(const QString& path)
@@ -1132,11 +1264,9 @@
     d->inIccUrlEdit->setUrl(KUrl(path));
 }
 
-// ---------------------------------------------------------------
-
 QString DcrawSettingsWidget::outputColorProfile()
 {
-    return d->outIccUrlEdit->url().path();
+    return d->outIccUrlEdit->url().toLocalFile();
 }
 
 void DcrawSettingsWidget::setOutputColorProfile(const QString& path)
Index: libs/libkdcraw/libkdcraw/kdcraw_p.cpp
===================================================================
--- libs/libkdcraw/libkdcraw/kdcraw_p.cpp	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/kdcraw_p.cpp	(copie de travail)
@@ -6,7 +6,7 @@
  * Date        : 2008-10-09
  * Description : internal private container for KDcraw
  *
- * Copyright (C) 2008-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2008-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
  *
  * This program is free software; you can redistribute it
  * and/or modify it under the terms of the GNU General
@@ -109,6 +109,8 @@
     identify.thumbSize        = QSize(raw->imgdata.thumbnail.twidth, raw->imgdata.thumbnail.theight);
     identify.topMargin        = raw->imgdata.sizes.top_margin;
     identify.leftMargin       = raw->imgdata.sizes.left_margin;
+    identify.rightMargin      = raw->imgdata.sizes.right_margin;
+    identify.bottomMargin     = raw->imgdata.sizes.bottom_margin;
     identify.hasIccProfile    = raw->imgdata.color.profile ? true : false;
     identify.isDecodable      = true;
     identify.pixelAspectRatio = raw->imgdata.sizes.pixel_aspect;
@@ -126,6 +128,8 @@
         if (!raw->imgdata.idata.cdesc[3]) raw->imgdata.idata.cdesc[3] = 'G';
         for (int i=0; i < 16; i++)
             identify.filterPattern.append(raw->imgdata.idata.cdesc[raw->fc(i >> 1,i & 1)]);
+
+        identify.colorKeys = raw->imgdata.idata.cdesc;
     }
 
     for(int c = 0 ; c < raw->imgdata.idata.colors ; c++)
Index: libs/libkdcraw/libkdcraw/dcrawsettingswidget.h
===================================================================
--- libs/libkdcraw/libkdcraw/dcrawsettingswidget.h	(révision 1122317)
+++ libs/libkdcraw/libkdcraw/dcrawsettingswidget.h	(copie de travail)
@@ -6,8 +6,8 @@
  * Date        : 2006-09-13
  * Description : LibRaw settings widgets
  *
- * Copyright (C) 2006-2009 by Gilles Caulier <caulier dot gilles at gmail dot com>
- * Copyright (C) 2006-2009 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
+ * Copyright (C) 2006-2010 by Gilles Caulier <caulier dot gilles at gmail dot com>
+ * Copyright (C) 2006-2010 by Marcel Wiesweg <marcel dot wiesweg at gmx dot de>
  * Copyright (C) 2007-2008 by Guillaume Castagnino <casta at xwing dot info>
  *
  * This program is free software; you can redistribute it
@@ -32,6 +32,7 @@
 // KDE includes.
 
 #include <kurlrequester.h>
+#include <kconfig.h>
 
 // Local includes.
 
@@ -48,7 +49,7 @@
 {
     Q_OBJECT
 
-public: 
+public:
 
     enum AdvancedSettingsOptions
     {
@@ -71,74 +72,91 @@
     /**
      * @param advSettings the default value is COLORSPACE
      */
-    DcrawSettingsWidget(QWidget *parent, int advSettings = COLORSPACE);
+    DcrawSettingsWidget(QWidget* parent, int advSettings = COLORSPACE);
     virtual ~DcrawSettingsWidget();
 
+    KUrlRequester* inputProfileUrlEdit() const;
+    KUrlRequester* outputProfileUrlEdit() const;
+
     void setup(int advSettings);
 
-    bool   sixteenBits();
-    int    customWhiteBalance();
-    double customWhiteBalanceGreen();
-    bool   useFourColor();
-    bool   useDontStretchPixels();
-    bool   useNoiseReduction();
-    bool   useCACorrection();
-    bool   useBlackPoint();
-    bool   useWhitePoint();
-    int    unclipColor();
-    bool   useAutoBrightness();
-    double brightness();
-    int    blackPoint();
-    int    whitePoint();
-    int    NRThreshold();
-    double caRedMultiplier();
-    double caBlueMultiplier();
-    int    medianFilterPasses();
+    void setEnabledBrightnessSettings(bool b);
+    bool brightnessSettingsIsEnabled();
 
-    RawDecodingSettings::WhiteBalance     whiteBalance();
-    RawDecodingSettings::DecodingQuality  quality();
-    RawDecodingSettings::InputColorSpace  inputColorSpace();
-    RawDecodingSettings::OutputColorSpace outputColorSpace();
+    void updateMinimumWidth();
 
-    QString inputColorProfile();
-    QString outputColorProfile();
+    /** deprecated. use resetToDefault() instead.
+     */
+    KDE_DEPRECATED void setDefaultSettings();
+    void resetToDefault();
 
-    void   setSixteenBits(bool b);
-    void   setCameraWB(bool b);
-    void   setWhiteBalance(RawDecodingSettings::WhiteBalance v);
-    void   setCustomWhiteBalance(int v);
-    void   setCustomWhiteBalanceGreen(double v);
-    void   setFourColor(bool b);
-    void   setDontStretchPixels(bool b);
-    void   setNoiseReduction(bool b);
-    void   setUseCACorrection(bool b);
-    void   setUseBlackPoint(bool b);
-    void   setUseWhitePoint(bool b);
-    void   setUnclipColor(int v);
-    void   setAutoBrightness(bool b);
-    void   setBrightness(double b);
-    void   setBlackPoint(int b);
-    void   setWhitePoint(int b);
-    void   setNRThreshold(int b);
-    void   setcaRedMultiplier(double b);
-    void   setcaBlueMultiplier(double b);
-    void   setMedianFilterPasses(int p);
-    void   setQuality(RawDecodingSettings::DecodingQuality q);
-    void   setInputColorSpace(RawDecodingSettings::InputColorSpace c);
-    void   setOutputColorSpace(RawDecodingSettings::OutputColorSpace c);
-    void   setInputColorProfile(const QString& path);
-    void   setOutputColorProfile(const QString& path);
+    void setSettings(const RawDecodingSettings& settings);
+    RawDecodingSettings settings() const;
 
-    void   setDefaultSettings();
+    /** deprecated. use KConfigGroup based methods instead.
+     */
+    KDE_DEPRECATED void readSettings() { RExpanderBox::readSettings();  };
+    KDE_DEPRECATED void writeSettings(){ RExpanderBox::writeSettings(); };
+    void readSettings(KConfigGroup& group);
+    void writeSettings(KConfigGroup& group);
 
-    void   setEnabledBrightnessSettings(bool b);
-    bool   brightnessSettingsIsEnabled();
+    /** All methods below are deprecated and will be remove for 1.1.0. 
+        Use settings() and setSettings() instead.
+     */
 
-    void   updateMinimumWidth();
+    KDE_DEPRECATED bool   sixteenBits();
+    KDE_DEPRECATED int    customWhiteBalance();
+    KDE_DEPRECATED double customWhiteBalanceGreen();
+    KDE_DEPRECATED bool   useFourColor();
+    KDE_DEPRECATED bool   useDontStretchPixels();
+    KDE_DEPRECATED bool   useNoiseReduction();
+    KDE_DEPRECATED bool   useCACorrection();
+    KDE_DEPRECATED bool   useBlackPoint();
+    KDE_DEPRECATED bool   useWhitePoint();
+    KDE_DEPRECATED int    unclipColor();
+    KDE_DEPRECATED bool   useAutoBrightness();
+    KDE_DEPRECATED double brightness();
+    KDE_DEPRECATED int    blackPoint();
+    KDE_DEPRECATED int    whitePoint();
+    KDE_DEPRECATED int    NRThreshold();
+    KDE_DEPRECATED double caRedMultiplier();
+    KDE_DEPRECATED double caBlueMultiplier();
+    KDE_DEPRECATED int    medianFilterPasses();
 
-    KUrlRequester* inputProfileUrlEdit() const;
-    KUrlRequester* outputProfileUrlEdit() const;
+    KDE_DEPRECATED RawDecodingSettings::WhiteBalance     whiteBalance();
+    KDE_DEPRECATED RawDecodingSettings::DecodingQuality  quality();
+    KDE_DEPRECATED RawDecodingSettings::InputColorSpace  inputColorSpace();
+    KDE_DEPRECATED RawDecodingSettings::OutputColorSpace outputColorSpace();
 
+    KDE_DEPRECATED QString inputColorProfile();
+    KDE_DEPRECATED QString outputColorProfile();
+
+    KDE_DEPRECATED void setSixteenBits(bool b);
+    KDE_DEPRECATED void setCameraWB(bool b);
+    KDE_DEPRECATED void setWhiteBalance(RawDecodingSettings::WhiteBalance v);
+    KDE_DEPRECATED void setCustomWhiteBalance(int v);
+    KDE_DEPRECATED void setCustomWhiteBalanceGreen(double v);
+    KDE_DEPRECATED void setFourColor(bool b);
+    KDE_DEPRECATED void setDontStretchPixels(bool b);
+    KDE_DEPRECATED void setNoiseReduction(bool b);
+    KDE_DEPRECATED void setUseCACorrection(bool b);
+    KDE_DEPRECATED void setUseBlackPoint(bool b);
+    KDE_DEPRECATED void setUseWhitePoint(bool b);
+    KDE_DEPRECATED void setUnclipColor(int v);
+    KDE_DEPRECATED void setAutoBrightness(bool b);
+    KDE_DEPRECATED void setBrightness(double b);
+    KDE_DEPRECATED void setBlackPoint(int b);
+    KDE_DEPRECATED void setWhitePoint(int b);
+    KDE_DEPRECATED void setNRThreshold(int b);
+    KDE_DEPRECATED void setcaRedMultiplier(double b);
+    KDE_DEPRECATED void setcaBlueMultiplier(double b);
+    KDE_DEPRECATED void setMedianFilterPasses(int p);
+    KDE_DEPRECATED void setQuality(RawDecodingSettings::DecodingQuality q);
+    KDE_DEPRECATED void setInputColorSpace(RawDecodingSettings::InputColorSpace c);
+    KDE_DEPRECATED void setOutputColorSpace(RawDecodingSettings::OutputColorSpace c);
+    KDE_DEPRECATED void setInputColorProfile(const QString& path);
+    KDE_DEPRECATED void setOutputColorProfile(const QString& path);    
+
 Q_SIGNALS:
 
     void signalSixteenBitsImageToggled(bool);
Index: libs/libkdcraw/CMakeLists.txt
===================================================================
--- libs/libkdcraw/CMakeLists.txt	(révision 1122317)
+++ libs/libkdcraw/CMakeLists.txt	(copie de travail)
@@ -24,11 +24,12 @@
 # 0.3.0 => 6.0.0  (released with KDE 4.1.2)
 # 0.4.0 => 7.0.0  (using libRaw-Released with KDE 4.2.0)
 # 0.5.0 => 7.1.0  (Released with KDE 4.3.0)
-# 1.0.0 => 8.0.0  (Released with KDE 4.4.0
+# 1.0.0 => 8.0.0  (Released with KDE 4.4.0)
+# 1.1.0 => 8.1.0  (Released with KDE 4.4.2)
 
 # Library API version
 SET(DCRAW_LIB_MAJOR_VERSION "1")
-SET(DCRAW_LIB_MINOR_VERSION "0")
+SET(DCRAW_LIB_MINOR_VERSION "1")
 SET(DCRAW_LIB_PATCH_VERSION "0")
 
 # Suffix to add at end of version string. Usual values are:
@@ -43,7 +44,7 @@
 # Library ABI version used by linker.
 # For details : http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info
 SET(DCRAW_LIB_SO_CUR_VERSION "8")
-SET(DCRAW_LIB_SO_REV_VERSION "0")
+SET(DCRAW_LIB_SO_REV_VERSION "1")
 SET(DCRAW_LIB_SO_AGE_VERSION "0")
 
 # ==================================================================================================
@@ -76,13 +77,13 @@
 
 IF(VERSION_CMAKE AND NOT MSVC)
     MACRO_OPTIONAL_FIND_PACKAGE(OpenMP)
-    IF(OPENMP_FOUND)
+    IF(OPENMP_FOUND AND NOT MSVC)
         MESSAGE(STATUS "OpenMP detected: LibRaw will be compiled with parallelized code.")
         SET(USE_OPENMP TRUE)
-    ELSEIF(OPENMP_FOUND)
+    ELSEIF(OPENMP_FOUND AND NOT MSVC)
         MESSAGE(STATUS "OpenMP not detected: LibRaw will not be compiled with parallelized code.")
         SET(USE_OPENMP FALSE)
-    ENDIF(OPENMP_FOUND)
+    ENDIF(OPENMP_FOUND AND NOT MSVC)
 ELSE(VERSION_CMAKE)
     MESSAGE(STATUS "CMake version too old: cannot detected OpenMP: LibRaw will not be compiled with parallelized code.")
     SET(USE_OPENMP FALSE)
@@ -119,7 +120,6 @@
 
 SET(libraw_LIB_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/libraw/internal/dcraw_common.cpp
                     ${CMAKE_CURRENT_SOURCE_DIR}/libraw/internal/dcraw_fileio.cpp
-                    ${CMAKE_CURRENT_SOURCE_DIR}/libraw/internal/foveon.cpp
                     ${CMAKE_CURRENT_SOURCE_DIR}/libraw/src/libraw_cxx.cpp
                     ${CMAKE_CURRENT_SOURCE_DIR}/libraw/src/libraw_c_api.cpp
    )
Index: libs/libkipi/libkipi/imageinfoshared.cpp
===================================================================
--- libs/libkipi/libkipi/imageinfoshared.cpp	(révision 1122317)
+++ libs/libkipi/libkipi/imageinfoshared.cpp	(copie de travail)
@@ -58,7 +58,7 @@
         return 0;
     }
     else
-        return QFileInfo( _url.path() ).size();
+        return QFileInfo( _url.toLocalFile() ).size();
 }
 
 QDateTime ImageInfoShared::time( TimeSpec )
@@ -69,7 +69,7 @@
         return QDateTime();
     }
     else
-        return QFileInfo( _url.path() ).lastModified();
+        return QFileInfo( _url.toLocalFile() ).lastModified();
 }
 
 void ImageInfoShared::addRef()
Index: libs/libksane/ksanetwain/twain.h
===================================================================
--- libs/libksane/ksanetwain/twain.h	(révision 1122317)
+++ libs/libksane/ksanetwain/twain.h	(copie de travail)
@@ -1,3 +1,4 @@
+// krazy:skip
 /* ======================================================================== *\
 
   Copyright (C) 1991, 1992 TWAIN Working Group: Aldus, Caere, Eastman-Kodak,
Index: libs/libksane/ksanetwain/twainiface.cpp
===================================================================
--- libs/libksane/ksanetwain/twainiface.cpp	(révision 1122317)
+++ libs/libksane/ksanetwain/twainiface.cpp	(copie de travail)
@@ -76,7 +76,7 @@
 
 /** Initializes TWAIN interface . Is already called from the constructor. 
     It should be called again if ReleaseTwain is called.
-    hWnd is the window which has to subclassed in order to recieve
+    hWnd is the window which has to subclassed in order to receive
     Twain messaged. Normally - this would be your main application window.
  */
 bool KSaneWidgetPrivate::InitTwain()
Index: libs/libksane/libksane/ksane_widget_private.cpp
===================================================================
--- libs/libksane/libksane/ksane_widget_private.cpp	(révision 1122317)
+++ libs/libksane/libksane/ksane_widget_private.cpp	(copie de travail)
@@ -102,6 +102,7 @@
     m_optGamG       = 0;
     m_optGamB       = 0;
     m_optPreview    = 0;
+    m_optWaitForBtn = 0;
     m_scanOngoing   = false;
     m_closeDevicePending = false;
     
@@ -261,12 +262,17 @@
             basic_layout->addWidget(option->widget());
         }
     }
-    
+
     // save a pointer to the preview option if possible
     if ((option = getOption(SANE_NAME_PREVIEW)) != 0) {
         m_optPreview = option;
     }
 
+    // save a pointer to the "wait-for-button" option if possible (Note: No translation)
+    if ((option = getOption("wait-for-button")) != 0) {
+        m_optWaitForBtn = option;
+    }
+
     // scan area (Do not add the widgets)
     if ((option = getOption(SANE_NAME_SCAN_TL_X)) != 0) {
         m_optTlX = option;
@@ -614,10 +620,6 @@
     if (m_optDepth != 0) m_optDepth->storeCurrentData();
     if (m_optRes != 0) m_optRes->storeCurrentData();
     if (m_optResY != 0) m_optResY->storeCurrentData();
-    if (m_optTlX != 0) m_optTlX->storeCurrentData();
-    if (m_optTlY != 0) m_optTlY->storeCurrentData();
-    if (m_optBrX != 0) m_optBrX->storeCurrentData();
-    if (m_optBrY != 0) m_optBrY->storeCurrentData();
     if (m_optPreview != 0) m_optPreview->storeCurrentData();
     
     // check if we can modify the selection
@@ -713,10 +715,6 @@
     if (m_optDepth != 0) m_optDepth->restoreSavedData();
     if (m_optRes != 0) m_optRes->restoreSavedData();
     if (m_optResY != 0) m_optResY->restoreSavedData();
-    if (m_optTlX != 0) m_optTlX->restoreSavedData();
-    if (m_optTlY != 0) m_optTlY->restoreSavedData();
-    if (m_optBrX != 0) m_optBrX->restoreSavedData();
-    if (m_optBrY != 0) m_optBrY->restoreSavedData();
     if (m_optPreview != 0) m_optPreview->restoreSavedData();
     
     if (m_autoSelect) {
@@ -758,6 +756,7 @@
 
         // reead the selection from the viewer
         m_previewViewer->selectionAt(m_selIndex, x1,y1,x2,y2);
+        m_previewViewer->setHighlightArea(x1,y1,x2,y2);
         m_selIndex++;
  
         // calculate the option values
@@ -811,16 +810,33 @@
                          (int)getImgFormat(params));
 
         // now check if we should have automatic ADF batch scaning
-        QString source;
         if (m_optSource){
+            QString source;
             m_optSource->getValue(source);
+
+            if (source == "Automatic Document Feeder") {
+                // in batch mode only one area can be scanned per page
+                //kDebug() << "source == \"Automatic Document Feeder\"";
+                m_updProgressTmr.start();
+                m_scanThread->start();
+                return;
+            }
         }
-        if (source == "Automatic Document Feeder") {
-            // in batch mode only one area can be scanned per page
-            //kDebug() << "source == \"Automatic Document Feeder\"";
-            m_updProgressTmr.start();
-            m_scanThread->start();
-            return;
+
+        // Check if we have a "wait for button" batch scanning
+        if (m_optWaitForBtn) {
+            kDebug() << m_optWaitForBtn->name();
+            QString wait;
+            m_optWaitForBtn->getValue(wait);
+
+            kDebug() << "wait ==" << wait;
+            if (wait == "true") {
+                // in batch mode only one area can be scanned per page
+                //kDebug() << "source == \"Automatic Document Feeder\"";
+                m_updProgressTmr.start();
+                m_scanThread->start();
+                return;
+            }
         }
 
         // not batch scan, call sane_cancel to be able to change parameters.
@@ -839,6 +855,9 @@
                 
                 // reead the selection from the viewer
                 m_previewViewer->selectionAt(m_selIndex, x1,y1,x2,y2);
+
+                // set the highlight
+                m_previewViewer->setHighlightArea(x1,y1,x2,y2);
                 
                 // calculate the option values
                 x1 *= max_x; y1 *= max_y;
@@ -890,6 +909,8 @@
     
     sane_cancel(m_saneHandle);
 
+    // clear the highlight
+    m_previewViewer->setHighlightArea(0,0,1,1);
     setBusy(false);
     m_scanOngoing = false;
     
Index: libs/libksane/libksane/ksane_find_devices_thread.h
===================================================================
--- libs/libksane/libksane/ksane_find_devices_thread.h	(révision 1122317)
+++ libs/libksane/libksane/ksane_find_devices_thread.h	(copie de travail)
@@ -25,8 +25,8 @@
  *
  * ============================================================ */
 
-#ifndef FIND_SANE_DEVICES_H
-#define FIND_SANE_DEVICES_H
+#ifndef KSANE_FIND_DEVICES_THREAD_H
+#define KSANE_FIND_DEVICES_THREAD_H
 
 // #include "ksane.h"
 
Index: libs/libksane/libksane/ksane_scan_thread.h
===================================================================
--- libs/libksane/libksane/ksane_scan_thread.h	(révision 1122317)
+++ libs/libksane/libksane/ksane_scan_thread.h	(copie de travail)
@@ -36,6 +36,7 @@
 }
 
 #include <QThread>
+#include <QMutex>
 #include <QByteArray>
 
 #define SCAN_READ_CHUNK_SIZE 100000
@@ -81,6 +82,7 @@
             ReadStatus      m_readStatus;
             bool            m_invertColors;
             bool            m_saneStartDone;
+            QMutex          m_cancelMutex;
     };
 }
 
Index: libs/libksane/libksane/ksane_widget_private.h
===================================================================
--- libs/libksane/libksane/ksane_widget_private.h	(révision 1122317)
+++ libs/libksane/libksane/ksane_widget_private.h	(copie de travail)
@@ -162,6 +162,7 @@
             KSaneOption        *m_optGamB;
             QCheckBox          *m_splitGamChB;
             LabeledGamma       *m_commonGamma;
+            KSaneOption        *m_optWaitForBtn;
             
             // preview variables
             float               m_previewWidth;
Index: libs/libksane/libksane/ksane_device_dialog.h
===================================================================
--- libs/libksane/libksane/ksane_device_dialog.h	(révision 1122317)
+++ libs/libksane/libksane/ksane_device_dialog.h	(copie de travail)
@@ -26,8 +26,8 @@
  *
  * ============================================================ */
 
-#ifndef KSANE_DEVICE_DIAG_H
-#define KSANE_DEVICE_DIAG_H
+#ifndef KSANE_DEVICE_DIALOG_H
+#define KSANE_DEVICE_DIALOG_H
 
 #include "ksane_find_devices_thread.h"
 
Index: libs/libksane/libksane/ksane_widget.cpp
===================================================================
--- libs/libksane/libksane/ksane_widget.cpp	(révision 1122317)
+++ libs/libksane/libksane/ksane_widget.cpp	(copie de travail)
@@ -37,6 +37,7 @@
 #include <QLabel>
 #include <QSplitter>
 #include <QMutex>
+#include <QPointer>
 
 // KDE includes
 #include <kpassworddialog.h>
@@ -112,7 +113,7 @@
     
     // Create the static UI
     // create the preview
-    d->m_previewViewer = new KSaneViewer(this);
+    d->m_previewViewer = new KSaneViewer(&(d->m_previewImg), this);
     connect(d->m_previewViewer, SIGNAL(newSelection(float, float, float, float)),
             d, SLOT(handleSelection(float, float, float, float)));
 
@@ -254,13 +255,14 @@
 
 QString KSaneWidget::selectDevice(QWidget* parent)
 {
-  QString selected_name("");
-  KSaneDeviceDialog sel(parent);
+  QString selected_name;
+  QPointer<KSaneDeviceDialog> sel = new KSaneDeviceDialog(parent);
 
   // sel.setDefault(prev_backend); // set default scanner - perhaps application using libksane should remember that
-  if(sel.exec()) {
-      return selected_name = sel.getSelectedName();
+  if(sel->exec() == KDialog::Accepted) {
+      return selected_name = sel->getSelectedName();
   }
+  delete sel;
   return selected_name;
 }
 
@@ -376,7 +378,7 @@
     num_sane_options = *reinterpret_cast<SANE_Word*>(data.data());
 
     // read the rest of the options
-    for (i=1; i<num_sane_options; i++) {
+    for (i=1; i<num_sane_options; ++i) {
         switch (KSaneOption::otpionType(sane_get_option_descriptor(d->m_saneHandle, i))) {
             case KSaneOption::TYPE_DETECT_FAIL:
                 d->m_optList.append(new KSaneOption(d->m_saneHandle, i));
@@ -406,7 +408,8 @@
     }
 
     // do the connections of the option parameters
-    for (i=1; i<d->m_optList.size(); i++) {
+    for (i=1; i<d->m_optList.size(); ++i) {
+        //kDebug() << d->m_optList.at(i)->name();
         connect (d->m_optList.at(i), SIGNAL(optsNeedReload()), d, SLOT(optReload()));
         connect (d->m_optList.at(i), SIGNAL(valsNeedReload()), d, SLOT(scheduleValReload()));
     }
Index: libs/libksane/libksane/dummy-hplip.cpp
===================================================================
--- libs/libksane/libksane/dummy-hplip.cpp	(révision 1122317)
+++ libs/libksane/libksane/dummy-hplip.cpp	(copie de travail)
@@ -1,4 +1,4 @@
-
+// krazy:skip
 //begin strings from hplip-3.9.2/scan/sane/common.h to make them translatable
 I18N_NOOP("None");
 I18N_NOOP("MH");
Index: libs/libksane/libksane/ksane.h
===================================================================
--- libs/libksane/libksane/ksane.h	(révision 1122317)
+++ libs/libksane/libksane/ksane.h	(copie de travail)
@@ -140,7 +140,7 @@
     /** This methos returns the model of the scanner. */
     QString model() const;
 
-    /** This method returns the current resolution of the aquired image,
+    /** This method returns the current resolution of the acquired image,
     * in dots per inch.
     * @note This function should be called from the slot connected
     * to the imageReady signal. The connection should not be queued.
Index: libs/libksane/libksane/selectionitem.h
===================================================================
--- libs/libksane/libksane/selectionitem.h	(révision 1122317)
+++ libs/libksane/libksane/selectionitem.h	(copie de travail)
@@ -24,17 +24,16 @@
 * License along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * ============================================================ */
-#ifndef SIDELINEITEM_H
-#define SIDELINEITEM_H
+#ifndef SELECTIONITEM_H
+#define SELECTIONITEM_H
 
 #include <QGraphicsPixmapItem>
-#include <QTransform>
 #include <QPainter>
 
 namespace KSaneIface
 {
 
-class SelectionItem : public QObject, public QGraphicsItem
+class SelectionItem : public QGraphicsItem
 {
     public:
         typedef enum
Index: libs/libksane/libksane/options/ksane_opt_checkbox.h
===================================================================
--- libs/libksane/libksane/options/ksane_opt_checkbox.h	(révision 1122317)
+++ libs/libksane/libksane/options/ksane_opt_checkbox.h	(copie de travail)
@@ -25,8 +25,8 @@
  *
  * ============================================================ */
 
-#ifndef KSANE_CHECKBOX_OPT_H
-#define KSANE_CHECKBOX_OPT_H
+#ifndef KSANE_OPT_CHECKBOX_H
+#define KSANE_OPT_CHECKBOX_H
 
 #include "ksane_option.h"
 
Index: libs/libksane/libksane/options/ksane_opt_combo.cpp
===================================================================
--- libs/libksane/libksane/options/ksane_opt_combo.cpp	(révision 1122317)
+++ libs/libksane/libksane/options/ksane_opt_combo.cpp	(copie de travail)
@@ -128,12 +128,12 @@
     switch (m_optDesc->type)
     {
         case SANE_TYPE_INT:
-            for (i=1; i<=m_optDesc->constraint.word_list[0]; i++) {
+            for (i=1; i<=m_optDesc->constraint.word_list[0]; ++i) {
                 m_strList += getSaneComboString((int)m_optDesc->constraint.word_list[i]);
             }
             break;
         case SANE_TYPE_FIXED:
-            for (i=1; i<=m_optDesc->constraint.word_list[0]; i++) {
+            for (i=1; i<=m_optDesc->constraint.word_list[0]; ++i) {
                 m_strList += getSaneComboString((float)SANE_UNFIX(m_optDesc->constraint.word_list[i]));
             }
             break;
@@ -300,7 +300,7 @@
         case SANE_TYPE_INT:
             tmp = (float)m_optDesc->constraint.word_list[minIndex];
             minDiff = qAbs(value - tmp);
-            for (i=2; i<=m_optDesc->constraint.word_list[0]; i++) {
+            for (i=2; i<=m_optDesc->constraint.word_list[0]; ++i) {
                 tmp = (float)m_optDesc->constraint.word_list[i];
                 if (qAbs(value - tmp) < minDiff) {
                     minDiff = qAbs(value - tmp);
@@ -314,7 +314,7 @@
         case SANE_TYPE_FIXED:
             tmp = (float)SANE_UNFIX(m_optDesc->constraint.word_list[minIndex]);
             minDiff = qAbs(value - tmp);
-            for (i=2; i<=m_optDesc->constraint.word_list[0]; i++) {
+            for (i=2; i<=m_optDesc->constraint.word_list[0]; ++i) {
                 tmp = (float)SANE_UNFIX(m_optDesc->constraint.word_list[i]);
                 if (qAbs(value - tmp) < minDiff) {
                     minDiff = qAbs(value - tmp);
Index: libs/libksane/libksane/options/ksane_opt_button.h
===================================================================
--- libs/libksane/libksane/options/ksane_opt_button.h	(révision 1122317)
+++ libs/libksane/libksane/options/ksane_opt_button.h	(copie de travail)
@@ -25,8 +25,8 @@
  *
  * ============================================================ */
 
-#ifndef KSANE_BUTTON_OPT_H
-#define KSANE_BUTTON_OPT_H
+#ifndef KSANE_OPT_BUTTON_H
+#define KSANE_OPT_BUTTON_H
 
 #include "ksane_option.h"
 
Index: libs/libksane/libksane/options/ksane_opt_slider.cpp
===================================================================
--- libs/libksane/libksane/options/ksane_opt_slider.cpp	(révision 1122317)
+++ libs/libksane/libksane/options/ksane_opt_slider.cpp	(copie de travail)
@@ -99,7 +99,7 @@
     KSaneOption::readOption();
 
     if (!m_slider) return;
-    
+
     if (m_optDesc->constraint_type == SANE_CONSTRAINT_RANGE) {
         m_slider->setRange(m_optDesc->constraint.range->min, m_optDesc->constraint.range->max);
         m_slider->setStep(m_optDesc->constraint.range->quant);
@@ -108,12 +108,7 @@
         m_slider->setRange(KSW_INT_MIN, KSW_INT_MAX);
         m_slider->setStep(1);
     }
-/** Remove #if tags when KDE 4.2 becomes unpopular**/
-#if KDE_IS_VERSION(4, 2, 80)
     m_slider->setSuffix(unitString());
-#else
-    m_slider->setSuffix1(unitDoubleString());
-#endif
     m_slider->setLabelText(i18n(m_optDesc->title));
 }
 
Index: libs/libksane/libksane/splittercollapser.cpp
===================================================================
--- libs/libksane/libksane/splittercollapser.cpp	(révision 1122317)
+++ libs/libksane/libksane/splittercollapser.cpp	(copie de travail)
@@ -4,19 +4,21 @@
 Copyright 2009 Aurélien Gâteau <agateau@kde.org>
 Copyright 2009 Kåre Sårs <kare.sars@iki.fi>
 
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
 
-This program is distributed in the hope that it will be useful,
+This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Cambridge, MA 02110-1301, USA.
+You should have received a copy of the GNU Lesser General Public
+License along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 */
 // Self
Index: libs/libksane/libksane/splittercollapser.h
===================================================================
--- libs/libksane/libksane/splittercollapser.h	(révision 1122317)
+++ libs/libksane/libksane/splittercollapser.h	(copie de travail)
@@ -3,19 +3,21 @@
 Gwenview: an image viewer
 Copyright 2009 Aurélien Gâteau <agateau@kde.org>
 
-This program is free software; you can redistribute it and/or
-modify it under the terms of the GNU General Public License
-as published by the Free Software Foundation; either version 2
-of the License, or (at your option) any later version.
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) version 3, or any
+later version accepted by the membership of KDE e.V. (or its
+successor approved by the membership of KDE e.V.), which shall
+act as a proxy defined in Section 6 of version 3 of the license.
 
-This program is distributed in the hope that it will be useful,
+This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
 
-You should have received a copy of the GNU General Public License
-along with this program; if not, write to the Free Software
-Foundation, Inc., 51 Franklin Street, Fifth Floor, Cambridge, MA 02110-1301, USA.
+You should have received a copy of the GNU Lesser General Public
+License along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 */
 #ifndef SPLITTERCOLLAPSER_H
Index: libs/libksane/libksane/ksane_viewer_test.cpp
===================================================================
--- libs/libksane/libksane/ksane_viewer_test.cpp	(révision 0)
+++ libs/libksane/libksane/ksane_viewer_test.cpp	(révision 0)
@@ -0,0 +1,52 @@
+/* ============================================================
+*
+* This file is part of the KDE project
+*
+* Date        : 2010-03-17
+* Description : Preview image viewer that can handle a selection.
+*
+* Copyright (C) 2010 by Kare Sars <kare dot sars at iki dot fi>
+*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) version 3, or any
+* later version accepted by the membership of KDE e.V. (or its
+* successor approved by the membership of KDE e.V.), which shall
+* act as a proxy defined in Section 6 of version 3 of the license.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*
+* ============================================================ */
+
+#include "ksane_viewer.h"
+
+#include <KDebug>
+#include <QApplication>
+
+int main (int argc, char *argv[])
+{
+    QApplication app(argc, argv);
+
+    if (argc != 2) {
+        kDebug() << "An image filename is needed.";
+        return 1;
+    }
+    QImage img(argv[1]);
+
+    KSaneIface::KSaneViewer viewer(&img);
+
+    viewer.findSelections();
+
+    viewer.show();
+
+    viewer.zoom2Fit();
+    
+    return app.exec();
+}

Modification de propriétés sur libs/libksane/libksane/ksane_viewer_test.cpp
___________________________________________________________________
Ajouté : svn:eol-style
   + native

Index: libs/libksane/libksane/ksane_viewer.cpp
===================================================================
--- libs/libksane/libksane/ksane_viewer.cpp	(révision 1122317)
+++ libs/libksane/libksane/ksane_viewer.cpp	(copie de travail)
@@ -31,6 +31,7 @@
 
 #include <QGraphicsPixmapItem>
 #include <QGraphicsScene>
+#include <QGraphicsRectItem>
 #include <QWheelEvent>
 #include <QScrollBar>
 #include <QAction>
@@ -41,13 +42,14 @@
 
 #include <KDebug>
 
+#include <math.h>
+
 namespace KSaneIface
 {
 
 struct KSaneViewer::Private
 {
     QGraphicsScene      *scene;
-    QGraphicsPixmapItem *pixmapItem;
     SelectionItem       *selection;
     QImage              *img;
 
@@ -63,30 +65,63 @@
     QAction *zoomSelAction;
     QAction *zoom2FitAction;
     QAction *clrSelAction;
+    
+    QGraphicsRectItem *hideLeft;
+    QGraphicsRectItem *hideRight;
+    QGraphicsRectItem *hideTop;
+    QGraphicsRectItem *hideBottom;
 };
 
-KSaneViewer::KSaneViewer(QWidget *parent) : QGraphicsView(parent), d(new Private)
+KSaneViewer::KSaneViewer(QImage * img, QWidget *parent) : QGraphicsView(parent), d(new Private)
 {
+    d->img = img;
+
     setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
     setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
     setMouseTracking(true);
     
     // Init the scene
     d->scene = new QGraphicsScene;
+    d->scene->setSceneRect(0, 0, img->width(), img->height());
     setScene(d->scene);
-    d->pixmapItem = new QGraphicsPixmapItem;
 
     d->selection = new SelectionItem(QRectF());
     d->selection->setZValue(10);
     d->selection->setSaved(false);
+    d->selection->setMaxRight(img->width());
+    d->selection->setMaxBottom(img->height());
+    d->selection->setRect(d->scene->sceneRect());
+    d->selection->setVisible(false);
 
-    d->scene->addItem(d->pixmapItem);
+    d->hideTop = new QGraphicsRectItem;
+    d->hideBottom = new QGraphicsRectItem;
+    d->hideRight = new QGraphicsRectItem;
+    d->hideLeft = new QGraphicsRectItem;
+
+    d->hideTop->setOpacity(0.4);
+    d->hideBottom->setOpacity(0.4);
+    d->hideRight->setOpacity(0.4);
+    d->hideLeft->setOpacity(0.4);
+    
+    d->hideTop->setPen(Qt::NoPen);
+    d->hideBottom->setPen(Qt::NoPen);
+    d->hideRight->setPen(Qt::NoPen);
+    d->hideLeft->setPen(Qt::NoPen);
+
+    d->hideTop->setBrush(QBrush(Qt::black));
+    d->hideBottom->setBrush(QBrush(Qt::black));
+    d->hideRight->setBrush(QBrush(Qt::black));
+    d->hideLeft->setBrush(QBrush(Qt::black));
+
     d->scene->addItem(d->selection);
-    d->scene->setBackgroundBrush(Qt::gray);
-
+    d->scene->addItem(d->hideLeft);
+    d->scene->addItem(d->hideRight);
+    d->scene->addItem(d->hideTop);
+    d->scene->addItem(d->hideBottom);
+    
     d->change = SelectionItem::None;
     d->selectionList.clear();
-
+    
     // create context menu
     d->zoomInAction = new QAction(KIcon("zoom-in"), i18n("Zoom In"), this);
     connect(d->zoomInAction, SIGNAL(triggered()), this, SLOT(zoomIn()));
@@ -112,6 +147,13 @@
 }
 
 // ------------------------------------------------------------------------
+void KSaneViewer::drawBackground(QPainter *painter, const QRectF &rect)
+{
+    painter->fillRect(rect, QColor(0x70, 0x70, 0x70));
+    painter->drawImage(rect, *d->img, rect);
+}
+
+// ------------------------------------------------------------------------
 KSaneViewer::~KSaneViewer()
 {
     // first remove any old saved selections
@@ -128,10 +170,7 @@
     // first remove any old saved selections
     clearSavedSelections();
 
-    d->pixmapItem->setPixmap(QPixmap::fromImage(*img));
-    d->pixmapItem->setShapeMode(QGraphicsPixmapItem::BoundingRectShape);
     d->scene->setSceneRect(0, 0, img->width(), img->height());
-    d->pixmapItem->setZValue(0);
     d->selection->setMaxRight(img->width());
     d->selection->setMaxBottom(img->height());
     d->selection->setRect(d->scene->sceneRect());
@@ -142,7 +181,9 @@
 // ------------------------------------------------------------------------
 void KSaneViewer::updateImage()
 {
-    d->pixmapItem->setPixmap(QPixmap::fromImage(*d->img));
+    setCacheMode(QGraphicsView::CacheNone);
+    repaint();
+    setCacheMode(QGraphicsView::CacheBackground);
 }
 
 // ------------------------------------------------------------------------
@@ -183,7 +224,7 @@
 // ------------------------------------------------------------------------
 void KSaneViewer::zoom2Fit()
 {
-    fitInView(d->pixmapItem->boundingRect(), Qt::KeepAspectRatio);
+    fitInView(d->img->rect(), Qt::KeepAspectRatio);
     d->selection->saveZoom(transform().m11());
     for (int i=0; i<d->selectionList.size(); ++i) {
         d->selectionList[i]->saveZoom(transform().m11());
@@ -194,7 +235,7 @@
 void KSaneViewer::setTLX(float ratio)
 {
     QRectF rect = d->selection->rect();
-    rect.setLeft(ratio * d->pixmapItem->pixmap().width());
+    rect.setLeft(ratio * d->img->width());
     d->selection->setRect(rect);
     updateSelVisibility();
 }
@@ -203,7 +244,7 @@
 void KSaneViewer::setTLY(float ratio)
 {
     QRectF rect = d->selection->rect();
-    rect.setTop(ratio * d->pixmapItem->pixmap().height());
+    rect.setTop(ratio * d->img->height());
     d->selection->setRect(rect);
     updateSelVisibility();
 }
@@ -212,7 +253,7 @@
 void KSaneViewer::setBRX(float ratio)
 {
     QRectF rect = d->selection->rect();
-    rect.setRight(ratio * d->pixmapItem->pixmap().width());
+    rect.setRight(ratio * d->img->width());
     d->selection->setRect(rect);
     updateSelVisibility();
 }
@@ -221,7 +262,7 @@
 void KSaneViewer::setBRY(float ratio)
 {
     QRectF rect = d->selection->rect();
-    rect.setBottom(ratio * d->pixmapItem->pixmap().height());
+    rect.setBottom(ratio * d->img->height());
     d->selection->setRect(rect);
     updateSelVisibility();
 }
@@ -230,28 +271,107 @@
 void KSaneViewer::setSelection(float tl_x, float tl_y, float br_x, float br_y)
 {
     QRectF rect;
-    rect.setCoords(tl_x * d->pixmapItem->pixmap().width(),
-                    tl_y * d->pixmapItem->pixmap().height(),
-                    br_x * d->pixmapItem->pixmap().width(),
-                    br_y * d->pixmapItem->pixmap().height());
+    rect.setCoords(tl_x * d->img->width(),
+                    tl_y * d->img->height(),
+                    br_x * d->img->width(),
+                    br_y * d->img->height());
 
     d->selection->setRect(rect);
     updateSelVisibility();
 }
 
 // ------------------------------------------------------------------------
+void KSaneViewer::setHighlightArea(float tl_x, float tl_y, float br_x, float br_y)
+{
+    QRectF rect;
+    // Left 
+    rect.setCoords(0,0, tl_x * d->img->width(), d->img->height());
+    d->hideLeft->setRect(rect);
+    
+    // Right
+    rect.setCoords(br_x * d->img->width(), 
+                   0,
+                   d->img->width(), 
+                   d->img->height());
+    d->hideRight->setRect(rect);
+
+    // Top
+    rect.setCoords(tl_x * d->img->width(), 
+                   0,
+                   br_x * d->img->width(), 
+                   tl_y * d->img->height());
+    d->hideTop->setRect(rect);
+
+    // Bottom
+    rect.setCoords(tl_x * d->img->width(), 
+                   br_y * d->img->height(),
+                   br_x * d->img->width(), 
+                   d->img->height());
+    d->hideBottom->setRect(rect);
+
+    d->hideLeft->show();
+    d->hideRight->show();
+    d->hideTop->show();
+    d->hideBottom->show();
+}
+
+// ------------------------------------------------------------------------
+void KSaneViewer::updateHighlight()
+{
+    if (d->selection->isVisible()) {
+        QRectF rect;
+        // Left 
+        rect.setCoords(0,0, d->selection->rect().left(), d->img->height());
+        d->hideLeft->setRect(rect);
+        
+        // Right
+        rect.setCoords(d->selection->rect().right(), 
+                       0,
+                       d->img->width(), 
+                       d->img->height());
+        d->hideRight->setRect(rect);
+        
+        // Top
+        rect.setCoords(d->selection->rect().left(), 
+                       0,
+                       d->selection->rect().right(),
+                       d->selection->rect().top());
+        d->hideTop->setRect(rect);
+        
+        // Bottom
+        rect.setCoords(d->selection->rect().left(), 
+                       d->selection->rect().bottom(),
+                       d->selection->rect().right(),
+                       d->img->height());
+        d->hideBottom->setRect(rect);
+        
+        d->hideLeft->show();
+        d->hideRight->show();
+        d->hideTop->show();
+        d->hideBottom->show();
+    }
+    else {
+        d->hideLeft->hide();
+        d->hideRight->hide();
+        d->hideTop->hide();
+        d->hideBottom->hide();
+    }
+}
+
+// ------------------------------------------------------------------------
 void KSaneViewer::updateSelVisibility()
 {
     if ((d->selection->rect().width() >0.001) &&
         (d->selection->rect().height() > 0.001) &&
-        ((d->pixmapItem->pixmap().width() - d->selection->rect().width() > 0.1) ||
-        (d->pixmapItem->pixmap().height() - d->selection->rect().height() > 0.1)))
+        ((d->img->width() - d->selection->rect().width() > 0.1) ||
+        (d->img->height() - d->selection->rect().height() > 0.1)))
     {
         d->selection->setVisible(true);
     }
     else {
         d->selection->setVisible(false);
     }
+    updateHighlight();
 }
 
 // ---- Return the saved selection list size + 1 if the selection is visible -
@@ -275,10 +395,10 @@
         return activeSelection(tl_x, tl_y, br_x, br_y);
     }
 
-    tl_x = d->selectionList[index]->rect().left()   / d->pixmapItem->pixmap().width();
-    tl_y = d->selectionList[index]->rect().top()    / d->pixmapItem->pixmap().height();
-    br_x = d->selectionList[index]->rect().right()  / d->pixmapItem->pixmap().width();
-    br_y = d->selectionList[index]->rect().bottom() / d->pixmapItem->pixmap().height();
+    tl_x = d->selectionList[index]->rect().left()   / d->img->width();
+    tl_y = d->selectionList[index]->rect().top()    / d->img->height();
+    br_x = d->selectionList[index]->rect().right()  / d->img->width();
+    br_y = d->selectionList[index]->rect().bottom() / d->img->height();
     return true;
 }
 
@@ -293,10 +413,10 @@
         return true;
     }
     
-    tl_x = d->selection->rect().left()   / d->pixmapItem->pixmap().width();
-    tl_y = d->selection->rect().top()    / d->pixmapItem->pixmap().height();
-    br_x = d->selection->rect().right()  / d->pixmapItem->pixmap().width();
-    br_y = d->selection->rect().bottom() / d->pixmapItem->pixmap().height();
+    tl_x = d->selection->rect().left()   / d->img->width();
+    tl_y = d->selection->rect().top()    / d->img->height();
+    br_x = d->selection->rect().right()  / d->img->width();
+    br_y = d->selection->rect().bottom() / d->img->height();
     
     if ((tl_x == br_x) || (tl_y == br_y)) {
         tl_x = 0.0;
@@ -369,6 +489,7 @@
                 d->selection->setRect(QRectF(scenePoint, QSizeF(0,0)));
                 d->change = SelectionItem::BottomRight;
             }
+            updateHighlight();
         }
     }
     QGraphicsView::mousePressEvent(e);
@@ -418,17 +539,17 @@
     
     if ((e->modifiers() != Qt::ControlModifier) &&
         (d->selection->isVisible()) &&
-        (d->pixmapItem->pixmap().width() > 0.001) &&
-        (d->pixmapItem->pixmap().height() > 0.001))
+        (d->img->width() > 0.001) &&
+        (d->img->height() > 0.001))
     {
-        float tlx = d->selection->rect().left()   / d->pixmapItem->pixmap().width();
-        float tly = d->selection->rect().top()    / d->pixmapItem->pixmap().height();
-        float brx = d->selection->rect().right()  / d->pixmapItem->pixmap().width();
-        float bry = d->selection->rect().bottom() / d->pixmapItem->pixmap().height();
+        float tlx = d->selection->rect().left()   / d->img->width();
+        float tly = d->selection->rect().top()    / d->img->height();
+        float brx = d->selection->rect().right()  / d->img->width();
+        float bry = d->selection->rect().bottom() / d->img->height();
         
         emit newSelection(tlx, tly, brx, bry);
     }
-
+    updateHighlight();
     QGraphicsView::mouseReleaseEvent(e);
 }
 
@@ -594,67 +715,312 @@
     }
 
     d->lastSPoint = scenePoint;
+    updateHighlight();
     QGraphicsView::mouseMoveEvent(e);
 }
 
+// The change trigger before adding to the sum
+#define DIFF_TRIGGER 8
+
+// The selection start/stop level trigger
+#define SUM_TRIGGER 4
+
+// The selection start/stop level trigger for the floating  average
+#define AVERAGE_TRIGGER 7
+
+// The selection start/stop margin 
+#define SEL_MARGIN 3
+
+// Maximum number of allowed selections (this could be a settable variable)
+#define MAX_NUM_SELECTIONS 8
+
+// floating average 'div' must be one less than 'count'
+#define AVERAGE_COUNT 50
+#define AVERAGE_MULT 49
+
 // ------------------------------------------------------------------------
-void KSaneViewer::findSelections()
+void KSaneViewer::findSelections(float area)
 {
-    QVector<int> rowSums(d->img->height());
-    QVector<int> colSums(d->img->width());
-    rowSums.fill(0);
+    // Reduce the size of the image to decrease noise and calculation time
+    float multiplier = sqrt(area/(d->img->height() * d->img->width()));
+
+    int width  = (int)(d->img->width() * multiplier);
+    int height = (int)(d->img->height() * multiplier);
+
+    QImage img = d->img->scaled(width, height, Qt::KeepAspectRatio);
+    height = img.height(); // the size was probably not exact
+    width  = img.width();
+
+    QVector<qint64> colSums(width + SEL_MARGIN + 1);
+    qint64 rowSum;
     colSums.fill(0);
     int pix;
-    int average;
-    int diff = 0;
-    int y_sel_start=2;
-    int x_sel_start=2;
-    for (int y=2; y<d->img->height()-2; y++) {
-        for (int x=2; x<d->img->width()-2; x++) {
-            pix = qGray(d->img->pixel(x, y));
-            diff = 0;
-            // how much does the pixel differ from the surrounding
-            diff += qAbs(pix - qGray(d->img->pixel(x-1, y)));
-            diff += qAbs(pix - qGray(d->img->pixel(x-2, y)));
-            diff += qAbs(pix - qGray(d->img->pixel(x+1, y)));
-            diff += qAbs(pix - qGray(d->img->pixel(x+2, y)));
-            diff += qAbs(pix - qGray(d->img->pixel(x, y-1)));
-            diff += qAbs(pix - qGray(d->img->pixel(x, y-2)));
-            diff += qAbs(pix - qGray(d->img->pixel(x, y+1)));
-            diff += qAbs(pix - qGray(d->img->pixel(x, y+2)));
-            if (diff > 30 ) { // a limit to tweek
-                rowSums[y] += diff;
-                colSums[x] += diff;
+    int diff;
+    int hSelStart=-1;
+    int hSelEnd=-1;
+    int hSelMargin = 0;
+    int wSelStart=-1;
+    int wSelEnd=-1;
+    int wSelMargin = 0;
+
+    for (int h=1; h<height; h++) {
+        rowSum = 0;
+        if (h<height-1) {
+            // Special case for the left most pixel
+            pix = qGray(img.pixel(0, h));
+            diff  = qAbs(pix - qGray(img.pixel(1, h)));
+            diff += qAbs(pix - qGray(img.pixel(0, h-1)));
+            diff += qAbs(pix - qGray(img.pixel(0, h+1)));
+            if (diff > DIFF_TRIGGER) {
+                colSums[0] += diff;
+                rowSum += diff;
             }
+            
+            // Special case for the right most pixel
+            pix = qGray(img.pixel(width - 1, h));
+            diff  = qAbs(pix - qGray(img.pixel(width - 2, h)));
+            diff += qAbs(pix - qGray(img.pixel(width - 1, h-1)));
+            diff += qAbs(pix - qGray(img.pixel(width - 1, h+1)));
+            if (diff > DIFF_TRIGGER) {
+                colSums[width - 1] += diff;
+                rowSum += diff;
+            }
+            
+            for (int w=1; w < (width - 1); w++) {
+                pix = qGray(img.pixel(w, h));
+                diff = 0;
+                // how much does the pixel differ from the surrounding
+                diff += qAbs(pix - qGray(img.pixel(w - 1, h)));
+                diff += qAbs(pix - qGray(img.pixel(w + 1, h)));
+                diff += qAbs(pix - qGray(img.pixel(w, h - 1)));
+                diff += qAbs(pix - qGray(img.pixel(w, h + 1)));
+                if (diff > DIFF_TRIGGER) {
+                    colSums[w] += diff;
+                    rowSum += diff;
+                }
+            }
         }
-        average = rowSums[y-2]+rowSums[y-1]+rowSums[y]+rowSums[y+1]+rowSums[y+2];
-        if (average < d->img->width()) { // this limit seems to be OK here.
-            if ((y-y_sel_start) > 20) {
-                // the selection ends here Y
-                x_sel_start = 2;
-                for (int x=2; x<d->img->width()-2; x++) {
-                    average = colSums[x-1]+colSums[x-2]+colSums[x]+colSums[x+1]+colSums[x+2];
-                    if (average < (y-y_sel_start)*2){ // *2 seems OK here.
-                        // the selection ends here X
-                        if ((x-x_sel_start) > 20) {
-                            SelectionItem *tmp = new SelectionItem(QRect(x_sel_start, y_sel_start,
-                                                                          x-x_sel_start, y-y_sel_start));
-                            d->selectionList.push_back(tmp);
-                            d->selectionList.back()->setSaved(true);
-                            d->selectionList.back()->saveZoom(transform().m11());
-                            d->scene->addItem(d->selectionList.back());
-                            d->selectionList.back()->setZValue(9);
+        
+        if ((rowSum/width) > SUM_TRIGGER) {
+            if (hSelStart < 0) {
+                if (hSelMargin < SEL_MARGIN) hSelMargin++;
+                if (hSelMargin == SEL_MARGIN) hSelStart = h - SEL_MARGIN + 1;
+            }
+        }
+        else {
+            if (hSelStart >= 0) {
+                if (hSelMargin > 0) hSelMargin--;
+            }
+            if ((hSelStart > -1) && ((hSelMargin == 0) || (h==height-1))) {
+                if (h==height-1) {
+                    hSelEnd = h - hSelMargin;
+                }
+                else {
+                    hSelEnd = h - SEL_MARGIN;
+                }
+                // We have the end of the vertical selection
+                // now figure out the horizontal part of the selection
+                for (int w=0; w <= width; w++) { // colSums[width] will be 0
+                    if ((colSums[w]/(h - hSelStart)) > SUM_TRIGGER) {
+                        if (wSelStart < 0) {
+                            if (wSelMargin < SEL_MARGIN) wSelMargin++;
+                            if (wSelMargin == SEL_MARGIN) wSelStart = w - SEL_MARGIN + 1;
                         }
-                        x_sel_start = x;
                     }
+                    else {
+                        if (wSelStart >= 0) {
+                            if (wSelMargin > 0) wSelMargin--;
+                        }
+                        if ((wSelStart >= 0) && ((wSelMargin == 0) || (w == width))) {
+                            if (w == width) {
+                                wSelEnd = width;
+                            }
+                            else {
+                                wSelEnd = w - SEL_MARGIN +1;
+                            }
+
+                            // we have the end of a horizontal selection
+                            if ((wSelEnd-wSelStart) < width) {
+                                // skip selections that span the whole width
+                                // calculate the coordinates in the original size
+                                int x1 = wSelStart / multiplier;
+                                int y1 = hSelStart / multiplier;
+                                int x2 = wSelEnd / multiplier;
+                                int y2 = hSelEnd / multiplier;
+                                SelectionItem *tmp = new SelectionItem(QRect(QPoint(x1, y1), QPoint(x2, y2)));
+                                d->selectionList.push_back(tmp);
+                                d->selectionList.back()->setSaved(true);
+                                d->selectionList.back()->saveZoom(transform().m11());
+                                d->scene->addItem(d->selectionList.back());
+                                d->selectionList.back()->setZValue(9);
+                            }
+                            wSelStart = -1;
+                            wSelEnd = -1;
+                            wSelMargin = 0;
+                        }
+                    }
                 }
-            }
-            if ((y-y_sel_start) > 2) {
+                hSelStart = -1;
+                hSelEnd = -1;
+                hSelMargin = 0;
                 colSums.fill(0);
             }
-            y_sel_start = y;
         }
     }
+    
+    if (d->selectionList.size() > MAX_NUM_SELECTIONS) {
+        // smaller area or should we give up??
+        clearSavedSelections(); 
+        //findSelections(area/2); 
+        // instead of trying to find probably broken selections just give up 
+        // and do not force broken selections on the user.
+    }
+    else {
+        // 1/multiplier is the error margin caused by the resolution reduction
+        refineSelections(qRound(2/multiplier));
+    }
 }
 
+void KSaneViewer::refineSelections(int pixelMargin)
+{
+   // The end result
+    int hSelStart;
+    int hSelEnd;
+    int wSelStart;
+    int wSelEnd;
+
+    for (int i=0; i<d->selectionList.size(); i++) {
+        QRectF selRect = d->selectionList.at(i)->rect();
+
+        // original values
+        hSelStart = (int)selRect.top();
+        hSelEnd = (int)selRect.bottom();
+        wSelStart = (int)selRect.left();
+        wSelEnd = (int)selRect.right();
+
+        // Top
+        // Too long iteration should not be a problem since the loop should be interrupted by the limit 
+        hSelStart = refineRow(hSelStart - pixelMargin, hSelEnd, wSelStart, wSelEnd);
+
+        // Bottom (from the bottom up wards)
+        hSelEnd = refineRow(hSelEnd + pixelMargin, hSelStart, wSelStart, wSelEnd);
+
+        // Left
+        wSelStart = refineColumn(wSelStart - pixelMargin, wSelEnd, hSelStart, hSelEnd);
+
+        // Right
+        wSelEnd = refineColumn(wSelEnd + pixelMargin, wSelStart, hSelStart, hSelEnd);
+        
+        // Now update the selection
+        d->selectionList.at(i)->setRect(QRectF(QPointF(wSelStart, hSelStart), QPointF(wSelEnd, hSelEnd)));
+    }
+}
+
+int KSaneViewer::refineRow(int fromRow, int toRow, int rowStart, int rowEnd)
+{
+    int pix;
+    int diff;
+    float rowTrigger;
+    int row;
+    int addSub = (fromRow < toRow) ? 1 : -1;
+    
+    rowStart -= 2; //add some margin
+    rowEnd += 2; //add some margin
+    
+    if (rowStart < 1) rowStart = 1;
+    if (rowEnd >= d->img->width()) rowEnd = d->img->width() - 2;
+    
+    if (fromRow < 1) fromRow = 1;
+    if (fromRow >= d->img->height()) fromRow = d->img->height() - 2;
+    
+    if (toRow < 1) toRow = 1;
+    if (toRow >= d->img->height()) toRow = d->img->height() - 2;
+    
+    row = fromRow;
+    while (row != toRow) {
+        rowTrigger = 0;
+        for (int w=rowStart; w<rowEnd; w++) {
+            diff = 0;
+            pix = qGray(d->img->pixel(w, row));
+            // how much does the pixel differ from the surrounding
+            diff += qAbs(pix - qGray(d->img->pixel(w-1, row)));
+            diff += qAbs(pix - qGray(d->img->pixel(w+1, row)));
+            diff += qAbs(pix - qGray(d->img->pixel(w, row-1)));
+            diff += qAbs(pix - qGray(d->img->pixel(w, row+1)));
+            if (diff <= DIFF_TRIGGER) diff = 0;
+            
+            rowTrigger = ((rowTrigger * AVERAGE_MULT) + diff) / AVERAGE_COUNT;
+            
+            if (rowTrigger > AVERAGE_TRIGGER) {
+                break;
+            }
+        }
+
+        if (rowTrigger > AVERAGE_TRIGGER) {
+            // row == 1 _probably_ means that the selection should start from 0
+            // but that can not be detected if we start from 1 => include one extra column
+            if (row == 1) row = 0;
+            if (row == (d->img->width() -2)) row = d->img->width();
+            return row;
+        }
+        row += addSub;
+    }
+    return row;
+}
+
+int KSaneViewer::refineColumn(int fromCol, int toCol, int colStart, int colEnd)
+{
+    int pix;
+    int diff;
+    float colTrigger;
+    int col;
+    int count;
+    int addSub = (fromCol < toCol) ? 1 : -1;
+    
+    colStart -= 2; //add some margin
+    colEnd += 2; //add some margin
+    
+    if (colStart < 1) colStart = 1;
+    if (colEnd >= d->img->height()) colEnd = d->img->height() - 2;
+    
+    if (fromCol < 1) fromCol = 1;
+    if (fromCol >= d->img->width()) fromCol = d->img->width() - 2;
+    
+    if (toCol < 1) toCol = 1;
+    if (toCol >= d->img->width()) toCol = d->img->width() - 2;
+    
+    col = fromCol;
+    while (col != toCol) {
+        colTrigger = 0;
+        count = 0;
+        for (int row=colStart; row<colEnd; row++) {
+            count++;
+            diff = 0;
+            pix = qGray(d->img->pixel(col, row));
+            // how much does the pixel differ from the surrounding
+            diff += qAbs(pix - qGray(d->img->pixel(col-1, row)));
+            diff += qAbs(pix - qGray(d->img->pixel(col+1, row)));
+            diff += qAbs(pix - qGray(d->img->pixel(col, row-1)));
+            diff += qAbs(pix - qGray(d->img->pixel(col, row+1)));
+            if (diff <= DIFF_TRIGGER) diff = 0;
+            
+            colTrigger = ((colTrigger * AVERAGE_MULT) + diff) / AVERAGE_COUNT;
+            
+            if (colTrigger > AVERAGE_TRIGGER) {
+                break;
+            }
+        }
+
+        if (colTrigger > AVERAGE_TRIGGER) {
+            // col == 1 _probably_ means that the selection should start from 0
+            // but that can not be detected if we start from 1 => include one extra column
+            if (col == 1) col = 0;
+            if (col == (d->img->width() -2)) col = d->img->width();
+            return col;
+        }
+        col += addSub;
+    }
+    return col;
+}
+
 }  // NameSpace KSaneIface
Index: libs/libksane/libksane/widgets/labeled_slider.h
===================================================================
--- libs/libksane/libksane/widgets/labeled_slider.h	(révision 1122317)
+++ libs/libksane/libksane/widgets/labeled_slider.h	(copie de travail)
@@ -34,9 +34,6 @@
 #include <QSlider>
 #include <QGridLayout>
 
-/** Remove #if tags when KDE 4.2 becomes unpopular**/
-#include <kdeversion.h>
-
 /**
   *@author Kåre Särs
   */
@@ -89,7 +86,6 @@
     void setStep(int);
     /** Set the unit */
     void setSuffix(const KLocalizedString &text);
-    void setSuffix1(const QString &text); /** Remove this compatibility hack when KDE 4.2 becomes unpopular **/
 
 private Q_SLOTS:
 
Index: libs/libksane/libksane/widgets/labeled_entry.cpp
===================================================================
--- libs/libksane/libksane/widgets/labeled_entry.cpp	(révision 1122317)
+++ libs/libksane/libksane/widgets/labeled_entry.cpp	(copie de travail)
@@ -48,9 +48,9 @@
     label = new QLabel(ltext, this);
     entry = new KLineEdit(this);
     reset = new QPushButton(this);
-    reset->setText(i18n("Reset"));
+    reset->setText(i18nc("Label for button to reset text in a KLineEdit", "Reset"));
     set = new QPushButton(this);
-    set->setText(i18n("Set"));
+    set->setText(i18nc("Label for button to write text in a KLineEdit to sane", "Set"));
 
     hb->addWidget(label);
     hb->addWidget(entry);
Index: libs/libksane/libksane/widgets/labeled_slider.cpp
===================================================================
--- libs/libksane/libksane/widgets/labeled_slider.cpp	(révision 1122317)
+++ libs/libksane/libksane/widgets/labeled_slider.cpp	(copie de travail)
@@ -91,21 +91,9 @@
 
 void LabeledSlider::setSuffix(const KLocalizedString &text)
 {
-/** Remove #if tags when KDE 4.2 becomes unpopular
-    This method is never called with KDE < 4.3.x. setSuffix1() is used instead */
-#if KDE_IS_VERSION(4, 2, 80)
     m_spinb->setSuffix(text);
-#else
-    Q_UNUSED(text);
-#endif
 }
 
-/** Remove "setSuffix1" method when KDE 4.2 becomes unpopular**/
-void LabeledSlider::setSuffix1(const QString &text)
-{
-    m_spinb->setSuffix(text);
-}
-
 void LabeledSlider::widgetSizeHints(int *lab_w, int *spi_w)
 {
     if (lab_w != 0) *lab_w = m_label->sizeHint().width();
Index: libs/libksane/libksane/ksane_viewer.h
===================================================================
--- libs/libksane/libksane/ksane_viewer.h	(révision 1122317)
+++ libs/libksane/libksane/ksane_viewer.h	(copie de travail)
@@ -38,12 +38,14 @@
 {
     Q_OBJECT
     public:
-        KSaneViewer(QWidget *parent = 0);
+        explicit KSaneViewer(QImage *img, QWidget *parent = 0);
         ~KSaneViewer();
 
         void setQImage(QImage *img);
         void updateImage();
-        void findSelections();
+        /** Find selections in the picture
+        * \param area this parameter determine the area of the reduced sized image. */
+        void findSelections(float area = 10000.0);
         
     public Q_SLOTS:
         
@@ -58,11 +60,20 @@
         * \param br_x is the x coordinate of the bottom right corner 0=0 1=image with.
         * \param br_y is the y coordinate of the bottom right corner 0=0 1=image with.
         */
-        void setSelection(float tl_x, float tl_y, float b_rx, float b_ry);
+        void setSelection(float tl_x, float tl_y, float br_x, float br_y);
         void clearActiveSelection();
         void clearSavedSelections();
         void clearSelections();
         
+        /** This functiuon is used to set a selection without the user seting it.
+        * \note all parameters must be in the range 0.0 -> 1.0.
+        * \param tl_x is the x coordinate of the top left corner 0=0 1=image with.
+        * \param tl_y is the y coordinate of the top left corner 0=0 1=image with.
+        * \param br_x is the x coordinate of the bottom right corner 0=0 1=image with.
+        * \param br_y is the y coordinate of the bottom right corner 0=0 1=image with.
+        */
+        void setHighlightArea(float tl_x, float tl_y, float br_x, float br_y);
+
         void zoomIn();
         void zoomOut();
         void zoomSel();
@@ -80,11 +91,21 @@
         void mousePressEvent(QMouseEvent *e);
         void mouseReleaseEvent(QMouseEvent *e);
         void mouseMoveEvent(QMouseEvent *e);
+        void drawBackground(QPainter *painter, const QRectF &rect); 
         
     private:
         void updateSelVisibility();
+        void updateHighlight();
         bool activeSelection(float &tl_x, float &tl_y, float &br_x, float &br_y);
+        void refineSelections(int pixelMargin);
         
+        // fromRow is the row to start the iterations from. fromRow can be grater than toRow. 
+        // rowStart is the x1 coordinate of the row 
+        // all parameters are corrected to be valid pixel indexes, 
+        // but start must be < end
+        int  refineRow(int fromRow, int toRow, int rowStart, int rowEnd);
+        int  refineColumn(int fromCol, int toCol, int colStart, int colEnd);
+
         struct Private;
         Private * const d;
 
Index: libs/libksane/libksane/ksane_preview_thread.cpp
===================================================================
--- libs/libksane/libksane/ksane_preview_thread.cpp	(révision 1122317)
+++ libs/libksane/libksane/ksane_preview_thread.cpp	(copie de travail)
@@ -186,7 +186,7 @@
                         sane_cancel(m_saneHandle);
                         return;
                     }
-                    kDebug() << "New Frame";
+                    //kDebug() << "New Frame";
                     m_frameRead = 0;
                     m_pixel_x     = 0;
                     m_pixel_y     = 0;
@@ -242,7 +242,7 @@
                             // resize the image
                             *m_img = m_img->copy(0, 0, m_img->width(), m_img->height() + m_img->width());
                         }
-                        for (j=7; j>=0; j--) {
+                        for (j=7; j>=0; --j) {
                             if ((m_readData[i] & (1<<j)) == 0) {
                                 m_img->setPixel(m_pixel_x,
                                                 m_pixel_y,
@@ -372,7 +372,7 @@
                         return;
                     }
                     break;
-                    
+
                 case SANE_FRAME_GREEN:
                     if (m_params.depth == 8) {
                         for (int i=0; i<read_bytes; i++) {
@@ -401,7 +401,7 @@
                         return;
                     }
                     break;
-                    
+
                 case SANE_FRAME_BLUE:
                     if (m_params.depth == 8) {
                         for (int i=0; i<read_bytes; i++) {
@@ -431,19 +431,17 @@
                     }
                     break;
         }
-        
+
         kWarning() << "Format" << m_params.format
         << "and depth" << m_params.format
         << "is not yet suppoeted by libksane!";
         m_readStatus = READ_ERROR;
         return;
     }
-    
-    
+
     bool KSanePreviewThread::saneStartDone()
     {
         return   m_saneStartDone;
     }
-    
+
 }  // NameSpace KSaneIface
-    
\ No newline at end of file
Index: libs/libksane/libksane/ksane_scan_thread.cpp
===================================================================
--- libs/libksane/libksane/ksane_scan_thread.cpp	(révision 1122317)
+++ libs/libksane/libksane/ksane_scan_thread.cpp	(copie de travail)
@@ -30,6 +30,8 @@
 
 #include <KDebug>
 
+#include <QMutexLocker>
+
 namespace KSaneIface
 {
 
@@ -65,6 +67,13 @@
     void KSaneScanThread::cancelScan()
     {
         m_readStatus = READ_CANCEL;
+        if (m_cancelMutex.tryLock()) {
+            kDebug() << "pre cancel";
+            sane_cancel(m_saneHandle);
+            kDebug() << "post cancel";
+            // wait for sane_cancel to return before any other sane function is called.
+            m_cancelMutex.unlock();
+        }
     }
     
     int KSaneScanThread::scanProgress()
@@ -90,19 +99,24 @@
         
     void KSaneScanThread::run()
     {
+        // sane cancel can only be called once and must return before any other call is done
+        QMutexLocker locker(&m_cancelMutex);
         m_dataSize = 0;
         m_readStatus = READ_ON_GOING;
         m_saneStartDone = false;
-        
+
+        locker.unlock();
         // Start the scanning with sane_start
         m_saneStatus = sane_start(m_saneHandle);
+        // if sane_cancel is called do not continue before it is done.
+        locker.relock();
         
+        m_saneStartDone = true;
+                
         if (m_readStatus == READ_CANCEL) {
             return;
         }
         
-        m_saneStartDone = true;
-        
         if (m_saneStatus != SANE_STATUS_GOOD) {
             kDebug() << "sane_start=" << sane_strstatus(m_saneStatus);
             m_readStatus = READ_ERROR;
@@ -146,7 +160,7 @@
     
     void KSaneScanThread::readData()
     {
-        SANE_Int readBytes;
+        SANE_Int readBytes = 0;
         m_saneStatus = sane_read(m_saneHandle, m_readData, SCAN_READ_CHUNK_SIZE, &readBytes);
         
         switch (m_saneStatus) 
@@ -157,8 +171,12 @@
                 
             case SANE_STATUS_EOF:
                 if (m_frameRead < m_frameSize) {
-                    kDebug() << "frameRead =" << m_frameRead  << ", frameSize =" << m_frameSize;
-                    m_readStatus = READ_ERROR;
+                    kDebug() << "frameRead =" << m_frameRead  << ", frameSize =" << m_frameSize << "readBytes =" << readBytes;
+                    if ((readBytes > 0) && ((m_frameRead + readBytes) <= m_frameSize)) {
+                        kDebug() << "This is not a standard compliant backend";
+                        copyToScanData(readBytes);
+                    }
+                    m_readStatus = READ_READY; // It is better to return a broken image than nothing
                     return;
                 }
                 if (m_params.last_frame == SANE_TRUE) {
@@ -181,7 +199,7 @@
                         sane_cancel(m_saneHandle);
                         return;
                     }
-                    kDebug() << "New Frame";
+                    //kDebug() << "New Frame";
                     m_frameRead = 0;
                     m_frame_t_count++;
                     break;
Index: libs/libksane/libksane/CMakeLists.txt
===================================================================
--- libs/libksane/libksane/CMakeLists.txt	(révision 1122317)
+++ libs/libksane/libksane/CMakeLists.txt	(copie de travail)
@@ -42,6 +42,12 @@
 
 SET_TARGET_PROPERTIES(ksane PROPERTIES VERSION ${KSANE_LIB_SO_VERSION_STRING} SOVERSION ${KSANE_LIB_SO_CUR_VERSION})
 
+if ("$ENV{COMPILE_VIEWER_TESTAPP}" STREQUAL "YES")
+    message("Compile testapp")
+    kde4_add_executable(viewer_test ksane_viewer.cpp ksane_viewer_test.cpp selectionitem.cpp)
+    target_link_libraries(viewer_test ${KDE4_KDEUI_LIBS})
+endif()
+
 install(TARGETS ksane ${INSTALL_TARGETS_DEFAULT_ARGS} )
 
 INSTALL(FILES ksane.h
