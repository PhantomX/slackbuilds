diff --git a/configure.ac b/configure.ac
index 2d922f6..2b1b210 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1518,7 +1518,7 @@ for plat in $egl_platforms; do
 		;;
 
 	wayland)
-		PKG_CHECK_MODULES([WAYLAND], [wayland-client wayland-server],, \
+		PKG_CHECK_MODULES([WAYLAND], [wayland-client >= 0.99.0 wayland-server >= 0.99.0],, \
 				  [AC_MSG_ERROR([cannot find libwayland-client])])
 		GALLIUM_WINSYS_DIRS="$GALLIUM_WINSYS_DIRS sw/wayland"
 
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 81c1354..3c42338 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -122,8 +122,10 @@ struct dri2_egl_display
 
 #ifdef HAVE_WAYLAND_PLATFORM
    struct wl_display        *wl_dpy;
+   struct wl_registry       *wl_registry;
    struct wl_drm            *wl_server_drm;
    struct wl_drm            *wl_drm;
+   struct wl_event_queue    *wl_queue;
    int			     authenticated;
    int			     formats;
 #endif
@@ -174,7 +176,7 @@ struct dri2_egl_surface
    __DRIbuffer           *dri_buffers[__DRI_BUFFER_COUNT];
    __DRIbuffer           *third_buffer;
    __DRIbuffer           *pending_buffer;
-   EGLBoolean             block_swap_buffers;
+   struct wl_callback    *frame_callback;
    int			  format;
 #endif
 
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index d291f0f..dcf3601 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -46,6 +46,34 @@ enum wl_drm_format_flags {
 };
 
 static void
+sync_callback(void *data, struct wl_callback *callback, uint32_t serial)
+{
+   int *done = data;
+
+   *done = 1;
+   wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener sync_listener = {
+   sync_callback
+};
+
+static int
+roundtrip(struct dri2_egl_display *dri2_dpy)
+{
+   struct wl_callback *callback;
+   int done = 0, ret = 0;
+
+   callback = wl_display_sync(dri2_dpy->wl_dpy);
+   wl_callback_add_listener(callback, &sync_listener, &done);
+   wl_proxy_set_queue((struct wl_proxy *) callback, dri2_dpy->wl_queue);
+   while (ret != -1 && !done)
+      ret = wl_display_dispatch_queue(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
+
+   return ret;
+}
+
+static void
 wl_buffer_release(void *data, struct wl_buffer *buffer)
 {
    struct dri2_egl_surface *dri2_surf = data;
@@ -80,7 +108,6 @@ dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_config *dri2_conf = dri2_egl_config(conf);
    struct dri2_egl_surface *dri2_surf;
-   struct dri2_egl_buffer *dri2_buf;
    int i;
 
    (void) drv;
@@ -104,7 +131,7 @@ dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
 
    dri2_surf->pending_buffer = NULL;
    dri2_surf->third_buffer = NULL;
-   dri2_surf->block_swap_buffers = EGL_FALSE;
+   dri2_surf->frame_callback = NULL;
 
    if (conf->AlphaSize == 0)
       dri2_surf->format = WL_DRM_FORMAT_XRGB8888;
@@ -118,17 +145,6 @@ dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
       dri2_surf->base.Width =  -1;
       dri2_surf->base.Height = -1;
       break;
-   case EGL_PIXMAP_BIT:
-      dri2_surf->wl_pix = (struct wl_egl_pixmap *) window;
-
-      dri2_surf->base.Width  = dri2_surf->wl_pix->width;
-      dri2_surf->base.Height = dri2_surf->wl_pix->height;
-
-      if (dri2_surf->wl_pix->driver_private) {
-         dri2_buf = dri2_surf->wl_pix->driver_private;
-         dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT] = dri2_buf->dri_buffer;
-      }
-      break;
    default: 
       goto cleanup_surf;
    }
@@ -166,15 +182,6 @@ dri2_create_window_surface(_EGLDriver *drv, _EGLDisplay *disp,
 			      window, attrib_list);
 }
 
-static _EGLSurface *
-dri2_create_pixmap_surface(_EGLDriver *drv, _EGLDisplay *disp,
-			   _EGLConfig *conf, EGLNativePixmapType pixmap,
-			   const EGLint *attrib_list)
-{
-   return dri2_create_surface(drv, disp, EGL_PIXMAP_BIT, conf,
-			      pixmap, attrib_list);
-}
-
 /**
  * Called via eglDestroySurface(), drv->API.DestroySurface().
  */
@@ -197,8 +204,7 @@ dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
          wl_buffer_destroy(dri2_surf->wl_drm_buffer[i]);
 
    for (i = 0; i < __DRI_BUFFER_COUNT; ++i)
-      if (dri2_surf->dri_buffers[i] && !(i == __DRI_BUFFER_FRONT_LEFT &&
-          dri2_surf->base.Type == EGL_PIXMAP_BIT))
+      if (dri2_surf->dri_buffers[i])
          dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
                                        dri2_surf->dri_buffers[i]);
 
@@ -212,22 +218,6 @@ dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
    return EGL_TRUE;
 }
 
-static void
-dri2_wl_egl_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
-{
-   struct dri2_egl_buffer *dri2_buf = egl_pixmap->driver_private;
-
-   assert(dri2_buf);
-
-   dri2_buf->dri2_dpy->dri2->releaseBuffer(dri2_buf->dri2_dpy->dri_screen,
-                                           dri2_buf->dri_buffer);
-
-   free(dri2_buf);
-   
-   egl_pixmap->driver_private = NULL;
-   egl_pixmap->destroy = NULL;
-}
-
 static struct wl_buffer *
 wayland_create_buffer(struct dri2_egl_surface *dri2_surf,
                       __DRIbuffer *buffer)
@@ -268,30 +258,6 @@ dri2_process_back_buffer(struct dri2_egl_surface *dri2_surf, unsigned format)
 }
 
 static void
-dri2_process_front_buffer(struct dri2_egl_surface *dri2_surf, unsigned format)
-{
-   struct dri2_egl_display *dri2_dpy =
-      dri2_egl_display(dri2_surf->base.Resource.Display);
-   struct dri2_egl_buffer *dri2_buf;
-
-   switch (dri2_surf->base.Type) {
-   case EGL_PIXMAP_BIT:
-      dri2_buf = malloc(sizeof *dri2_buf);
-      if (!dri2_buf)
-         return;
-
-      dri2_buf->dri_buffer = dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT];
-      dri2_buf->dri2_dpy   = dri2_dpy;
-
-      dri2_surf->wl_pix->driver_private = dri2_buf;
-      dri2_surf->wl_pix->destroy        = dri2_wl_egl_pixmap_destroy;
-      break;
-   default:
-      break;
-   }
-}
-
-static void
 dri2_release_pending_buffer(void *data,
 			    struct wl_callback *callback, uint32_t time)
 {
@@ -333,11 +299,13 @@ dri2_release_buffers(struct dri2_egl_surface *dri2_surf)
          switch (i) {
          case __DRI_BUFFER_FRONT_LEFT:
             if (dri2_surf->pending_buffer)
-	      wl_display_roundtrip(dri2_dpy->wl_dpy);
+               roundtrip(dri2_dpy);
             dri2_surf->pending_buffer = dri2_surf->dri_buffers[i];
             callback = wl_display_sync(dri2_dpy->wl_dpy);
 	    wl_callback_add_listener(callback,
 				     &release_buffer_listener, dri2_surf);
+            wl_proxy_set_queue((struct wl_proxy *) callback,
+                               dri2_dpy->wl_queue);
             break;
          default:
             dri2_dpy->dri2->releaseBuffer(dri2_dpy->dri_screen,
@@ -466,9 +434,7 @@ dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
          if (!dri2_surf->dri_buffers[attachments[i]]) 
             continue;
 
-         if (attachments[i] == __DRI_BUFFER_FRONT_LEFT)
-            dri2_process_front_buffer(dri2_surf, attachments[i+1]);
-         else if (attachments[i] == __DRI_BUFFER_BACK_LEFT)
+         if (attachments[i] == __DRI_BUFFER_BACK_LEFT)
             dri2_process_back_buffer(dri2_surf, attachments[i+1]);
       }
 
@@ -479,13 +445,7 @@ dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
       dri2_surf->buffer_count++;
    }
 
-   assert(dri2_surf->base.Type == EGL_PIXMAP_BIT ||
-          dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);
-
-   if (dri2_surf->base.Type == EGL_PIXMAP_BIT && !dri2_surf->wl_pix->buffer)
-      dri2_surf->wl_pix->buffer =
-         wayland_create_buffer(dri2_surf,
-			       dri2_surf->dri_buffers[__DRI_BUFFER_FRONT_LEFT]);
+   assert(dri2_surf->dri_buffers[__DRI_BUFFER_BACK_LEFT]);
 
    *out_count = dri2_surf->buffer_count;
    if (dri2_surf->buffer_count == 0)
@@ -552,7 +512,7 @@ wayland_frame_callback(void *data, struct wl_callback *callback, uint32_t time)
 {
    struct dri2_egl_surface *dri2_surf = data;
 
-   dri2_surf->block_swap_buffers = EGL_FALSE;
+   dri2_surf->frame_callback = NULL;
    wl_callback_destroy(callback);
 }
 
@@ -569,17 +529,18 @@ dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
    struct dri2_egl_driver *dri2_drv = dri2_egl_driver(drv);
-   struct wl_callback *callback;
+   int ret = 0;
 
-   if (dri2_surf->block_swap_buffers) {
-      wl_display_flush(dri2_dpy->wl_dpy);
-      while (dri2_surf->block_swap_buffers)
-         wl_display_iterate(dri2_dpy->wl_dpy, WL_DISPLAY_READABLE);
-   }
+   while (dri2_surf->frame_callback && ret != -1)
+      ret = wl_display_dispatch_queue(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
+   if (ret < 0)
+      return EGL_FALSE;
 
-   dri2_surf->block_swap_buffers = EGL_TRUE;
-   callback = wl_surface_frame(dri2_surf->wl_win->surface);
-   wl_callback_add_listener(callback, &frame_listener, dri2_surf);
+   dri2_surf->frame_callback = wl_surface_frame(dri2_surf->wl_win->surface);
+   wl_callback_add_listener(dri2_surf->frame_callback,
+                            &frame_listener, dri2_surf);
+   wl_proxy_set_queue((struct wl_proxy *) dri2_surf->frame_callback,
+                      dri2_dpy->wl_queue);
 
    if (dri2_surf->base.Type == EGL_WINDOW_BIT) {
       pointer_swap(
@@ -611,6 +572,8 @@ dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
 
       wl_surface_damage(dri2_surf->wl_win->surface, 0, 0,
 	    dri2_surf->base.Width, dri2_surf->base.Height);
+
+      wl_surface_commit(dri2_surf->wl_win->surface);
    }
 
    _EGLContext *ctx;
@@ -626,71 +589,6 @@ dri2_swap_buffers(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *draw)
    return EGL_TRUE;
 }
 
-/**
- * Called via eglCreateImageKHR(), drv->API.CreateImageKHR().
- */
-static _EGLImage *
-dri2_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
-			     EGLClientBuffer buffer, const EGLint *attr_list)
-{
-   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-   struct wl_egl_pixmap *wl_egl_pixmap = (struct wl_egl_pixmap *) buffer;
-   struct dri2_egl_buffer *dri2_buf;
-   EGLint wl_attr_list[] = {
-		EGL_WIDTH,		0,
-		EGL_HEIGHT,		0,
-		EGL_DRM_BUFFER_STRIDE_MESA,	0,
-		EGL_DRM_BUFFER_FORMAT_MESA,	EGL_DRM_BUFFER_FORMAT_ARGB32_MESA,
-		EGL_NONE
-   };
-
-   dri2_buf = malloc(sizeof *dri2_buf);
-   if (!dri2_buf)
-           return NULL;
-
-   dri2_buf->dri2_dpy = dri2_dpy;
-   dri2_buf->dri_buffer =
-      dri2_dpy->dri2->allocateBuffer(dri2_dpy->dri_screen,
-				     __DRI_BUFFER_FRONT_LEFT, 32,
-				     wl_egl_pixmap->width,
-				     wl_egl_pixmap->height);
-
-   wl_egl_pixmap->destroy = dri2_wl_egl_pixmap_destroy;
-   wl_egl_pixmap->driver_private = dri2_buf;
-
-   /* FIXME: Get buffer format from attr_list somehow... or from the
-      wl_egl_piaxmap.  */
-   wl_egl_pixmap->buffer =
-      wl_drm_create_buffer(dri2_dpy->wl_drm,
-			   dri2_buf->dri_buffer->name,
-			   wl_egl_pixmap->width,
-			   wl_egl_pixmap->height,
-			   dri2_buf->dri_buffer->pitch,
-			   WL_DRM_FORMAT_ARGB8888);
-
-   wl_attr_list[1] = wl_egl_pixmap->width;
-   wl_attr_list[3] = wl_egl_pixmap->height;
-   wl_attr_list[5] = dri2_buf->dri_buffer->pitch / 4;
-
-   return dri2_create_image_khr(disp->Driver, disp, ctx, EGL_DRM_BUFFER_MESA,
-	(EGLClientBuffer)(intptr_t) dri2_buf->dri_buffer->name, wl_attr_list);
-}
-
-static _EGLImage *
-dri2_wayland_create_image_khr(_EGLDriver *drv, _EGLDisplay *disp,
-			      _EGLContext *ctx, EGLenum target,
-			      EGLClientBuffer buffer, const EGLint *attr_list)
-{
-   (void) drv;
-
-   switch (target) {
-   case EGL_NATIVE_PIXMAP_KHR:
-      return dri2_create_image_khr_pixmap(disp, ctx, buffer, attr_list);
-   default:
-      return dri2_create_image_khr(drv, disp, ctx, target, buffer, attr_list);
-   }
-}
-
 static int
 dri2_wayland_authenticate(_EGLDisplay *disp, uint32_t id)
 {
@@ -700,7 +598,8 @@ dri2_wayland_authenticate(_EGLDisplay *disp, uint32_t id)
    dri2_dpy->authenticated = 0;
 
    wl_drm_authenticate(dri2_dpy->wl_drm, id);
-   wl_display_roundtrip(dri2_dpy->wl_dpy);
+   if (roundtrip(dri2_dpy) < 0)
+      ret = -1;
 
    if (!dri2_dpy->authenticated)
       ret = -1;
@@ -795,22 +694,37 @@ static const struct wl_drm_listener drm_listener = {
 	drm_handle_authenticated
 };
 
+static void
+registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
+		       const char *interface, uint32_t version)
+{
+   struct dri2_egl_display *dri2_dpy = data;
+
+   if (strcmp(interface, "wl_drm") == 0) {
+      dri2_dpy->wl_drm =
+         wl_registry_bind(registry, name, &wl_drm_interface, 1);
+      wl_drm_add_listener(dri2_dpy->wl_drm, &drm_listener, dri2_dpy);
+   }
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global
+};
+
 EGLBoolean
 dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
 {
    struct dri2_egl_display *dri2_dpy;
    const __DRIconfig *config;
-   uint32_t id, types;
+   uint32_t types;
    int i;
    static const unsigned int argb_masks[4] =
       { 0xff0000, 0xff00, 0xff, 0xff000000 };
    static const unsigned int rgb_masks[4] = { 0xff0000, 0xff00, 0xff, 0 };
 
    drv->API.CreateWindowSurface = dri2_create_window_surface;
-   drv->API.CreatePixmapSurface = dri2_create_pixmap_surface;
    drv->API.DestroySurface = dri2_destroy_surface;
    drv->API.SwapBuffers = dri2_swap_buffers;
-   drv->API.CreateImageKHR = dri2_wayland_create_image_khr;
    drv->API.Terminate = dri2_terminate;
 
    dri2_dpy = malloc(sizeof *dri2_dpy);
@@ -829,22 +743,19 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
       dri2_dpy->wl_dpy = disp->PlatformDisplay;
    }
 
-   id = wl_display_get_global(dri2_dpy->wl_dpy, "wl_drm", 1);
-   if (id == 0)
-      wl_display_roundtrip(dri2_dpy->wl_dpy);
-   id = wl_display_get_global(dri2_dpy->wl_dpy, "wl_drm", 1);
-   if (id == 0)
+   dri2_dpy->wl_queue = wl_display_create_queue(dri2_dpy->wl_dpy);
+   dri2_dpy->wl_registry = wl_display_get_registry(dri2_dpy->wl_dpy);
+   wl_proxy_set_queue((struct wl_proxy *) dri2_dpy->wl_registry,
+                      dri2_dpy->wl_queue);
+   wl_registry_add_listener(dri2_dpy->wl_registry,
+                            &registry_listener, dri2_dpy);
+   if (roundtrip(dri2_dpy) < 0 || dri2_dpy->wl_drm == NULL)
       goto cleanup_dpy;
-   dri2_dpy->wl_drm = wl_display_bind(dri2_dpy->wl_dpy, id, &wl_drm_interface);
-   if (!dri2_dpy->wl_drm)
-      goto cleanup_dpy;
-   wl_drm_add_listener(dri2_dpy->wl_drm, &drm_listener, dri2_dpy);
-   wl_display_roundtrip(dri2_dpy->wl_dpy);
-   if (dri2_dpy->fd == -1)
+
+   if (roundtrip(dri2_dpy) < 0 || dri2_dpy->fd == -1)
       goto cleanup_drm;
 
-   wl_display_roundtrip(dri2_dpy->wl_dpy);
-   if (!dri2_dpy->authenticated)
+   if (roundtrip(dri2_dpy) < 0 || !dri2_dpy->authenticated)
       goto cleanup_fd;
 
    dri2_dpy->driver_name = dri2_get_driver_for_fd(dri2_dpy->fd);
@@ -871,7 +782,7 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
    if (!dri2_create_screen(disp))
       goto cleanup_driver;
 
-   types = EGL_WINDOW_BIT | EGL_PIXMAP_BIT;
+   types = EGL_WINDOW_BIT;
    for (i = 0; dri2_dpy->driver_configs[i]; i++) {
       config = dri2_dpy->driver_configs[i];
       if (dri2_dpy->formats & HAS_XRGB8888)
@@ -880,8 +791,6 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
 	 dri2_add_config(disp, config, i + 1, 0, types, NULL, argb_masks);
    }
 
-   disp->Extensions.KHR_image_pixmap = EGL_TRUE;
-
    disp->Extensions.WL_bind_wayland_display = EGL_TRUE;
    dri2_dpy->authenticate = dri2_wayland_authenticate;
 
diff --git a/src/egl/wayland/wayland-egl/wayland-egl-priv.h b/src/egl/wayland/wayland-egl/wayland-egl-priv.h
index accd2dd..bdbf32a 100644
--- a/src/egl/wayland/wayland-egl/wayland-egl-priv.h
+++ b/src/egl/wayland/wayland-egl/wayland-egl-priv.h
@@ -26,17 +26,6 @@ struct wl_egl_window {
 	int attached_height;
 };
 
-struct wl_egl_pixmap {
-	struct wl_buffer *buffer;
-
-	int width;
-	int height;
-
-	void (*destroy) (struct wl_egl_pixmap *egl_pixmap);
-
-	void *driver_private;
-};
-
 #ifdef  __cplusplus
 }
 #endif
diff --git a/src/egl/wayland/wayland-egl/wayland-egl.c b/src/egl/wayland/wayland-egl/wayland-egl.c
index e950b4a..c61fb4f 100644
--- a/src/egl/wayland/wayland-egl/wayland-egl.c
+++ b/src/egl/wayland/wayland-egl/wayland-egl.c
@@ -48,36 +48,3 @@ wl_egl_window_get_attached_size(struct wl_egl_window *egl_window,
 	if (height)
 		*height = egl_window->attached_height;
 }
-
-WL_EGL_EXPORT struct wl_egl_pixmap *
-wl_egl_pixmap_create(int width, int height, uint32_t flags)
-{
-	struct wl_egl_pixmap *egl_pixmap;
-
-	egl_pixmap = malloc(sizeof *egl_pixmap);
-	if (egl_pixmap == NULL)
-		return NULL;
-
-	egl_pixmap->width   = width;
-	egl_pixmap->height  = height;
-
-	egl_pixmap->destroy = NULL;
-	egl_pixmap->buffer  = NULL;
-	egl_pixmap->driver_private = NULL;
-
-	return egl_pixmap;
-}
-
-WL_EGL_EXPORT void
-wl_egl_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
-{
-	if (egl_pixmap->destroy)
-		egl_pixmap->destroy(egl_pixmap);
-	free(egl_pixmap);
-}
-
-WL_EGL_EXPORT struct wl_buffer *
-wl_egl_pixmap_create_buffer(struct wl_egl_pixmap *egl_pixmap)
-{
-	return egl_pixmap->buffer;
-}
diff --git a/src/gallium/state_trackers/egl/wayland/native_drm.c b/src/gallium/state_trackers/egl/wayland/native_drm.c
index c6f6197..4671e33 100644
--- a/src/gallium/state_trackers/egl/wayland/native_drm.c
+++ b/src/gallium/state_trackers/egl/wayland/native_drm.c
@@ -182,35 +182,43 @@ static const struct wl_drm_listener drm_listener = {
    drm_handle_authenticated
 };
 
+static void
+registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
+                       const char *interface, uint32_t version)
+{
+   struct wayland_drm_display *drmdpy = data;
+
+   if (strcmp(interface, "wl_drm") == 0) {
+      drmdpy->wl_drm = wl_registry_bind(registry, name, &wl_drm_interface, 1);
+      wl_drm_add_listener(drmdpy->wl_drm, &drm_listener, drmdpy);
+   }
+}
+
+static const struct wl_registry_listener registry_listener = {
+       registry_handle_global
+};
+
 static boolean
 wayland_drm_display_init_screen(struct native_display *ndpy)
 {
    struct wayland_drm_display *drmdpy = wayland_drm_display(ndpy);
-   uint32_t id;
-
-   id = wl_display_get_global(drmdpy->base.dpy, "wl_drm", 1);
-   if (id == 0)
-      wl_display_roundtrip(drmdpy->base.dpy);
-   id = wl_display_get_global(drmdpy->base.dpy, "wl_drm", 1);
-   if (id == 0)
-      return FALSE;
 
-   drmdpy->wl_drm = wl_display_bind(drmdpy->base.dpy, id, &wl_drm_interface);
-   if (!drmdpy->wl_drm)
+   drmdpy->base.queue = wl_display_create_queue(drmdpy->base.dpy);
+   drmdpy->base.registry = wl_display_get_registry(drmdpy->base.dpy);
+   wl_proxy_set_queue((struct wl_proxy *) drmdpy->base.registry,
+                      drmdpy->base.queue);
+   wl_registry_add_listener(drmdpy->base.registry, &registry_listener, drmdpy);
+   if (wayland_roundtrip(&drmdpy->base) < 0 || drmdpy->wl_drm == NULL)
       return FALSE;
 
    wl_drm_add_listener(drmdpy->wl_drm, &drm_listener, drmdpy);
-   wl_display_roundtrip(drmdpy->base.dpy);
-   if (drmdpy->fd == -1)
+   if (wayland_roundtrip(&drmdpy->base) < 0 || drmdpy->fd == -1)
       return FALSE;
 
-   wl_display_roundtrip(drmdpy->base.dpy);
-   if (!drmdpy->authenticated)
+   if (wayland_roundtrip(&drmdpy->base) < 0 || !drmdpy->authenticated)
       return FALSE;
 
    if (drmdpy->base.formats == 0)
-      wl_display_roundtrip(drmdpy->base.dpy);
-   if (drmdpy->base.formats == 0)
       return FALSE;
 
    drmdpy->base.base.screen =
diff --git a/src/gallium/state_trackers/egl/wayland/native_shm.c b/src/gallium/state_trackers/egl/wayland/native_shm.c
index 574ffce..5ffe485 100644
--- a/src/gallium/state_trackers/egl/wayland/native_shm.c
+++ b/src/gallium/state_trackers/egl/wayland/native_shm.c
@@ -133,26 +133,36 @@ static const struct wl_shm_listener shm_listener = {
    shm_handle_format
 };
 
+static void
+registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
+                       const char *interface, uint32_t version)
+{
+   struct wayland_shm_display *shmdpy = data;
+
+   if (strcmp(interface, "wl_shm") == 0) {
+      shmdpy->wl_shm = wl_registry_bind(registry, name, &wl_shm_interface, 1);
+      wl_shm_add_listener(shmdpy->wl_shm, &shm_listener, shmdpy);
+   }
+}
+
+static const struct wl_registry_listener registry_listener = {
+       registry_handle_global
+};
+
 static boolean
 wayland_shm_display_init_screen(struct native_display *ndpy)
 {
    struct wayland_shm_display *shmdpy = wayland_shm_display(ndpy);
    struct sw_winsys *winsys = NULL;
-   uint32_t id;
 
-   id = wl_display_get_global(shmdpy->base.dpy, "wl_shm", 1);
-   if (id == 0)
-      wl_display_iterate(shmdpy->base.dpy, WL_DISPLAY_READABLE);
-   id = wl_display_get_global(shmdpy->base.dpy, "wl_shm", 1);
-   if (id == 0)
+   shmdpy->base.queue = wl_display_create_queue(shmdpy->base.dpy);
+   shmdpy->base.registry = wl_display_get_registry(shmdpy->base.dpy);
+   wl_proxy_set_queue((struct wl_proxy *) shmdpy->base.registry,
+                      shmdpy->base.queue);
+   wl_registry_add_listener(shmdpy->base.registry, &registry_listener, shmdpy);
+   if (wayland_roundtrip(&shmdpy->base) < 0 || shmdpy->wl_shm == NULL)
       return FALSE;
 
-   shmdpy->wl_shm = wl_display_bind(shmdpy->base.dpy, id, &wl_shm_interface);
-   if (!shmdpy->wl_shm)
-      return FALSE;
-
-   wl_shm_add_listener(shmdpy->wl_shm, &shm_listener, shmdpy);
-
    if (shmdpy->base.formats == 0)
       wl_display_roundtrip(shmdpy->base.dpy);
    if (shmdpy->base.formats == 0)
diff --git a/src/gallium/state_trackers/egl/wayland/native_wayland.c b/src/gallium/state_trackers/egl/wayland/native_wayland.c
index a7f9cb7..62c87f3 100644
--- a/src/gallium/state_trackers/egl/wayland/native_wayland.c
+++ b/src/gallium/state_trackers/egl/wayland/native_wayland.c
@@ -35,6 +35,34 @@
 
 #include "native_wayland.h"
 
+static void
+sync_callback(void *data, struct wl_callback *callback, uint32_t serial)
+{
+   int *done = data;
+
+   *done = 1;
+   wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener sync_listener = {
+   sync_callback
+};
+
+int
+wayland_roundtrip(struct wayland_display *display)
+{
+   struct wl_callback *callback;
+   int done = 0, ret = 0;
+
+   callback = wl_display_sync(display->dpy);
+   wl_callback_add_listener(callback, &sync_listener, &done);
+   wl_proxy_set_queue((struct wl_proxy *) callback, display->queue);
+   while (ret == 0 && !done)
+      ret = wl_display_dispatch_queue(display->dpy, display->queue);
+
+   return ret;
+}
+
 static const struct native_event_handler *wayland_event_handler;
 
 const static struct {
@@ -71,7 +99,6 @@ wayland_display_get_configs(struct native_display *ndpy, int *num_configs)
             (1 << NATIVE_ATTACHMENT_BACK_LEFT);
          
          nconf->window_bit = TRUE;
-         nconf->pixmap_bit = TRUE;
          
          nconf->color_format = wayland_formats[i].format;
          display->num_configs++;
@@ -93,7 +120,6 @@ static int
 wayland_display_get_param(struct native_display *ndpy,
                           enum native_param_type param)
 {
-   struct wayland_display *display = wayland_display(ndpy);
    int val;
 
    switch (param) {
@@ -111,49 +137,6 @@ wayland_display_get_param(struct native_display *ndpy,
    return val;
 }
 
-static boolean
-wayland_display_get_pixmap_format(struct native_display *ndpy,
-                                  EGLNativePixmapType pix,
-                                  enum pipe_format *format)
-{
-   /* all wl_egl_pixmaps are supported */
-   *format = PIPE_FORMAT_NONE;
-
-   return TRUE;
-}
-
-static void
-wayland_pixmap_destroy(struct wl_egl_pixmap *egl_pixmap)
-{
-   struct pipe_resource *resource = egl_pixmap->driver_private;
-
-   assert(resource);
-
-   pipe_resource_reference(&resource, NULL);
-   if (egl_pixmap->buffer) {
-      wl_buffer_destroy(egl_pixmap->buffer);
-      egl_pixmap->buffer = NULL;
-   }
-
-   egl_pixmap->driver_private = NULL;
-   egl_pixmap->destroy = NULL;
-}
-
-static void
-wayland_pixmap_surface_initialize(struct wayland_surface *surface)
-{
-   struct wayland_display *display = wayland_display(&surface->display->base);
-   const enum native_attachment front_natt = NATIVE_ATTACHMENT_FRONT_LEFT;
-
-   if (surface->pix->buffer != NULL)
-      return;
-
-   surface->pix->buffer  = display->create_buffer(display, surface, front_natt);
-   surface->pix->destroy = wayland_pixmap_destroy;
-   surface->pix->driver_private =
-      resource_surface_get_single_resource(surface->rsurf, front_natt);
-}
-
 static void
 wayland_release_pending_resource(void *data,
                                  struct wl_callback *callback,
@@ -188,7 +171,7 @@ wayland_window_surface_handle_resize(struct wayland_surface *surface)
                                  surface->win->width, surface->win->height)) {
 
       if (surface->pending_resource)
-         wl_display_roundtrip(display->dpy);
+         wayland_roundtrip(display);
 
       if (front_resource) {
          struct wl_callback *callback;
@@ -198,6 +181,7 @@ wayland_window_surface_handle_resize(struct wayland_surface *surface)
 
          callback = wl_display_sync(display->dpy);
          wl_callback_add_listener(callback, &release_buffer_listener, surface);
+         wl_proxy_set_queue((struct wl_proxy *) callback, display->queue);
       }
 
       for (i = 0; i < WL_BUFFER_COUNT; ++i) {
@@ -234,9 +218,6 @@ wayland_surface_validate(struct native_surface *nsurf, uint attachment_mask,
 
    resource_surface_get_size(surface->rsurf, (uint *) width, (uint *) height);
 
-   if (surface->type == WL_PIXMAP_SURFACE)
-      wayland_pixmap_surface_initialize(surface);
-
    return TRUE;
 }
 
@@ -245,7 +226,7 @@ wayland_frame_callback(void *data, struct wl_callback *callback, uint32_t time)
 {
    struct wayland_surface *surface = data;
 
-   surface->block_swap_buffers = FALSE;
+   surface->frame_callback = NULL;
 
    wl_callback_destroy(callback);
 }
@@ -269,15 +250,17 @@ wayland_surface_swap_buffers(struct native_surface *nsurf)
 {
    struct wayland_surface *surface = wayland_surface(nsurf);
    struct wayland_display *display = surface->display;
-   struct wl_callback *callback;
+   int ret = 0;
 
-   while (surface->block_swap_buffers)
-      wl_display_iterate(display->dpy, WL_DISPLAY_READABLE);
+   while (surface->frame_callback && ret != -1)
+      ret = wl_display_dispatch_queue(display->dpy, display->queue);
+   if (ret == -1)
+      return EGL_FALSE;
 
-   surface->block_swap_buffers = TRUE;
-
-   callback = wl_surface_frame(surface->win->surface);
-   wl_callback_add_listener(callback, &frame_listener, surface);
+   surface->frame_callback = wl_surface_frame(surface->win->surface);
+   wl_callback_add_listener(surface->frame_callback, &frame_listener, surface);
+   wl_proxy_set_queue((struct wl_proxy *) surface->frame_callback,
+                      display->queue);
 
    if (surface->type == WL_WINDOW_SURFACE) {
       resource_surface_swap_buffers(surface->rsurf,
@@ -349,6 +332,7 @@ wayland_surface_present(struct native_surface *nsurf,
    if (surface->type == WL_WINDOW_SURFACE) {
       resource_surface_get_size(surface->rsurf, &width, &height);
       wl_surface_damage(surface->win->surface, 0, 0, width, height);
+      wl_surface_commit(surface->win->surface);
    }
 
    return ret;
@@ -376,61 +360,6 @@ wayland_surface_destroy(struct native_surface *nsurf)
 }
 
 
-
-static struct native_surface *
-wayland_create_pixmap_surface(struct native_display *ndpy,
-                              EGLNativePixmapType pix,
-                              const struct native_config *nconf)
-{
-   struct wayland_display *display = wayland_display(ndpy);
-   struct wayland_surface *surface;
-   struct wl_egl_pixmap *egl_pixmap = (struct wl_egl_pixmap *) pix;
-   enum native_attachment natt = NATIVE_ATTACHMENT_FRONT_LEFT;
-   uint bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW |
-      PIPE_BIND_DISPLAY_TARGET | PIPE_BIND_SCANOUT;
-
-   surface = CALLOC_STRUCT(wayland_surface);
-   if (!surface)
-      return NULL;
-
-   surface->display = display;
-
-   surface->pending_resource = NULL;
-   surface->type = WL_PIXMAP_SURFACE;
-   surface->pix = egl_pixmap;
-
-   if (nconf)
-      surface->color_format = nconf->color_format;
-   else /* FIXME: derive format from wl_visual */
-      surface->color_format = PIPE_FORMAT_B8G8R8A8_UNORM;
-
-   surface->attachment_mask = (1 << NATIVE_ATTACHMENT_FRONT_LEFT);
-
-   surface->rsurf = resource_surface_create(display->base.screen,
-                                            surface->color_format, bind);
-
-   if (!surface->rsurf) {
-      FREE(surface);
-      return NULL;
-   }
-
-   resource_surface_set_size(surface->rsurf,
-                             egl_pixmap->width, egl_pixmap->height);
-
-   /* the pixmap is already allocated, so import it */
-   if (surface->pix->buffer != NULL)
-      resource_surface_import_resource(surface->rsurf, natt,
-                                       surface->pix->driver_private);
-
-   surface->base.destroy = wayland_surface_destroy;
-   surface->base.present = wayland_surface_present;
-   surface->base.validate = wayland_surface_validate;
-   surface->base.wait = wayland_surface_wait;
-
-   return &surface->base;
-}
-
-
 static struct native_surface *
 wayland_create_window_surface(struct native_display *ndpy,
                               EGLNativeWindowType win,
@@ -452,7 +381,7 @@ wayland_create_window_surface(struct native_display *ndpy,
    surface->win = (struct wl_egl_window *) win;
 
    surface->pending_resource = NULL;
-   surface->block_swap_buffers = FALSE;
+   surface->frame_callback = NULL;
    surface->type = WL_WINDOW_SURFACE;
 
    surface->buffer[WL_BUFFER_FRONT] = NULL;
@@ -505,10 +434,7 @@ native_create_display(void *dpy, boolean use_sw)
 
    display->base.get_param = wayland_display_get_param;
    display->base.get_configs = wayland_display_get_configs;
-   display->base.get_pixmap_format = wayland_display_get_pixmap_format;
-   display->base.copy_to_pixmap = native_display_copy_to_pixmap;
    display->base.create_window_surface = wayland_create_window_surface;
-   display->base.create_pixmap_surface = wayland_create_pixmap_surface;
 
    display->own_dpy = own_dpy;
 
diff --git a/src/gallium/state_trackers/egl/wayland/native_wayland.h b/src/gallium/state_trackers/egl/wayland/native_wayland.h
index e6a914f..b623fee 100644
--- a/src/gallium/state_trackers/egl/wayland/native_wayland.h
+++ b/src/gallium/state_trackers/egl/wayland/native_wayland.h
@@ -45,6 +45,8 @@ struct wayland_display {
    struct native_display base;
 
    struct wl_display *dpy;
+   struct wl_event_queue *queue;
+   struct wl_registry *registry;
    boolean own_dpy;
    /* supported formats */
    uint32_t formats;
@@ -65,7 +67,6 @@ enum wayland_buffer_type {
 
 enum wayland_surface_type {
    WL_WINDOW_SURFACE,
-   WL_PIXMAP_SURFACE,
    WL_PBUFFER_SURFACE
 };
 
@@ -74,7 +75,6 @@ struct wayland_surface {
    struct wayland_display *display;
 
    struct wl_egl_window *win;
-   struct wl_egl_pixmap *pix;
    enum wayland_surface_type type;
    int dx, dy;
    struct resource_surface *rsurf;
@@ -85,7 +85,7 @@ struct wayland_surface {
    struct wl_buffer *buffer[WL_BUFFER_COUNT];
    unsigned int attachment_mask;
 
-   boolean block_swap_buffers;
+   struct wl_callback *frame_callback;
    boolean premultiplied_alpha;
 };
 
@@ -119,4 +119,7 @@ struct wayland_display *
 wayland_create_drm_display(struct wl_display *display,
                            const struct native_event_handler *event_handler);
 
+int
+wayland_roundtrip(struct wayland_display *drmdpy);
+
 #endif /* _NATIVE_WAYLAND_H_ */
