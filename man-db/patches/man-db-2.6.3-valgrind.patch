diff -up man-db-2.6.3/lib/encodings.c.valgrind-mem man-db-2.6.3/lib/encodings.c
--- man-db-2.6.3/lib/encodings.c.valgrind-mem	2013-04-05 18:19:01.402892699 +0200
+++ man-db-2.6.3/lib/encodings.c	2013-04-05 18:19:01.419892450 +0200
@@ -559,6 +559,7 @@ const char *get_locale_charset (void)
 
 	/* Restore LC_CTYPE to its value on entry to this function. */
 	setlocale (LC_CTYPE, saved_locale);
+	free (saved_locale);
 
 	if (charset && *charset)
 		return get_canonical_charset_name (charset);
@@ -596,9 +597,12 @@ char *find_charset_locale (const char *c
 			locale = xstrdup("en_US.UTF-8");
 			if (setlocale (LC_CTYPE, locale)) {
 				setlocale (LC_CTYPE, saved_locale);
+				free (saved_locale);
 				return locale;
 			}
 		}
+		free (saved_locale);
+		free (locale);
 		return NULL;
 	}
 
@@ -628,6 +632,7 @@ char *find_charset_locale (const char *c
 
 out:
 	setlocale (LC_CTYPE, saved_locale);
+	free (saved_locale);
 	fclose (supported);
 	return locale;
 }
diff -up man-db-2.6.3/src/check_mandirs.c.valgrind-mem man-db-2.6.3/src/check_mandirs.c
--- man-db-2.6.3/src/check_mandirs.c.valgrind-mem	2013-04-05 18:19:01.415892509 +0200
+++ man-db-2.6.3/src/check_mandirs.c	2013-04-05 18:19:01.420892435 +0200
@@ -479,11 +480,13 @@ static int testmandirs (const char *path
 				if (errno == EACCES || errno == EROFS) {
 					debug ("database %s is read-only\n",
 					       database);
+					closedir (dir);
 					return 0;
 				} else {
 					error (0, errno,
 					       _("can't create index cache %s"),
 					       database);
+					closedir (dir);
 					return -errno;
 				}
 			}
@@ -496,6 +499,7 @@ static int testmandirs (const char *path
 
 		if (!dbf) {
 			gripe_rwopen_failed ();
+			closedir (dir);
 			return 0;
 		}
 
diff -up man-db-2.6.3/src/manconv_client.c.valgrind-mem man-db-2.6.3/src/manconv_client.c
--- man-db-2.6.3/src/manconv_client.c.valgrind-mem	2011-01-04 04:04:50.000000000 +0100
+++ man-db-2.6.3/src/manconv_client.c	2013-04-05 18:40:45.360739910 +0200
@@ -111,8 +111,10 @@ void add_manconv (pipeline *p, const cha
 	char *name;
 	pipecmd *cmd;
 
-	if (STREQ (source, "UTF-8") && STREQ (target, "UTF-8"))
+	if (STREQ (source, "UTF-8") && STREQ (target, "UTF-8")) {
+		free (codes);
 		return;
+	}
 
 	/* informational only; no shell quoting concerns */
 	name = appendstr (NULL, MANCONV, " -f ", NULL);
diff -up man-db-2.6.3/src/man.c.valgrind-mem man-db-2.6.3/src/man.c
--- man-db-2.6.3/src/man.c.valgrind-mem	2013-04-05 18:19:01.408892611 +0200
+++ man-db-2.6.3/src/man.c	2013-04-05 18:40:56.233580113 +0200
@@ -188,7 +188,7 @@ static char *manpathlist[MAXDIRS];
 /* globals */
 int quiet = 1;
 char *program_name;
-char *database;
+char *database = NULL;
 MYDBM_FILE dbf; 
 extern const char *extension; /* for globbing.c */
 extern char *user_config_file;	/* defined in manp.c */
@@ -207,7 +207,7 @@ static char *internal_locale, *multiple_
 static const char *prompt_string;
 static char *less;
 static const char *std_sections[] = STD_SECTIONS;
-static char *manp;
+static char *manp = NULL;
 static const char *external;
 static struct hashtable *db_hash = NULL;
 
@@ -950,7 +950,7 @@ static int local_man_loop (const char *a
 
 			if (directory_on_path (argv_dir)) {
 				char *argv_base = base_name (argv);
-				char *new_manp;
+				char *new_manp, *nm;
 				char **old_manpathlist, **mp;
 
 				debug ("recalculating manpath for executable "
@@ -962,7 +962,9 @@ static int local_man_loop (const char *a
 					       "executable\n");
 					goto executable_out;
 				}
-				new_manp = locale_manpath (new_manp);
+				nm = locale_manpath (new_manp);
+				free (new_manp);
+				new_manp = nm;
 
 				old_manpathlist = XNMALLOC (MAXDIRS, char *);
 				memcpy (old_manpathlist, manpathlist,
@@ -1167,14 +1169,21 @@ int main (int argc, char *argv[])
 			manp = get_manpath ("");
 			printf ("%s\n", manp);
 			exit (OK);
-		} else
+		} else {
+			free (cwd);
+			free (internal_locale);
+			free (program_name);
 			gripe_no_name (NULL);
+		}
 	}
 
 	section_list = get_section_list ();
 
-	if (manp == NULL)
-		manp = locale_manpath (get_manpath (alt_system_name));
+	if (manp == NULL) {
+		char *mp = get_manpath (alt_system_name);
+		manp = locale_manpath (mp);
+		free (mp);
+	}
 	else
 		free (get_manpath (NULL));
 
@@ -1350,6 +1359,14 @@ int main (int argc, char *argv[])
 	if (cwd[0])
 		chdir (cwd);
 
+	if (database) {
+		free (database);
+		database = NULL;
+	}
+	if (manp) {
+		free (manp);
+		manp = NULL;
+	}
 	free_pathlist (manpathlist);
 	free (cwd);
 	free (internal_locale);
@@ -1810,6 +1827,9 @@ static pipeline *make_roff_command (cons
 		pipeline_command (p, cmd);
 	}
 
+	/* free pp_string */
+	get_preprocessors_from_file(NULL);
+
 	free (page_encoding);
 	return p;
 }
@@ -2327,6 +2347,7 @@ static void format_display (pipeline *de
 			       htmldir);
 		free (htmlfile);
 		free (htmldir);
+		free (old_cwd);
 	} else
 #endif /* TROFF_IS_GROFF */
 	/* TODO: check format_cmd status too? */
@@ -2498,6 +2519,7 @@ static int display (const char *dir, con
 				free (name);
 				free_locale_bits (&bits);
 			}
+			free (page_lang);
 		}
 #endif /* TROFF_IS_GROFF */
 
@@ -2564,6 +2586,7 @@ static int display (const char *dir, con
 			if (prompt && do_prompt (title)) {
 				pipeline_free (format_cmd);
 				pipeline_free (decomp);
+				free (formatted_encoding);
 				return 0;
 			}
 			drop_effective_privs ();
@@ -2690,6 +2713,7 @@ static int display (const char *dir, con
 			if (prompt && do_prompt (title)) {
 				pipeline_free (format_cmd);
 				pipeline_free (decomp);
+				free (formatted_encoding);
 				if (local_man_file)
 					return 1;
 				else
@@ -2741,6 +2765,8 @@ static int display (const char *dir, con
 		}
 	}
 
+	free (formatted_encoding);
+
 	pipeline_free (format_cmd);
 	pipeline_free (decomp);
 
@@ -2802,6 +2828,7 @@ static char *find_cat_file (const char *
 				*tmp = 0;
 			if (is_directory (cat_dir)) {
 				debug ("will try cat file %s\n", cat_file);
+				free (cat_dir);
 				return cat_file;
 			} else
 				debug ("cat dir %s does not exist\n", cat_dir);
@@ -3272,6 +3299,7 @@ static int try_section (const char *path
 		}
 	}
 
+	int f;
 	for (np = names; np && *np; np++) {
 		struct mandata *info = infoalloc ();
 		char *info_buffer = filename_info (*np, info, name);
@@ -3300,8 +3328,15 @@ static int try_section (const char *path
 		else
 			info->id = SO_MAN;
 
-		found += add_candidate (cand_head, CANDIDATE_FILESYSTEM,
+		f = add_candidate (cand_head, CANDIDATE_FILESYSTEM,
 					cat, name, path, ult, info);
+		found += f;
+		/* Free info and info_buffer if it wasn't added to the candidates. */
+		if (f == 0) {
+			free (info_buffer);
+			info->addr = NULL;
+			free_mandata_struct (info);
+		}
 		/* Don't free info and info_buffer here. */
 	}
 
@@ -3319,9 +3354,13 @@ static int display_filesystem (struct ca
 	char *title = appendstr (NULL, candp->source->name,
 				 "(", candp->source->ext, ")", NULL);
 	if (candp->cat) {
-		if (troff || want_encoding || recode)
+		if (troff || want_encoding || recode) {
+			free (title);
 			return 0;
-		return display (candp->path, NULL, filename, title, NULL);
+		}
+		int r = display (candp->path, NULL, filename, title, NULL);
+		free (title);
+		return r;
 	} else {
 		const char *man_file;
 		char *cat_file;
@@ -3344,6 +3383,7 @@ static int display_filesystem (struct ca
 		free (lang);
 		lang = NULL;
 		free (title);
+		free (filename);
 
 		return found;
 	}
@@ -3571,6 +3611,10 @@ static int try_db (const char *manpath,
 	/* find out where our db for this manpath should be */
 
 	catpath = get_catpath (manpath, global_manpath ? SYSTEM_CAT : USER_CAT);
+	if (database) {
+		free (database);
+		database = NULL;
+	}
 	if (catpath) {
 		database = mkdbname (catpath);
 		free (catpath);
@@ -3942,7 +3986,7 @@ static int man (const char *name, int *f
 
 	for (cand = candidates; cand; cand = candnext) {
 		candnext = cand->next;
-		free (cand);
+		free_candidate (cand);
 	}
 
 	return *found ? OK : NOT_FOUND;
diff -up man-db-2.6.3/src/mandb.c.valgrind-mem man-db-2.6.3/src/mandb.c
--- man-db-2.6.3/src/mandb.c.valgrind-mem	2012-02-21 12:15:11.000000000 +0100
+++ man-db-2.6.3/src/mandb.c	2013-04-05 18:19:01.425892362 +0200
@@ -247,7 +247,7 @@ static int xcopy (const char *from, cons
 	}
 
 	while (!feof (ifp) && !ferror (ifp)) {
-		char buf[32 * 1024];
+		char buf[9 * 1024];
 		size_t in = fread (buf, 1, sizeof (buf), ifp);
 		if (in > 0) {
 			if (fwrite (buf, 1, in, ofp) == 0 && ferror (ofp)) {
diff -up man-db-2.6.3/src/manp.c.valgrind-mem man-db-2.6.3/src/manp.c
--- man-db-2.6.3/src/manp.c.valgrind-mem	2013-04-05 18:19:01.412892553 +0200
+++ man-db-2.6.3/src/manp.c	2013-04-05 18:19:01.428892318 +0200
@@ -504,6 +504,7 @@ static char *get_nls_manpath (const char
 
 		closedir (mandir);
 	}
+	free (manpathlist_copy);
 
 	free_locale_bits (&lbits);
 	return manpath;
@@ -567,6 +568,7 @@ char *add_nls_manpaths (char *manpathlis
 			free (locale_manpath);
 		}
 	}
+	free (locales_copy);
 
 	/* Always try untranslated pages as a last resort. */
 	locale_manpath = get_nls_manpath (manpathlist, "C");
@@ -820,6 +822,11 @@ next:
 		free (buf);
 		buf = NULL;
 	}
+
+	if (buf) {
+		free (buf);
+		buf = NULL;
+	}
 }
 
 static void free_config_file (void *unused ATTRIBUTE_UNUSED)
diff -up man-db-2.6.3/src/whatis.c.valgrind-mem man-db-2.6.3/src/whatis.c
--- man-db-2.6.3/src/whatis.c.valgrind-mem	2012-06-18 12:23:37.000000000 +0200
+++ man-db-2.6.3/src/whatis.c	2013-04-05 18:19:01.429892304 +0200
@@ -501,7 +501,7 @@ static inline int do_whatis_section (con
 
 static int suitable_manpath (const char *manpath, const char *page_dir)
 {
-	char *page_manp;
+	char *page_manp, *pm;
 	char *page_manpathlist[MAXDIRS], **mp;
 	int ret;
 
@@ -510,7 +510,9 @@ static int suitable_manpath (const char
 		free (page_manp);
 		return 0;
 	}
-	page_manp = locale_manpath (page_manp);
+	pm = locale_manpath (page_manp);
+	free (page_manp);
+	page_manp = pm;
 	create_pathlist (page_manp, page_manpathlist);
 
 	ret = 0;
@@ -554,6 +556,7 @@ static void do_whatis (const char * cons
 					debug ("%s not on manpath for %s\n",
 					       manpath, page);
 					free (page_dir);
+					free (page);
 					continue;
 				}
 			}
